<!DOCTYPE html>
<html lang="en">
  <!-- Mathjax Support -->
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Quotidien</title>
  <meta name="description" content="Learning by teaching">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dotkay.github.io/posts/20/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Quotidien" href="https://dotkay.github.io/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Quotidien">
  <meta name="twitter:description" content="Learning by teaching">
  
  

  
  
  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105390377-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Quotidien</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Posts</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/10/06/computing-permutations/">Computing permutations - divide and conquer &rarr;</a>
          </h1>

          <p class="post-meta">Oct 6, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/c/">C++</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>In one of the <a href="https://dotkay.github.io/2017/09/21/permutations-of-a-list/">previous posts</a> we saw how to compute all permutations of a list recursively. Let us attempt the same, but this time with C++, in what is called divide and conquer approach - essentially divide the input into smaller chunks and recursively call the function on each of the smaller chunk.</p>

<p>Let us compute the permutations of say characters in a string. A string of <em>n</em> characters would have <em>n!</em> permutations. For example, if we have the string “ABC”, the permutations (6 in all) are:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ABC
ACB
BAC
BCA
CBA
CAB
</code></pre></div></div>
<p>We shall do it by going through the string of characters and iteratively swapping each character with the neighbouring character to get the permutation. For example, for the string “ABC”:</p>

<p><br />
<img src="/assets/images/algorithms/cpp/perm_1.png" alt="Permutations of &quot;ABC&quot;" class="img=responsive" /></p>

<p>Here is a function <code class="language-plaintext highlighter-rouge">permute()</code> implementing the traversal: We are given a string <em>s</em> with starting index <em>start</em> and ending index <em>end</em>.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">permute</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">start</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">swap</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="n">permute</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
      <span class="n">swap</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>What happens if we use the above algorithms to find permutations of strings that have duplicated characters? For example, the string “AAB” would produce:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AAB
ABA
AAB  (*)
ABA  (*)
BAA
BAA  (*)
</code></pre></div></div>

<p>As you can see, we are computing the same permutation more than once (marked with *). How can we modify the above function to handle duplicates?</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/10/04/closest-pair-naive/">Computing the closest pair of points - Naïve approach &rarr;</a>
          </h1>

          <p class="post-meta">Oct 4, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/c/">C++</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Given a set of points (say provided to us as <em>(x, y)</em> coordinates) on a plane, let us find the closest pair among the set. The straight forward approach would be to compute the distance of each point with every other point in the given set and store the minimum distance.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="cp">#define REP(i, n) for (int i=0; i&lt;n; i++)
#define REPK(i, k, n) for (int i=k; i&lt;n; i++)
</span>
<span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
  <span class="nl">public:</span> 
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
  <span class="nl">public:</span>
    <span class="n">Point</span> <span class="p">()</span> <span class="p">{};</span>
    <span class="n">Point</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
    <span class="k">static</span> <span class="kt">float</span> <span class="n">dist</span><span class="p">(</span><span class="n">Point</span> <span class="n">p</span><span class="p">,</span> <span class="n">Point</span> <span class="n">q</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">float</span> <span class="nf">min_distance</span> <span class="p">(</span><span class="n">Point</span> <span class="n">p</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="n">MAX_DIST</span><span class="p">;</span>
  <span class="n">REP</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">REPK</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span> 
        <span class="n">min</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
  <span class="k">return</span> <span class="n">min</span><span class="p">;</span>
  <span class="c1">// Time Complexity: O(n^2) - nested for loops (2)</span>
<span class="p">}</span></code></pre>
</figure>

<p>As you can see this is a <em>O(n^2)</em> algorithm. Can we do better than this? It turns out we can - a topic for a future post.</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/10/03/array-inversions-merge-sort/">Computing the number of inversions in an array - using divide and conquer approach &rarr;</a>
          </h1>

          <p class="post-meta">Oct 3, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/c/">C++</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>In our <a href="https://dotkay.github.io/2017/10/02/array-inversions-naive">previous post</a>, we saw an <code class="language-plaintext highlighter-rouge">O(n^2</code> algorithm to compute the number of inversions in an input array. Now, let us see how we can use divide and conquer approach to solve the same problem. We will see that we can do better than <code class="language-plaintext highlighter-rouge">O(n^2)</code> using this approach.</p>

<p>In the traditional recursive version of merge-sort, we divide the input array into two halves and call merge-sort procedure on each of the sub-arrays recursively and eventually merge the results. Suppose our input array is <code class="language-plaintext highlighter-rouge">{2, 4, 1, 3, 5}</code> and suppose that the merge-sort procedure calls are complete and that we are in the merge process. Let us say that we ended up with the following sorted subarrays and trying to merge them up into a single sorted array - <code class="language-plaintext highlighter-rouge">{2, 4}</code> and <code class="language-plaintext highlighter-rouge">{1, 3, 5}</code>. The way merge procedure works is to compare the two sub-arrays (call it <code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code>) and compare the elements one by one. First, we compare <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">1</code>, since <code class="language-plaintext highlighter-rouge">1</code> is less than <code class="language-plaintext highlighter-rouge">2</code>, we push <code class="language-plaintext highlighter-rouge">1</code> to the result array (<code class="language-plaintext highlighter-rouge">1</code> being the smaller element). And we have encountered an inversion - the index of <code class="language-plaintext highlighter-rouge">2</code> is smaller than the index of <code class="language-plaintext highlighter-rouge">1</code>. Since we know that each of the sub-arrays are sorted, elements that follow <code class="language-plaintext highlighter-rouge">2</code> in the <code class="language-plaintext highlighter-rouge">left</code> sub-array would be greater than <code class="language-plaintext highlighter-rouge">2</code> and since <code class="language-plaintext highlighter-rouge">2</code> formed an inversion with <code class="language-plaintext highlighter-rouge">1</code> (of the <code class="language-plaintext highlighter-rouge">right</code> sub-array), so will all the elements that follow <code class="language-plaintext highlighter-rouge">2</code> in the <code class="language-plaintext highlighter-rouge">left</code> sub-array. So, we already see two inversions - <code class="language-plaintext highlighter-rouge">(2, 1)</code> and <code class="language-plaintext highlighter-rouge">(4, 1)</code>. Now we move on and compare the next elements - <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">3</code> and push <code class="language-plaintext highlighter-rouge">2</code> into the result array, and move on to the next. Now, we compare <code class="language-plaintext highlighter-rouge">4</code> and <code class="language-plaintext highlighter-rouge">3</code> and since <code class="language-plaintext highlighter-rouge">3</code> is smaller, we push it into the result array - we also encounter an inversion <code class="language-plaintext highlighter-rouge">(4, 3)</code>. A pair of keen eyes would note that whenever we push an element from the <code class="language-plaintext highlighter-rouge">right</code> sub-array into the result array, we encounter (at least) an inversion and the number of inversions at that step equals the number of elements following the current element in <code class="language-plaintext highlighter-rouge">left</code> sub-array. Think over it.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="cp">#define REP(i, n) for (int i=0; i&lt;n; i++)
#define REPK(i, k, n) for (int i=k; i&lt;n; i++)
</span>
<span class="kt">int</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">inv_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// create tmp arrays for l and r</span>
  <span class="kt">int</span> <span class="n">lsz</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">rsz</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">m</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">left</span><span class="p">[</span><span class="n">lsz</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">right</span><span class="p">[</span><span class="n">rsz</span><span class="p">];</span>
  <span class="c1">// populate</span>
  <span class="n">REP</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lsz</span><span class="p">)</span>
    <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
  <span class="n">REP</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rsz</span><span class="p">)</span>
    <span class="n">right</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
  <span class="c1">// compare and merge</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">k</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">((</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">lsz</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">rsz</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
      <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
      <span class="n">inv_cnt</span> <span class="o">+=</span> <span class="n">lsz</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// fill in the left-over elements</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">lsz</span><span class="p">)</span> 
    <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">rsz</span><span class="p">)</span> 
    <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>

  <span class="k">return</span> <span class="n">inv_cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">mergesort</span> <span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">inv_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span><span class="o">+</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

    <span class="n">inv_cnt</span> <span class="o">=</span> <span class="n">mergesort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
    <span class="n">inv_cnt</span> <span class="o">+=</span> <span class="n">mergesort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="n">inv_cnt</span> <span class="o">+=</span> <span class="n">merge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">inv_cnt</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>Since we use divide and conquer, in fact we could re-purpose merge step of merge-sort as shown below to count the number of inversions, the time complexity of this approach is <code class="language-plaintext highlighter-rouge">O(nlogn)</code> which is better than our previous approach.</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/10/02/array-inversions-naive/">Computing the number of inversions in an array - naïve method &rarr;</a>
          </h1>

          <p class="post-meta">Oct 2, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/c/">C++</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Let us think about computing the number of inversions in an array. Let us also assume that our array has unique elements.</p>

<blockquote>
  <p>Two elements in an array <em>arr</em> form an inversion if <em>arr[i] &gt; arr[j]</em> for <em>i &lt; j</em>.</p>
</blockquote>

<p>For example, if <code class="language-plaintext highlighter-rouge">{2, 4, 1, 3, 5}</code> is our input array, it has 3 inversions <code class="language-plaintext highlighter-rouge">(2, 1), (4,1)</code> and <code class="language-plaintext highlighter-rouge">(4, 3)</code>. Let us look for a naïve straight-forward algorithm to solve this problem - i.e., traverse the array comparing the elements and checking if there is an inversion.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">inv_count</span> <span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">inv_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">inv_count</span><span class="o">++</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">inv_count</span><span class="p">;</span>
  <span class="c1">// Time complexity: O(n^2) (two for loops)</span>
<span class="p">}</span></code></pre>
</figure>

<p>Inversion tells us how far the array is from being sorted. For a sorted array, the number of inversions is <code class="language-plaintext highlighter-rouge">0</code> and if the array is sorted in the other order it has maximum number of inversions.</p>

<p>But can we do better than <code class="language-plaintext highlighter-rouge">O(n^2</code>?</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/10/01/array-query-sum-mo/">Computing sub-array sum given a set of queries on sub-array indices - Mo&#39;s Algorithm &rarr;</a>
          </h1>

          <p class="post-meta">Oct 1, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/c/">C++</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>In the <a href="https://dotkay.github.io/2017/09/30/array-query-sum/">previous post</a>, we saw the naïve way of computing sub-array sums, given a set of queries. Now, following the hint provided in the previous post, let us try to think what would make it better.</p>

<p>First, let us try to understand it with an example. If we had an inpur array <code class="language-plaintext highlighter-rouge">a</code> and three queries of the form <code class="language-plaintext highlighter-rouge">{0, 3}</code>, <code class="language-plaintext highlighter-rouge">{4, 8}</code> and <code class="language-plaintext highlighter-rouge">{0, 8}</code>, we were independently computing <code class="language-plaintext highlighter-rouge">a[0] + a[1] + a[2] + a[3]</code>, <code class="language-plaintext highlighter-rouge">a[4] + a[5] + a[6] + a[7]</code> and <code class="language-plaintext highlighter-rouge">a[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8]</code>. Although the sub-array sums we computed for the first two queries <code class="language-plaintext highlighter-rouge">{0, 3}</code> and <code class="language-plaintext highlighter-rouge">{4, 8}</code> could have just been reused instead of computing the sum all over again. Even in the case where the third query was of the form <code class="language-plaintext highlighter-rouge">{0, 10}</code> we could have used the results computed for the queries <code class="language-plaintext highlighter-rouge">{0, 3}</code> and <code class="language-plaintext highlighter-rouge">{4, 8}</code>. This also means that we need to compute the queries <code class="language-plaintext highlighter-rouge">{0, 3}</code> and <code class="language-plaintext highlighter-rouge">{4, 8}</code> so that we could reuse them for <code class="language-plaintext highlighter-rouge">{0, 8}</code> - i.e., if we computed <code class="language-plaintext highlighter-rouge">{0, 8}</code> first, we already lost the advantage. Which means that we need to order our queries in such a way that we compute the queries that have the potential to be reused before computing the other queries - in the above example <code class="language-plaintext highlighter-rouge">{0, 3}</code> and <code class="language-plaintext highlighter-rouge">{4, 8}</code>.</p>

<p>The ordering of queries themselves could be done in several ways. In this post, we shall look at one Mo’s algorithm that buckets the queries into a number of buckets which are a function of the size of the input array. If the input array is of size <code class="language-plaintext highlighter-rouge">n</code>, we put all the queries whose left index (<code class="language-plaintext highlighter-rouge">L</code>) ranges from 0 … \sqrt(n) -1 in the first bucket, (\sqrt n) … (2 * \sqrt(n) - 1), and so on. Within each bucket, we shall order the queries in increasing order of the right indices - the queries’ <code class="language-plaintext highlighter-rouge">R</code> values.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="c1">// a, b : two Queries to be compared in order to sort</span>
<span class="kt">bool</span> <span class="nf">compare</span><span class="p">(</span><span class="n">Query</span> <span class="n">a</span><span class="p">,</span> <span class="n">Query</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// first, sort by L if they are in different buckets</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">L</span><span class="o">/</span><span class="n">bucket</span> <span class="o">!=</span> <span class="n">b</span><span class="p">.</span><span class="n">L</span><span class="o">/</span><span class="n">bucket</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">L</span><span class="o">/</span><span class="n">bucket</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">L</span><span class="o">/</span><span class="n">bucket</span><span class="p">;</span>
  <span class="c1">// within the same bucket, queries are sorted</span>
  <span class="c1">// according to R values</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">R</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">R</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>Now, we need to adjust for over-lapping ranges in the queries. For example, if the previous (already computed) query was <code class="language-plaintext highlighter-rouge">{2, 5}</code> and the query that is currently being worked upon is <code class="language-plaintext highlighter-rouge">{4, 7}</code> then we need to discount <code class="language-plaintext highlighter-rouge">a[2]</code> and <code class="language-plaintext highlighter-rouge">a[3]</code> from the already computed sum (for <code class="language-plaintext highlighter-rouge">{2, 5}</code>) and also add <code class="language-plaintext highlighter-rouge">a[6]</code> and <code class="language-plaintext highlighter-rouge">a[7]</code> to it.</p>

<p>Very similarly, we may have to remove elements from the right as well (i.e. tracking the <code class="language-plaintext highlighter-rouge">R</code> indices). For example, if the previous range was <code class="language-plaintext highlighter-rouge">{0, 5}</code> and the current range <code class="language-plaintext highlighter-rouge">{2, 3}</code>, we need to discount <code class="language-plaintext highlighter-rouge">a[4]</code> and <code class="language-plaintext highlighter-rouge">a[5]</code> from the previous sum, as well (besides <code class="language-plaintext highlighter-rouge">a[0]</code> and <code class="language-plaintext highlighter-rouge">a[1]</code> which were taken care when we were handling L (previous paragraph)).</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="c1">// initialize the current L and R values</span>
<span class="kt">int</span> <span class="n">currL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">currR</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// initialize an accumulator for the sum</span>
<span class="kt">int</span> <span class="n">curr_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// iterate over the queries</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">L</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">R</span><span class="p">;</span>

  <span class="c1">// taking care of L</span>
  <span class="c1">// taking care of discarding</span>
  <span class="c1">// sub-parts from the sum</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">currL</span> <span class="o">&lt;</span> <span class="n">L</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">curr_sum</span> <span class="o">-=</span> <span class="n">a</span><span class="p">[</span><span class="n">currL</span><span class="p">];</span>
    <span class="n">currL</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// taking care of adding </span>
  <span class="c1">// sub-parts to the sum</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">currL</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">curr_sum</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">currL</span><span class="p">];</span>
    <span class="n">currL</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// taking care of R</span>
  <span class="c1">// adding elements to R</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">currR</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">curr_sum</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">currR</span><span class="p">];</span>
    <span class="n">currR</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// discounting elements</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">currR</span> <span class="o">&gt;</span> <span class="n">R</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">curr_sum</span> <span class="o">-=</span> <span class="n">a</span><span class="p">[</span><span class="n">currR</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="n">currR</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>Let us run this on an example. Let us assume we are provided with an input array <code class="language-plaintext highlighter-rouge">a</code> which is <code class="language-plaintext highlighter-rouge">{ 1 2 3 1 1 2 4 1 3 4 2 1 2 3 4 1 1 3 4 2 3 2 1 2 3 }</code> of size 25 (<code class="language-plaintext highlighter-rouge">n</code>) and the following 8 (<code class="language-plaintext highlighter-rouge">m</code>) queries <code class="language-plaintext highlighter-rouge">(2,4) (1,7) (0,8) (5,8) (10,15) (12,16) (17,20) (18,21)</code>. Now, since <code class="language-plaintext highlighter-rouge">n</code> is 25, we need to put the queries with L values in the range 0 … \sqrt(n) -1 in the first bucket and so on. The first bucket, for example, would initially (arranged according to L values from 0..\sqrt(25) - 1), i.e. 0..4, will have the queries <code class="language-plaintext highlighter-rouge">(0, 8) (2, 4) (1, 7)</code> and then re-ordered as per their <code class="language-plaintext highlighter-rouge">R</code> values to <code class="language-plaintext highlighter-rouge">(2, 4) (1, 7) (0, 8)</code>. The other buckets are second: <code class="language-plaintext highlighter-rouge">(5,8)</code>, third: <code class="language-plaintext highlighter-rouge">(10, 15) (12, 16)</code>, fourth: <code class="language-plaintext highlighter-rouge">(17, 20) (18, 21)</code>.</p>

<p>Take some time to work through it. It would be worth the time to enhance the understanding.</p>

        </div>
        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/21/">&laquo; Older</a>
    

    
      <a class="next" href="/posts/19/">Newer &raquo;</a>
    
  </div>



</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://dotkay.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>

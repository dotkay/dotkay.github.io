<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Quotidien</title>
  <meta name="description" content="Learning by teaching">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dotkay.github.io/posts/17/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Quotidien" href="https://dotkay.github.io/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Quotidien">
  <meta name="twitter:description" content="Learning by teaching">
  
  

  
  
  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105390377-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Quotidien</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Posts</a>
      
        
        <a class="page-link" href="https://github.com/dotkay">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/21/permutations-of-a-list/">All permutations of a list &rarr;</a>
          </h1>

          <p class="post-meta">Sep 21, 2017 • 
  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
      <a href="/categories/ocaml/">ocaml</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Let’s write a sweet short function to generate all permutations of a list. We will be using some of the built-in functions of the OCaml List module - but these are generic and it could be implemented very easily (refer to the end of this post for sample implementations). One of them is the <code class="language-plaintext highlighter-rouge">map</code> function, that accepts an input function and a list and applies that function to each element of the list. For example, if we want to square each element of an input list <code class="language-plaintext highlighter-rouge">lst</code>, call the function <code class="language-plaintext highlighter-rouge">sq_lst</code>:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">sq_lst</span> <span class="n">lst</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="n">lst</span><span class="p">;;</span></code></pre>
</figure>

<p>When we provide the function with a list <code class="language-plaintext highlighter-rouge">[1;2;3]</code>, we would obtain <code class="language-plaintext highlighter-rouge">[1;4;9]</code> as the result.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="n">sq_lst</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span>
<span class="c">(* - : int list = [1; 4; 9] *)</span></code></pre>
</figure>

<p>Another built-in function from the List module we would use is <code class="language-plaintext highlighter-rouge">flatten</code>, which just flattens a list of lists into a list. For example, if we want to flatten <code class="language-plaintext highlighter-rouge">[[1; 2]; [3; 4]; [5]]</code> into a single list:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="nn">List</span><span class="p">.</span><span class="n">flatten</span> <span class="p">[[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">];</span> <span class="p">[</span><span class="mi">3</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span> <span class="p">[</span><span class="mi">5</span><span class="p">]];;</span>
<span class="c">(* - : int list = [1; 2; 3; 4; 5] *)</span></code></pre>
</figure>

<p>Let’s focus back at the problem at hand - generating permutations of a list.</p>

<blockquote>
  <p>Permutation - all possible arrangements of a list of items, where order is important.</p>
</blockquote>

<p>For example, <code class="language-plaintext highlighter-rouge">{a,b,c} {a,c,b} {b,a,c} {b,c,a} {c,a,b} {c,b,a}</code> are permutations of <code class="language-plaintext highlighter-rouge">{a,b,c}</code>. Let’s approach this problem by first writing a function - let’s call it <code class="language-plaintext highlighter-rouge">insert</code> that would take two arguments - an element <code class="language-plaintext highlighter-rouge">x</code> to insert and a list <code class="language-plaintext highlighter-rouge">lst</code> to insert <code class="language-plaintext highlighter-rouge">x</code> into. And this function <code class="language-plaintext highlighter-rouge">insert</code> would insert <code class="language-plaintext highlighter-rouge">x</code> at all possible positions in <code class="language-plaintext highlighter-rouge">lst</code>. For example, if we have a list <code class="language-plaintext highlighter-rouge">[1;2]</code> and an element <code class="language-plaintext highlighter-rouge">0</code>, we want to insert this <code class="language-plaintext highlighter-rouge">0</code> at all possible positions in the list <code class="language-plaintext highlighter-rouge">[1;2]</code>, producing <code class="language-plaintext highlighter-rouge">[[0; 1; 2], [1; 0; 2], [1; 2; 0]]</code> - note that this is not the permutation, we are just inserting a given element into all possible positions in the list.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">[[</span><span class="n">x</span><span class="p">]]</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> 
    <span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="n">lst</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="n">el</span> <span class="o">-&gt;</span> <span class="n">h</span><span class="o">::</span><span class="n">el</span><span class="p">)</span> <span class="p">(</span><span class="n">insert</span> <span class="n">x</span> <span class="n">t</span><span class="p">));;</span></code></pre>
</figure>

<p>Since we are producing a list of lists as output, for the base case we create a list of list containing a single element - the input element <code class="language-plaintext highlighter-rouge">x</code>. The second part just applies the function to each element of the list, besides adding the element to the list itself. So, <code class="language-plaintext highlighter-rouge">x::lst</code> produces <code class="language-plaintext highlighter-rouge">[0; 1; 2]</code>, and the <code class="language-plaintext highlighter-rouge">map</code> part produces <code class="language-plaintext highlighter-rouge">[1; 0; 2]</code> (which is applying the function to the first element <code class="language-plaintext highlighter-rouge">1</code> of the list (<code class="language-plaintext highlighter-rouge">h::el</code>) - the function just adds the element <code class="language-plaintext highlighter-rouge">0</code> to the list head item <code class="language-plaintext highlighter-rouge">1</code> giving <code class="language-plaintext highlighter-rouge">1; 0</code>) and similarly <code class="language-plaintext highlighter-rouge">[1; 2; 0]</code>.</p>

<p>Now we will use this <code class="language-plaintext highlighter-rouge">insert</code> function to write our <code class="language-plaintext highlighter-rouge">perm</code> (for permutation) function, which is straight-forward given the <code class="language-plaintext highlighter-rouge">insert</code> function. We will just traverse the list and choose each item in the list and insert the item to all the positions of the rest of the list.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">perm</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">lst</span><span class="p">]</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> 
    <span class="nn">List</span><span class="p">.</span><span class="n">flatten</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="n">insert</span> <span class="n">h</span><span class="p">)</span> <span class="p">(</span><span class="n">perm</span> <span class="n">t</span><span class="p">));;</span></code></pre>
</figure>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="n">perm</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">];;</span>
<span class="c">(* - : int list list = *)</span>
<span class="c">(* [[0; 1; 2]; [1; 0; 2]; [1; 2; 0]; [0; 2; 1]; [2; 0; 1]; [2; 1; 0]] *)</span></code></pre>
</figure>

<p>Hope this was the most intuitive way to a permutation function.</p>

<p>Here’s a sample implementation of map and flatten functions - I creatively named them <code class="language-plaintext highlighter-rouge">mapp</code> and <code class="language-plaintext highlighter-rouge">flatn</code>:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">mapp</span> <span class="n">f</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">h</span> <span class="o">::</span> <span class="p">(</span><span class="n">mapp</span> <span class="n">f</span> <span class="n">t</span><span class="p">);;</span></code></pre>
</figure>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">flatn</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">aux</span> <span class="n">acc</span> <span class="n">l</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">acc</span>
    <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">aux</span> <span class="p">(</span><span class="n">acc</span> <span class="o">@</span> <span class="n">h</span><span class="p">)</span> <span class="n">t</span>
  <span class="k">in</span>
  <span class="n">aux</span> <span class="bp">[]</span> <span class="n">lst</span><span class="p">;;</span></code></pre>
</figure>


        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/20/minimum-missing-nat-number-2/">Finding the minimum missing natural number - a better way! &rarr;</a>
          </h1>

          <p class="post-meta">Sep 20, 2017 • 
  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
      <a href="/categories/ocaml/">ocaml</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>In one of the <a href="https://dotkay.github.io/2017/09/18/minimum-missing-natural-number">earlier posts</a> we saw a straight forward way to find the minimum missing natural number in a list. That solution, although very straight forward, required us to sort the list before finding the minimum missing number. The question was - can we get away without that expense of sorting that list?</p>

<p>The answer seems to be <em>yes</em>. Since we know that we are not allowing any duplicates and we consider only natural numbers, we can use a very nice property:</p>

<blockquote>
  <p>In a perfectly consecutive sequence of natural numbers, any chosen number is also the number of natural numbers less than it.</p>
</blockquote>

<p>That is, if we consider the consecutive sequence of number <code class="language-plaintext highlighter-rouge">0 1 2 3 4 5</code> and choose <code class="language-plaintext highlighter-rouge">3</code>, we see that there are exactly three natural numbers before it - <code class="language-plaintext highlighter-rouge">0 1 2</code>. A curious mind would have noted that these three numbers actually need not be in order - they should just exist. For example <code class="language-plaintext highlighter-rouge">1 0 2 3 4 5</code> has three numbers before <code class="language-plaintext highlighter-rouge">3</code>, they are not in sequence, but the fact that there are three of them assures us that nothing less than three is missing in the sequence. This is the property we are going to use to come up with a simpler search. Just like how we <a href="https://dotkay.github.io/2017/09/19/list-partitioning-and-quicksort">partitioned a list of numbers around a pivot element for quicksort</a>, we will choose an element <code class="language-plaintext highlighter-rouge">x</code> and push all the numbers less than it (in any order) to the left of it and the rest to the right of it. We will also need to keep track of the number of elements <code class="language-plaintext highlighter-rouge">num</code> to the left of the chosen number (in order to check our fancy property mentioned above). Let’s write the partition function first:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">partition</span> <span class="n">x</span> <span class="n">lst</span> <span class="o">=</span> 
  <span class="k">let</span> <span class="n">aux</span> <span class="p">(</span><span class="n">num</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="k">then</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">y</span><span class="o">::</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span>
    <span class="k">else</span> <span class="n">num</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">y</span><span class="o">::</span><span class="n">right</span>
  <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="n">aux</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="bp">[]</span><span class="o">,</span> <span class="bp">[]</span><span class="p">)</span> <span class="n">lst</span><span class="p">;;</span></code></pre>
</figure>

<p>If the number of elements tracked is equal to the chosen number, it just means that there is no missing number in the left partition (just like the example above where the number of elements less than <code class="language-plaintext highlighter-rouge">3</code> is equal to three, and we don’t have any missing natural number to the left of <code class="language-plaintext highlighter-rouge">3</code>). Now, we will use this partition function to find the missing natural number:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">min_missing_num</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="c">(* m is the least nat number - 0 *)</span> 
  <span class="k">let</span> <span class="k">rec</span> <span class="n">find_min</span> <span class="n">m</span> <span class="n">l</span> <span class="o">=</span> 
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">m</span>  <span class="c">(* we return 0 as the missing num *)</span>
               <span class="c">(* as it is the least nat num *)</span>
    <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> 
      <span class="k">let</span> <span class="p">(</span><span class="n">num</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">=</span> <span class="n">partition</span> <span class="n">h</span> <span class="n">t</span> <span class="k">in</span>
      <span class="c">(* if (num = h) left side is perfect *)</span>
      <span class="c">(* search on the right partition *)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">+</span> <span class="n">m</span> <span class="o">=</span> <span class="n">h</span><span class="p">)</span> <span class="k">then</span> <span class="n">find_min</span> <span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">right</span>
      <span class="k">else</span> <span class="n">find_min</span> <span class="n">m</span> <span class="n">left</span>
    <span class="k">in</span>
    <span class="n">find_min</span> <span class="mi">0</span> <span class="n">lst</span><span class="p">;;</span></code></pre>
</figure>

<p>Think of <code class="language-plaintext highlighter-rouge">m</code> as the accumulator - we know that <code class="language-plaintext highlighter-rouge">0</code> is the first natural number, so in case our input list is an empty one (base case), we just return the first (minimum) natural number that is missing. Is there too much going on in this? If you could work this out in a sample input, say <code class="language-plaintext highlighter-rouge">[0; 3; 2; 9; 1]</code> it would help understand it better.</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/19/list-partitioning-and-quick-sort/">List Partitioning and Quicksort &rarr;</a>
          </h1>

          <p class="post-meta">Sep 19, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
      <a href="/categories/ocaml/">ocaml</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Before we try to come up with a better solution for the problem in the <a href="https://dotkay.github.io/2017/09/18/minimum-missing-natural-number">previous post</a>, let us look at another familiar problem - Quicksort. A quick refresher of mergesort from one of the <a href="https://dotkay.github.io/2017/08/31/recursions-and-merge-sort">earlier posts</a> will make this exercise much simpler. In mergesort, we essentially wrote a <code class="language-plaintext highlighter-rouge">split</code> function to split an input list into two lists and recursively called the mergesort algorithm on each of the sub-lists produced by <code class="language-plaintext highlighter-rouge">split</code> and eventually merged them using a <code class="language-plaintext highlighter-rouge">merge</code> function that merges two lists by comparing the element at the head of the sub-lists.</p>

<p>The idea behind quicksort is similar. Instead of just splitting the list into two sub-lists, we are going to choose a <em>pivot</em> element (a fancy name for <em>just an element</em> from our input list) and split the list into two sub-lists in such a way that all the elements in the input list that are less than the pivot element would fall into one sub-list and the rest of the elements will fall into the other. Now that we are very much comfortable with writing recursive functions using accumulators, let us go ahead and write one for partitioning the list into a pair of lists (two sub-lists) given a pivot element. So, the inputs to our function are a list <code class="language-plaintext highlighter-rouge">lst</code> (to split) and a <code class="language-plaintext highlighter-rouge">pivot</code> element.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">partition</span> <span class="n">pivot</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">aux</span> <span class="p">(</span><span class="n">acc1</span><span class="o">,</span> <span class="n">acc2</span><span class="p">)</span> <span class="n">l</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">acc1</span><span class="o">,</span> <span class="n">acc2</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> 
      <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">)</span> <span class="k">then</span> <span class="n">aux</span> <span class="p">(</span><span class="n">h</span><span class="o">::</span><span class="n">acc1</span><span class="o">,</span> <span class="n">acc2</span><span class="p">)</span> <span class="n">t</span>
      <span class="k">else</span> <span class="n">aux</span> <span class="p">(</span><span class="n">acc1</span><span class="o">,</span> <span class="n">h</span><span class="o">::</span><span class="n">acc2</span><span class="p">)</span> <span class="n">t</span>
  <span class="k">in</span>
  <span class="n">aux</span> <span class="p">([]</span><span class="o">,</span> <span class="bp">[]</span><span class="p">)</span> <span class="n">lst</span><span class="p">;;</span></code></pre>
</figure>

<p>Let’s go ahead and see what it does on a sample list <code class="language-plaintext highlighter-rouge">lst1</code> which contains <code class="language-plaintext highlighter-rouge">[1; 11; 9; 3; 6; 7; 2; 29]</code>. Let’s pick <code class="language-plaintext highlighter-rouge">7</code> to be our pivot element.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">lst1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">11</span><span class="p">;</span><span class="mi">9</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">6</span><span class="p">;</span><span class="mi">7</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">29</span><span class="p">];;</span>
<span class="n">partition</span> <span class="mi">7</span> <span class="n">lst1</span><span class="p">;;</span>
<span class="c">(* - : int list * int list = ([2; 6; 3; 1], [29; 7; 9; 11]) *)</span></code></pre>
</figure>

<p>As we see, all the elements less than our pivot element, <code class="language-plaintext highlighter-rouge">7</code> in this case, are in one of the sub-lists generated by <code class="language-plaintext highlighter-rouge">partition</code> function.</p>

<p>Now, quicksort is just choosing the head element as the pivot, generating two sub-lists <code class="language-plaintext highlighter-rouge">l1</code> and <code class="language-plaintext highlighter-rouge">l2</code> and calling quicksort recursively on each of the sub-lists. Since each recursive call pushes the smaller element further towards the left, eventually when all recursive calls return, the list would be sorted in acsending order.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">quicksort</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
   <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
   <span class="o">|</span> <span class="n">x</span><span class="o">::</span><span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
   <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="k">let</span> <span class="n">l1</span><span class="o">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">partition</span> <span class="n">h</span> <span class="n">t</span> <span class="k">in</span>
     <span class="n">quicksort</span> <span class="n">l1</span> <span class="o">@</span> <span class="p">(</span><span class="n">h</span><span class="o">::</span><span class="n">quicksort</span> <span class="n">l2</span><span class="p">);;</span></code></pre>
</figure>

<p>And let us try it on <code class="language-plaintext highlighter-rouge">lst1</code>:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="n">quicksort</span> <span class="n">lst1</span><span class="p">;;</span>
<span class="c">(* - : int list = [1; 2; 3; 6; 7; 9; 11; 29] *)</span></code></pre>
</figure>

<p>This exercise will help us find a better solution to the problem of finding the minimum missing natural number from an unsorted list. Does this ring any bell?</p>


        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/18/minimum-missing-natural-number/">Let&#39;s find the minimum missing natural number... &rarr;</a>
          </h1>

          <p class="post-meta">Sep 18, 2017 • 
  
  
    
  
    
      <a href="/categories/ocaml/">ocaml</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Let’s write a program to find the minimum missing natural number. We would be given an unsorted list of natural numbers, say <code class="language-plaintext highlighter-rouge">[0;3;2;9;1;7;5]</code> and we need to return <code class="language-plaintext highlighter-rouge">4</code>. Let’s assume that there are no duplicates. And if we provide a list that does not start with <code class="language-plaintext highlighter-rouge">0</code> (natural numbers start with <code class="language-plaintext highlighter-rouge">0</code> and we assume that we provide proper input), we just return <code class="language-plaintext highlighter-rouge">0</code> as it is the smallest natural number.</p>

<p>How do we go about solving this problem. Once we look at <em>unsorted</em>, we can think of sorting the provided list first. Once we sort the list, we just need to go through the elements of the list one by one and find the missing number. As we have sorted the list already, the first missing number we encounter would be the minimum missing number.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">min_missing_num</span> <span class="n">lst</span> <span class="o">=</span> 
  <span class="k">let</span> <span class="n">sort_lst</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="n">compare</span> <span class="n">lst</span> <span class="k">in</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">find_min</span> <span class="n">sort_lst</span> <span class="o">=</span> 
    <span class="k">match</span> <span class="n">sort_lst</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">-</span><span class="mi">1</span>
    <span class="o">|</span> <span class="n">x</span><span class="o">::</span><span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>
    <span class="o">|</span> <span class="n">x</span><span class="o">::</span><span class="n">y</span><span class="o">::_</span> <span class="k">when</span> <span class="n">y</span> <span class="o">-</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>
    <span class="o">|</span> <span class="n">_</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span> <span class="n">find_min</span> <span class="n">tl</span>
  <span class="k">in</span>
  <span class="n">find_min</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">::</span><span class="n">sort_lst</span><span class="p">);;</span></code></pre>
</figure>

<p>Here, we are using OCaml List module’s sort function that has the following signature:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="c">(* - : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list = &lt;fun&gt; *)</span></code></pre>
</figure>

<p>And <code class="language-plaintext highlighter-rouge">compare</code> is a comparision function that has the following signature:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="c">(* - : 'a -&gt; 'a -&gt; int = &lt;fun&gt; *)</span></code></pre>
</figure>

<p>Essentially, <code class="language-plaintext highlighter-rouge">compare x y</code> returns 0 if <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> are equal, <code class="language-plaintext highlighter-rouge">-1</code> if <code class="language-plaintext highlighter-rouge">x &lt; y</code> and <code class="language-plaintext highlighter-rouge">1</code> if <code class="language-plaintext highlighter-rouge">x &gt; y</code>.</p>

<p>Can we do better than this algorithm for finding the minimum missing natural number? Hint: sorting the input list is not very cheap - we could avoid that.</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/07/podcast-on-success/">A podcast on Success &rarr;</a>
          </h1>

          <p class="post-meta">Sep 7, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/success/">success</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/npr/">NPR</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/ted/">TED</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Just happened to listen (again) to a TED Radio hour podcast on <em>success</em>. Although I don’t quite agree with the fragment about dirty jobs, some part of the podcast is worth listening to. Most people end up doing dirty jobs because they were less fortunate to get the kind of life the many of us were fortunate enough to get - education, encouraging family, help, opportunities, etc. To some extent, some of them continue doing dirty jobs also because we let them down as a society. We should continuously look to empower the less fortunate around us, in whatever way we can - one of the easiest is to share information and knowledge. Here’s the full podcast:</p>

<audio controls="">
<source src="https://play.podtrac.com/npr-510298/npr.mc.tritondigital.com/NPR_510298/media/anon.npr-mp3/npr/ted/2013/11/20131101_ted_01.mp3" />
</audio>


        </div>
        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/18/">&laquo; Older</a>
    

    
      <a class="next" href="/posts/16/">Newer &raquo;</a>
    
  </div>



</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://dotkay.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>

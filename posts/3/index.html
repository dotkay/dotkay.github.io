<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Quotidien</title>
  <meta name="description" content="Learning by teaching">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dotkay.github.io/posts/3/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Quotidien" href="https://dotkay.github.io/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Quotidien">
  <meta name="twitter:description" content="Learning by teaching">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105390377-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Quotidien</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Posts</a>
      
        
        <a class="page-link" href="https://github.com/dotkay">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/04/17/reverse-subarray-groups/">Reversing elements of an array in groups &rarr;</a>
          </h1>

          <p class="post-meta">Apr 17, 2018 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/data-structures/">data structures</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/arrays/">arrays</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Earlier, we <a href="https://dotkay.github.io/2018/04/05/reverse-a-subarray">saw how to reverse a sub-array</a> given the window to be reversed. How do we reverse an array in subarray groups? For example, if our input array is <code class="highlighter-rouge">[1, 2, 3, 4, 5, 6, 7, 8]</code> and group size is <code class="highlighter-rouge">3</code>, we want to reverse every group of 3 elements in the array and the remaining ones. Something like:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1 2 3 4 5 6 7 8                 -&gt; input array
(3 2 1) 4 5 6 7 8               -&gt; first group of 3 elements reversed;
                                   group denoted by (..)
(3 2 1) (6 5 4) 7 8             -&gt; second group of 3 elements reversed
(3 2 1) (6 5 4) (8 7)           -&gt; remaining elements (less than group size)
                                   reversed
</code></pre>
</div>

<p>The algorithm is very similar to the earlier one, just that we need to take care of the group boundaries while traversal and reversing, just like how we took care of boundaries while reversing subarrays.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">reverse_in_groups</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">g</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">g</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">lo</span><span class="o">++</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">hi</span><span class="o">--</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>Here, <code class="highlighter-rouge">n</code> denotes the size of the input array <code class="highlighter-rouge">arr</code> and <code class="highlighter-rouge">g</code> denotes the size of the group.</p>


        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/04/14/array-min-abs-diff/">Finding the minimum absolute difference among array elements &rarr;</a>
          </h1>

          <p class="post-meta">Apr 14, 2018 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/data-structures/">data structures</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/arrays/">arrays</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Let us see how do we compute the minimum absolute difference among elements of an array. Given that we are concerened about all the elements of the array tells us that we need to</p>

<ol>
  <li>Traverse all the elements of the array (so complexity is already O(n))</li>
  <li>Maintain a running counter that captures the minimum difference as we traverse the array - the idea is also to initialize this variable to MAX value so that we can record the minimum difference easily</li>
</ol>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">min_abs_diff</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">min_diff</span> <span class="o">=</span> <span class="n">INT8_MAX</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">int</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="n">min_diff</span><span class="p">)</span>
      <span class="n">min_diff</span> <span class="o">=</span> <span class="n">diff</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">min_diff</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>Note how we try not to overflow the array index (while evaluating <code class="highlighter-rouge">arr[i+1]</code>) by computing modulo <code class="highlighter-rouge">n</code> - the size of the array.</p>


        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/04/08/rotate-array-ccw/">Rotating an array counter clockwise around a given index &rarr;</a>
          </h1>

          <p class="post-meta">Apr 8, 2018 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/data-structures/">data structures</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/arrays/">arrays</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Given an array, how do you rotate it counter clockwise around a given input index position? i.e. If the input array was <code class="highlighter-rouge">[1, 2, 3, 4, 5, 6, 7, 8]</code>, the result of rotation around index <code class="highlighter-rouge">3</code> (that has the element 4) in the counter clockwise direction would be <code class="highlighter-rouge">[5, 6, 7, 8, 1, 2, 3, 4]</code>. The sequence of transformations the array goes through as each of the elements until the given index rotates would be:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1 2 3 4 5 6 7 8            --&gt; input array
2 3 4 5 6 7 8 1            --&gt; 1 has rotated away to the end of the array
3 4 5 6 7 8 1 2            --&gt; 2 has rotated away following 1
4 5 6 7 8 1 2 3            --&gt; now, it's 3's turn
5 6 7 8 1 2 3 4            --&gt; the element at index 3 (i.e. 4) around which we
                               wanted to rotate has also completed.
</code></pre>
</div>

<p>We can use the <a href="https://dotkay.github.io/2018/04/05/reverse-a-subarray">algorithm we developed to reverse a sub-array</a>, in order to achieve this rotation. The idea is simple:</p>

<ol>
  <li>First, reverse the sub-array consisting of elements from the beginning of the array until the pivot (around which we want to rotate the array) in place</li>
  <li>Now, rotate the remaining sub-array alone (i.e. from the pivot until the end of the array</li>
  <li>Complete it by reversing the entire array once</li>
</ol>

<div class="highlighter-rouge"><pre class="highlight"><code>1 2 3 4 5 6 7 8            --&gt; input array
4 3 2 1 5 6 7 8            --&gt; step-1 first sub-array reversed
4 3 2 1 8 7 6 5            --&gt; step-2 second sub-array reversed
5 6 7 8 1 2 3 4            --&gt; step-3 rotation of the entire array 
</code></pre>
</div>

<p>An implementation would look like:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">rotate_arr_ccw</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pivot</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">reverse_arr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pivot</span><span class="p">);</span>
  <span class="n">reverse_arr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">pivot</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">reverse_arr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</figure>


        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/04/06/isomorphic-strings/">Checking if two strings are isomorphic &rarr;</a>
          </h1>

          <p class="post-meta">Apr 6, 2018 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/data-structures/">data structures</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/strings/">strings</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Today, let us see how we can figure out if two given input strings are <em>isomorphic</em> using a time-efficient algorithm.</p>

<blockquote>
  <p>Given two strings s1 and s2 if there is a unique mapping from each of the characters of one to the other, then they are isomorphic</p>
</blockquote>

<p>For example, <code class="highlighter-rouge">anna</code> and <code class="highlighter-rouge">naan</code> are isomorphic with the mapping <code class="highlighter-rouge">a -&gt; n</code> and <code class="highlighter-rouge">n -&gt; a</code>. Similarly <code class="highlighter-rouge">aab</code> and <code class="highlighter-rouge">xxy</code> are isomorphic with the mapping <code class="highlighter-rouge">a -&gt; x</code> and <code class="highlighter-rouge">b -&gt; y</code>, while <code class="highlighter-rouge">aab</code> and <code class="highlighter-rouge">xyz</code> are not isomorphic. However, <code class="highlighter-rouge">anna</code> and <code class="highlighter-rouge">naa</code> are not isomorphic as there is no direct mapping for the last <code class="highlighter-rouge">a</code> of <code class="highlighter-rouge">anna</code> (a hint that the strings should be of equal length for them to be isomorphic).</p>

<p>An approach is to traverse one of the strings and mark the occurence of the character in the string. The nice thing about character strings is that there are only 256 <a href="https://en.wikipedia.org/wiki/ASCII">ASCII characters</a> and hence we can have a character array of size 256 to mark the occurence of characters in a string. Along with marking the occurence, we need to store the mapping of this character to the corresponding (array index) character of the second string.</p>

<ol>
  <li>During the very first encounter of a character, say the first <code class="highlighter-rouge">a</code> (index 0) in <code class="highlighter-rouge">anna</code>, we check if the corresponding index in the other string <code class="highlighter-rouge">naan</code> has already been visited.</li>
  <li>We visit it (i.e. remember it in some algorithmic way).</li>
  <li>We store the mapping of this visit (i.e. <code class="highlighter-rouge">a -&gt; n</code>).</li>
  <li>If we encounter a character again, say the last <code class="highlighter-rouge">a</code> in <code class="highlighter-rouge">anna</code>, we check for the mapping to see if the corresponding index in the second string is as per our expectations (i.e. obeys the mapping).</li>
</ol>

<p>The way we maintain the mapping is through an array <code class="highlighter-rouge">map</code> and we also maintain whether we already visited a particular character using an array <code class="highlighter-rouge">visited</code>. Since we need two additional arrays of size 256 each, there is some cost we pay for this space. However, we traverse the input array only once and so it would be <em>O(n)</em> time algorithm. These four steps are noted in the code fragment below for easier reference.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="cp">#define MAX_CHARS 26
</span><span class="kt">bool</span> <span class="nf">isomorphic</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="n">MAX_CHARS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">false</span> <span class="p">};</span>
  <span class="kt">int</span> <span class="n">map</span><span class="p">[</span><span class="n">MAX_CHARS</span><span class="p">];</span>

  <span class="c1">// initialize map
</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_CHARS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="c1">// check if both strings are of equal length
</span>  <span class="kt">int</span> <span class="n">slen1</span> <span class="o">=</span> <span class="n">s1</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">slen2</span> <span class="o">=</span> <span class="n">s2</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">slen1</span> <span class="o">!=</span> <span class="n">slen2</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

  <span class="c1">// traverse s1 and update marked and visited
</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">slen1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// (1) first occurence
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> 
    <span class="p">{</span>
      <span class="c1">// check if corresponding s2 char is visited
</span>      <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

      <span class="c1">// (2) update visited
</span>      <span class="n">visited</span><span class="p">[</span><span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>                          

      <span class="c1">// (3) store mapping
</span>      <span class="n">map</span><span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>                             
    <span class="p">}</span>
    <span class="c1">// (4) not the first occurence? check the mapping
</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>


        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/04/05/reverse-a-subarray/">Reversing a sub-array of an array in place &rarr;</a>
          </h1>

          <p class="post-meta">Apr 5, 2018 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/data-structures/">data structures</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/arrays/">arrays</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>In an <a href="https://dotkay.github.io/2018/04/02/reverse-an-array/">earlier post</a>, we saw how to reverse a given input array. But, it reversed the entire array. What if we want to pick a fragment of the input array and reverse only that?</p>

<p>Let us assume we are given the <code class="highlighter-rouge">start</code> and <code class="highlighter-rouge">end</code> indices - the window that we want to reverse. It is very similar to our previous approach, except that we need to be careful computing the indices to iterate on.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">reverse_arr</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="p">((</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">));</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">end</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">start</span><span class="p">)]);</span>
<span class="p">}</span></code></pre>
</figure>

<p>There is an <a href="https://thebittheories.com/the-curious-case-of-binary-search-the-famous-bug-that-remained-undetected-for-20-years-973e89fc212">interesting story</a> about computation of mid-point given two window boundaries. At first glance, it would seem tempting to write it as <code class="highlighter-rouge">(start + end) / 2</code> but it is safer (and more correct) to write it as <code class="highlighter-rouge">start + ((end - start) / 2)</code>.</p>


        </div>
        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/4/">&laquo; Older</a>
    

    
      <a class="next" href="/posts/2/">Newer &raquo;</a>
    
  </div>



</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://dotkay.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>

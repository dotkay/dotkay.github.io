<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Quotidien</title>
  <meta name="description" content="Learning by teaching">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dotkay.github.io/posts/18/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Quotidien" href="https://dotkay.github.io/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Quotidien">
  <meta name="twitter:description" content="Learning by teaching">
  
  

  
  
  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105390377-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Quotidien</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Posts</a>
      
        
        <a class="page-link" href="https://github.com/dotkay">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/23/binary-trees-2/">Binary Trees again &rarr;</a>
          </h1>

          <p class="post-meta">Sep 23, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/data-structures/">data structures</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
      <a href="/categories/ocaml/">ocaml</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>In the <a href="https://dotkay.github.io/2017/09/22/binary-trees">previous post</a>, we saw how to define a binary tree. Now, that we have the tree, we need to be able to insert items into the tree. So, let us write an <code class="language-plaintext highlighter-rouge">insert</code> function to do that:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Node</span> <span class="p">(</span><span class="nc">Leaf</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">tree</span><span class="p">);;</span></code></pre>
</figure>

<p>If we want to insert an element <code class="language-plaintext highlighter-rouge">0</code> into an empty tree, we just do the following:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="nc">Leaf</span><span class="p">;;</span>
<span class="c">(* val empty : 'a tree = Leaf *)</span>
<span class="n">insert</span> <span class="mi">0</span> <span class="n">empty</span><span class="p">;;</span>
<span class="c">(* - : int tree = Node (Leaf, 0, Leaf) *)</span></code></pre>
</figure>

<p>Let us try something more fun. Let’s create a tree from a list. We have worked with lists all along and it is imaginable that we would accept inputs in the form of lists, but we want to implement our algorithms (later on!..) using tree data structure. So, this function is going to be very helpful. Let’s just call the function <code class="language-plaintext highlighter-rouge">make_tree</code>.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">make_tree</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="k">in</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">empty</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">insert</span> <span class="n">h</span> <span class="p">(</span><span class="n">make_tree</span> <span class="n">t</span><span class="p">);;</span></code></pre>
</figure>

<p>Let us use our new function to create a tree from the list <code class="language-plaintext highlighter-rouge">[0; 1; 2]</code>.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="n">make_tree</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">];;</span>
<span class="c">(* - : int tree = Node (Leaf, 0, Node (Leaf, 1, Node (Leaf, 2, Leaf))) *)</span></code></pre>
</figure>

<p>Wasn’t that super easy?</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/22/binary-trees/">Binary Trees &rarr;</a>
          </h1>

          <p class="post-meta">Sep 22, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/data-structures/">data structures</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
      <a href="/categories/ocaml/">ocaml</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Let’s talk about <em>Binary Trees</em> - we cannot afford to ignore binary trees after having talked about several search algorithms. We will see many more applications of this wonderful data structure, but to get started, let’s understand what they are and how to create a simple one. Again, I am going to be using OCaml as I find it intuitive and concise. Probably, I will post the equivalent C/C++ code in later posts.</p>

<blockquote>
  <p>A Binary Tree is a tree in which each node can have at most two children</p>
</blockquote>

<p>A binary tree is just a recursive data structure with a root node and two children, which themselves could be trees or leaf nodes (that have no children). Since the children could themselves be trees, we have this recursive data structure. For example,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>             node-0
	      /  \
 	     /    \
	 node-1  node-2
	  / \      / \
         /   \    /   \
       leaf leaf leaf leaf	 

</code></pre></div></div>

<p>is how they generally look. Here, <code class="language-plaintext highlighter-rouge">node-0</code> has <code class="language-plaintext highlighter-rouge">node-1</code> and <code class="language-plaintext highlighter-rouge">node-2</code> as child nodes, which themselves are binary trees (as they have two (‘bi’) children). It could use used to represent many things. For example, a family tree:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            Mother
	     /  \
            /    \
       daughter  Son
                 / \
                _  daughter  

</code></pre></div></div>

<p>Let’s first define the type <em>binary tree</em> - we would call it just <code class="language-plaintext highlighter-rouge">tree</code>.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">tree</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Leaf</span>
  <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="n">tree</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">tree</span><span class="p">;;</span></code></pre>
</figure>

<p>This just defines the type <code class="language-plaintext highlighter-rouge">'a tree</code> - as noted in one of our <a href="https://dotkay.github.io/2017/08/17/lets-practice-some-more-examples/">earlier posts</a> ‘a is like <em>any</em> - we could have integer trees, string trees, etc. that would take different type values. So, a <code class="language-plaintext highlighter-rouge">tree</code> could either be a <code class="language-plaintext highlighter-rouge">Leaf</code> or another <code class="language-plaintext highlighter-rouge">tree</code> composed of two child trees and a root node (<code class="language-plaintext highlighter-rouge">'a</code>). Now we can create a new empty tree with just a Leaf:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Leaf</span><span class="p">;;</span>
<span class="c">(* val t : 'a tree = Leaf *)</span></code></pre>
</figure>

<p>Or we could create a tree with a root node and two child nodes, which themselves are trees with children:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">t2</span> <span class="o">=</span> <span class="nc">Node</span> <span class="p">(</span><span class="nc">Leaf</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nc">Node</span> <span class="p">(</span><span class="nc">Leaf</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Node</span> <span class="p">(</span><span class="nc">Leaf</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="nc">Leaf</span><span class="p">)));;</span>
<span class="c">(* val t2 : int tree = Node (Leaf, 1, Node (Leaf, 2, Node (Leaf, 3, Leaf))) *)</span></code></pre>
</figure>

<p>I know it looks awkward, but let’s decompose it and understand. <code class="language-plaintext highlighter-rouge">Node (Leaf, 3, Leaf)</code> is one tree. Let’s call it C. <code class="language-plaintext highlighter-rouge">Node (Leaf, 2, C)</code> is the next tree - Let’s call this guy B. <code class="language-plaintext highlighter-rouge">Node (Leaf, 1, B)</code> is the other one. So, we have something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>             1
	    / \          
           /   \
	 leaf   2                  |
	       / \                 |
              /   \                | -&gt; B
	    leaf   3       |       |
                  / \      |-&gt; C   |
		 /   \     |       |
	       leaf leaf   |       |

</code></pre></div></div>

<p>In the following post, we will write a functions to interact with this structure.</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/21/permutations-of-a-list/">All permutations of a list &rarr;</a>
          </h1>

          <p class="post-meta">Sep 21, 2017 • 
  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
      <a href="/categories/ocaml/">ocaml</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Let’s write a sweet short function to generate all permutations of a list. We will be using some of the built-in functions of the OCaml List module - but these are generic and it could be implemented very easily (refer to the end of this post for sample implementations). One of them is the <code class="language-plaintext highlighter-rouge">map</code> function, that accepts an input function and a list and applies that function to each element of the list. For example, if we want to square each element of an input list <code class="language-plaintext highlighter-rouge">lst</code>, call the function <code class="language-plaintext highlighter-rouge">sq_lst</code>:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">sq_lst</span> <span class="n">lst</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="n">lst</span><span class="p">;;</span></code></pre>
</figure>

<p>When we provide the function with a list <code class="language-plaintext highlighter-rouge">[1;2;3]</code>, we would obtain <code class="language-plaintext highlighter-rouge">[1;4;9]</code> as the result.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="n">sq_lst</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">];;</span>
<span class="c">(* - : int list = [1; 4; 9] *)</span></code></pre>
</figure>

<p>Another built-in function from the List module we would use is <code class="language-plaintext highlighter-rouge">flatten</code>, which just flattens a list of lists into a list. For example, if we want to flatten <code class="language-plaintext highlighter-rouge">[[1; 2]; [3; 4]; [5]]</code> into a single list:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="nn">List</span><span class="p">.</span><span class="n">flatten</span> <span class="p">[[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">2</span><span class="p">];</span> <span class="p">[</span><span class="mi">3</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span> <span class="p">[</span><span class="mi">5</span><span class="p">]];;</span>
<span class="c">(* - : int list = [1; 2; 3; 4; 5] *)</span></code></pre>
</figure>

<p>Let’s focus back at the problem at hand - generating permutations of a list.</p>

<blockquote>
  <p>Permutation - all possible arrangements of a list of items, where order is important.</p>
</blockquote>

<p>For example, <code class="language-plaintext highlighter-rouge">{a,b,c} {a,c,b} {b,a,c} {b,c,a} {c,a,b} {c,b,a}</code> are permutations of <code class="language-plaintext highlighter-rouge">{a,b,c}</code>. Let’s approach this problem by first writing a function - let’s call it <code class="language-plaintext highlighter-rouge">insert</code> that would take two arguments - an element <code class="language-plaintext highlighter-rouge">x</code> to insert and a list <code class="language-plaintext highlighter-rouge">lst</code> to insert <code class="language-plaintext highlighter-rouge">x</code> into. And this function <code class="language-plaintext highlighter-rouge">insert</code> would insert <code class="language-plaintext highlighter-rouge">x</code> at all possible positions in <code class="language-plaintext highlighter-rouge">lst</code>. For example, if we have a list <code class="language-plaintext highlighter-rouge">[1;2]</code> and an element <code class="language-plaintext highlighter-rouge">0</code>, we want to insert this <code class="language-plaintext highlighter-rouge">0</code> at all possible positions in the list <code class="language-plaintext highlighter-rouge">[1;2]</code>, producing <code class="language-plaintext highlighter-rouge">[[0; 1; 2], [1; 0; 2], [1; 2; 0]]</code> - note that this is not the permutation, we are just inserting a given element into all possible positions in the list.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">[[</span><span class="n">x</span><span class="p">]]</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> 
    <span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="n">lst</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="k">fun</span> <span class="n">el</span> <span class="o">-&gt;</span> <span class="n">h</span><span class="o">::</span><span class="n">el</span><span class="p">)</span> <span class="p">(</span><span class="n">insert</span> <span class="n">x</span> <span class="n">t</span><span class="p">));;</span></code></pre>
</figure>

<p>Since we are producing a list of lists as output, for the base case we create a list of list containing a single element - the input element <code class="language-plaintext highlighter-rouge">x</code>. The second part just applies the function to each element of the list, besides adding the element to the list itself. So, <code class="language-plaintext highlighter-rouge">x::lst</code> produces <code class="language-plaintext highlighter-rouge">[0; 1; 2]</code>, and the <code class="language-plaintext highlighter-rouge">map</code> part produces <code class="language-plaintext highlighter-rouge">[1; 0; 2]</code> (which is applying the function to the first element <code class="language-plaintext highlighter-rouge">1</code> of the list (<code class="language-plaintext highlighter-rouge">h::el</code>) - the function just adds the element <code class="language-plaintext highlighter-rouge">0</code> to the list head item <code class="language-plaintext highlighter-rouge">1</code> giving <code class="language-plaintext highlighter-rouge">1; 0</code>) and similarly <code class="language-plaintext highlighter-rouge">[1; 2; 0]</code>.</p>

<p>Now we will use this <code class="language-plaintext highlighter-rouge">insert</code> function to write our <code class="language-plaintext highlighter-rouge">perm</code> (for permutation) function, which is straight-forward given the <code class="language-plaintext highlighter-rouge">insert</code> function. We will just traverse the list and choose each item in the list and insert the item to all the positions of the rest of the list.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">perm</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">lst</span><span class="p">]</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> 
    <span class="nn">List</span><span class="p">.</span><span class="n">flatten</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="p">(</span><span class="n">insert</span> <span class="n">h</span><span class="p">)</span> <span class="p">(</span><span class="n">perm</span> <span class="n">t</span><span class="p">));;</span></code></pre>
</figure>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="n">perm</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">];;</span>
<span class="c">(* - : int list list = *)</span>
<span class="c">(* [[0; 1; 2]; [1; 0; 2]; [1; 2; 0]; [0; 2; 1]; [2; 0; 1]; [2; 1; 0]] *)</span></code></pre>
</figure>

<p>Hope this was the most intuitive way to a permutation function.</p>

<p>Here’s a sample implementation of map and flatten functions - I creatively named them <code class="language-plaintext highlighter-rouge">mapp</code> and <code class="language-plaintext highlighter-rouge">flatn</code>:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">mapp</span> <span class="n">f</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">h</span> <span class="o">::</span> <span class="p">(</span><span class="n">mapp</span> <span class="n">f</span> <span class="n">t</span><span class="p">);;</span></code></pre>
</figure>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">flatn</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">aux</span> <span class="n">acc</span> <span class="n">l</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">acc</span>
    <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">aux</span> <span class="p">(</span><span class="n">acc</span> <span class="o">@</span> <span class="n">h</span><span class="p">)</span> <span class="n">t</span>
  <span class="k">in</span>
  <span class="n">aux</span> <span class="bp">[]</span> <span class="n">lst</span><span class="p">;;</span></code></pre>
</figure>


        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/20/minimum-missing-nat-number-2/">Finding the minimum missing natural number - a better way! &rarr;</a>
          </h1>

          <p class="post-meta">Sep 20, 2017 • 
  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
      <a href="/categories/ocaml/">ocaml</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>In one of the <a href="https://dotkay.github.io/2017/09/18/minimum-missing-natural-number">earlier posts</a> we saw a straight forward way to find the minimum missing natural number in a list. That solution, although very straight forward, required us to sort the list before finding the minimum missing number. The question was - can we get away without that expense of sorting that list?</p>

<p>The answer seems to be <em>yes</em>. Since we know that we are not allowing any duplicates and we consider only natural numbers, we can use a very nice property:</p>

<blockquote>
  <p>In a perfectly consecutive sequence of natural numbers, any chosen number is also the number of natural numbers less than it.</p>
</blockquote>

<p>That is, if we consider the consecutive sequence of number <code class="language-plaintext highlighter-rouge">0 1 2 3 4 5</code> and choose <code class="language-plaintext highlighter-rouge">3</code>, we see that there are exactly three natural numbers before it - <code class="language-plaintext highlighter-rouge">0 1 2</code>. A curious mind would have noted that these three numbers actually need not be in order - they should just exist. For example <code class="language-plaintext highlighter-rouge">1 0 2 3 4 5</code> has three numbers before <code class="language-plaintext highlighter-rouge">3</code>, they are not in sequence, but the fact that there are three of them assures us that nothing less than three is missing in the sequence. This is the property we are going to use to come up with a simpler search. Just like how we <a href="https://dotkay.github.io/2017/09/19/list-partitioning-and-quicksort">partitioned a list of numbers around a pivot element for quicksort</a>, we will choose an element <code class="language-plaintext highlighter-rouge">x</code> and push all the numbers less than it (in any order) to the left of it and the rest to the right of it. We will also need to keep track of the number of elements <code class="language-plaintext highlighter-rouge">num</code> to the left of the chosen number (in order to check our fancy property mentioned above). Let’s write the partition function first:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">partition</span> <span class="n">x</span> <span class="n">lst</span> <span class="o">=</span> 
  <span class="k">let</span> <span class="n">aux</span> <span class="p">(</span><span class="n">num</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="n">y</span> <span class="o">=</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="k">then</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">y</span><span class="o">::</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span>
    <span class="k">else</span> <span class="n">num</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">y</span><span class="o">::</span><span class="n">right</span>
  <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="n">aux</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="bp">[]</span><span class="o">,</span> <span class="bp">[]</span><span class="p">)</span> <span class="n">lst</span><span class="p">;;</span></code></pre>
</figure>

<p>If the number of elements tracked is equal to the chosen number, it just means that there is no missing number in the left partition (just like the example above where the number of elements less than <code class="language-plaintext highlighter-rouge">3</code> is equal to three, and we don’t have any missing natural number to the left of <code class="language-plaintext highlighter-rouge">3</code>). Now, we will use this partition function to find the missing natural number:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">min_missing_num</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="c">(* m is the least nat number - 0 *)</span> 
  <span class="k">let</span> <span class="k">rec</span> <span class="n">find_min</span> <span class="n">m</span> <span class="n">l</span> <span class="o">=</span> 
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">m</span>  <span class="c">(* we return 0 as the missing num *)</span>
               <span class="c">(* as it is the least nat num *)</span>
    <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> 
      <span class="k">let</span> <span class="p">(</span><span class="n">num</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="p">)</span> <span class="o">=</span> <span class="n">partition</span> <span class="n">h</span> <span class="n">t</span> <span class="k">in</span>
      <span class="c">(* if (num = h) left side is perfect *)</span>
      <span class="c">(* search on the right partition *)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">+</span> <span class="n">m</span> <span class="o">=</span> <span class="n">h</span><span class="p">)</span> <span class="k">then</span> <span class="n">find_min</span> <span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">right</span>
      <span class="k">else</span> <span class="n">find_min</span> <span class="n">m</span> <span class="n">left</span>
    <span class="k">in</span>
    <span class="n">find_min</span> <span class="mi">0</span> <span class="n">lst</span><span class="p">;;</span></code></pre>
</figure>

<p>Think of <code class="language-plaintext highlighter-rouge">m</code> as the accumulator - we know that <code class="language-plaintext highlighter-rouge">0</code> is the first natural number, so in case our input list is an empty one (base case), we just return the first (minimum) natural number that is missing. Is there too much going on in this? If you could work this out in a sample input, say <code class="language-plaintext highlighter-rouge">[0; 3; 2; 9; 1]</code> it would help understand it better.</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/09/19/list-partitioning-and-quick-sort/">List Partitioning and Quicksort &rarr;</a>
          </h1>

          <p class="post-meta">Sep 19, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
      <a href="/categories/ocaml/">ocaml</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Before we try to come up with a better solution for the problem in the <a href="https://dotkay.github.io/2017/09/18/minimum-missing-natural-number">previous post</a>, let us look at another familiar problem - Quicksort. A quick refresher of mergesort from one of the <a href="https://dotkay.github.io/2017/08/31/recursions-and-merge-sort">earlier posts</a> will make this exercise much simpler. In mergesort, we essentially wrote a <code class="language-plaintext highlighter-rouge">split</code> function to split an input list into two lists and recursively called the mergesort algorithm on each of the sub-lists produced by <code class="language-plaintext highlighter-rouge">split</code> and eventually merged them using a <code class="language-plaintext highlighter-rouge">merge</code> function that merges two lists by comparing the element at the head of the sub-lists.</p>

<p>The idea behind quicksort is similar. Instead of just splitting the list into two sub-lists, we are going to choose a <em>pivot</em> element (a fancy name for <em>just an element</em> from our input list) and split the list into two sub-lists in such a way that all the elements in the input list that are less than the pivot element would fall into one sub-list and the rest of the elements will fall into the other. Now that we are very much comfortable with writing recursive functions using accumulators, let us go ahead and write one for partitioning the list into a pair of lists (two sub-lists) given a pivot element. So, the inputs to our function are a list <code class="language-plaintext highlighter-rouge">lst</code> (to split) and a <code class="language-plaintext highlighter-rouge">pivot</code> element.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">partition</span> <span class="n">pivot</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">aux</span> <span class="p">(</span><span class="n">acc1</span><span class="o">,</span> <span class="n">acc2</span><span class="p">)</span> <span class="n">l</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">acc1</span><span class="o">,</span> <span class="n">acc2</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> 
      <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">)</span> <span class="k">then</span> <span class="n">aux</span> <span class="p">(</span><span class="n">h</span><span class="o">::</span><span class="n">acc1</span><span class="o">,</span> <span class="n">acc2</span><span class="p">)</span> <span class="n">t</span>
      <span class="k">else</span> <span class="n">aux</span> <span class="p">(</span><span class="n">acc1</span><span class="o">,</span> <span class="n">h</span><span class="o">::</span><span class="n">acc2</span><span class="p">)</span> <span class="n">t</span>
  <span class="k">in</span>
  <span class="n">aux</span> <span class="p">([]</span><span class="o">,</span> <span class="bp">[]</span><span class="p">)</span> <span class="n">lst</span><span class="p">;;</span></code></pre>
</figure>

<p>Let’s go ahead and see what it does on a sample list <code class="language-plaintext highlighter-rouge">lst1</code> which contains <code class="language-plaintext highlighter-rouge">[1; 11; 9; 3; 6; 7; 2; 29]</code>. Let’s pick <code class="language-plaintext highlighter-rouge">7</code> to be our pivot element.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">lst1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">11</span><span class="p">;</span><span class="mi">9</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">6</span><span class="p">;</span><span class="mi">7</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">29</span><span class="p">];;</span>
<span class="n">partition</span> <span class="mi">7</span> <span class="n">lst1</span><span class="p">;;</span>
<span class="c">(* - : int list * int list = ([2; 6; 3; 1], [29; 7; 9; 11]) *)</span></code></pre>
</figure>

<p>As we see, all the elements less than our pivot element, <code class="language-plaintext highlighter-rouge">7</code> in this case, are in one of the sub-lists generated by <code class="language-plaintext highlighter-rouge">partition</code> function.</p>

<p>Now, quicksort is just choosing the head element as the pivot, generating two sub-lists <code class="language-plaintext highlighter-rouge">l1</code> and <code class="language-plaintext highlighter-rouge">l2</code> and calling quicksort recursively on each of the sub-lists. Since each recursive call pushes the smaller element further towards the left, eventually when all recursive calls return, the list would be sorted in acsending order.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">quicksort</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
   <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
   <span class="o">|</span> <span class="n">x</span><span class="o">::</span><span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
   <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="k">let</span> <span class="n">l1</span><span class="o">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">partition</span> <span class="n">h</span> <span class="n">t</span> <span class="k">in</span>
     <span class="n">quicksort</span> <span class="n">l1</span> <span class="o">@</span> <span class="p">(</span><span class="n">h</span><span class="o">::</span><span class="n">quicksort</span> <span class="n">l2</span><span class="p">);;</span></code></pre>
</figure>

<p>And let us try it on <code class="language-plaintext highlighter-rouge">lst1</code>:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="n">quicksort</span> <span class="n">lst1</span><span class="p">;;</span>
<span class="c">(* - : int list = [1; 2; 3; 6; 7; 9; 11; 29] *)</span></code></pre>
</figure>

<p>This exercise will help us find a better solution to the problem of finding the minimum missing natural number from an unsorted list. Does this ring any bell?</p>


        </div>
        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/19/">&laquo; Older</a>
    

    
      <a class="next" href="/posts/17/">Newer &raquo;</a>
    
  </div>



</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://dotkay.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>

<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Quotidien</title>
  <meta name="description" content="Learning by teaching">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dotkay.github.io/posts/6/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Quotidien" href="https://dotkay.github.io/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Quotidien">
  <meta name="twitter:description" content="Learning by teaching">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105390377-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Quotidien</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Posts</a>
      
        
        <a class="page-link" href="https://github.com/dotkay">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/12/queue_linked_list_methods/">Queue using Linked List - Operations &rarr;</a>
          </h1>

          <p class="post-meta">Nov 12, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/data-structures/">data structures</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/queues/">queues</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>In our <a href="https://dotkay.github.io/2017/11/11/queues_linked_list">previous post</a>, we saw how to model a Queue data structure using Linked List as a container for elements. Now, we will see how to implement the methods <em>enqueue()</em> and <em>dequeue()</em>.</p>

<p>This is very similar to inserting a new element to a linked list as we saw <a href="https://dotkay.github.io/2017/11/02/linked-list-insertion">earlier</a>. To insert a new item, we construct a node with that item and a <em>next</em> pointer, add it to the list and adjust the pointers.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">Queue</span><span class="o">::</span><span class="n">enqueue</span> <span class="p">(</span><span class="kt">int</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// if the queue is empty
</span>  <span class="c1">// front and rear are the same, i.e the new item
</span>  <span class="n">Node</span> <span class="o">*</span><span class="n">new_item</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">;</span>
  <span class="n">new_item</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
  <span class="n">new_item</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rear</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">front</span> <span class="o">=</span> <span class="n">rear</span> <span class="o">=</span> <span class="n">new_item</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// else add it to the rear end 
</span>  <span class="c1">// of the queue
</span>  <span class="n">rear</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_item</span><span class="p">;</span>
  <span class="n">rear</span> <span class="o">=</span> <span class="n">new_item</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p><br />
<img src="/assets/images/data_structures/queue_ll.png" alt="Queue Operations" class="img=responsive" /></p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">Queue</span><span class="o">::</span><span class="n">dequeue</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
  <span class="c1">// check if the queue is empty
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">front</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">throw</span> <span class="n">out_of_range</span><span class="p">(</span><span class="s">"Empty queue"</span><span class="p">);</span>
  
  <span class="c1">// get the item to dequeue
</span>  <span class="n">Node</span> <span class="o">*</span><span class="n">dequeue_item</span> <span class="o">=</span> <span class="n">front</span><span class="p">;</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">front</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
  <span class="n">front</span> <span class="o">=</span> <span class="n">front</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

  <span class="c1">// now, if there was only one node
</span>  <span class="c1">// to pop front would point to NULL
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">front</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">rear</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="k">delete</span> <span class="p">(</span><span class="n">dequeue_item</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Queue</span><span class="o">::</span><span class="n">is_empty</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">front</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</figure>

<p>That’s all there is in Queues!</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/11/queues_linked_list/">Queues using Linked List &rarr;</a>
          </h1>

          <p class="post-meta">Nov 11, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/data-structures/">data structures</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/queues/">queues</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>In an <a href="https://dotkay.github.io/2017/11/09/queues">earlier post</a>, we saw implementation of Queues using arrays. Now, we will use a <em>Linked List</em> to store the elements instead of an array. Since we are all linked list champs by now, we already know how to go about building a linked list given an input set of elements - create nodes that contain our elements and join the nodes using <em>next</em> pointers.</p>

<p>We will also use this example to introduce the notion of a <em>friend</em> class in C++.</p>

<blockquote>
  <p>A <em>friend class</em> F is a C++ class that can access private and protected members of another class A in which F is declared as friend. Here, a <em>Queue</em> class (F) may be allowed to access private members of a Node class (A).</p>
</blockquote>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Queue</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Queue</span> <span class="p">{</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">front</span><span class="p">,</span> <span class="o">*</span><span class="n">rear</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">Queue</span> <span class="p">();</span>
    <span class="kt">void</span> <span class="n">enqueue</span> <span class="p">(</span><span class="kt">int</span> <span class="n">item</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">is_empty</span> <span class="p">();</span>
    <span class="kt">int</span> <span class="n">dequeue</span> <span class="p">();</span>
<span class="p">};</span>

<span class="n">Queue</span><span class="o">::</span><span class="n">Queue</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">front</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">rear</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>There is also a notion of <em>friend function</em>, very similar to <em>friend class</em>:</p>
<blockquote>
  <p>A <em>friend function</em> f can be used to access private and protected members of a class A and it can be either:</p>
  <ul>
    <li>a method of a class A</li>
    <li>a global function</li>
  </ul>
</blockquote>

<p>In the following post, we will see how to implement the methods <em>enqueue()</em> and <em>dequeue()</em> for the Queue class above.</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/10/queue_operations/">Queue using Arrays - Operations &rarr;</a>
          </h1>

          <p class="post-meta">Nov 10, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/data-structures/">data structures</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/queues/">queues</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>In our <a href="https://dotkay.github.io/2017/11/09/queues">previous post</a>, we looked at the modelling of the Queue class using an <em>array</em> as the container to hold the queue elements. <em>front</em> and <em>rear</em> indicate the boundary of the queue (the first and the last elements). When we want to add a new element, we add it at the <em>rear</em>. Likewise, when we want to remove and process an element, we remove it from the <em>front</em>. That is, enqueue increments the <code class="highlighter-rouge">rear</code> member and dequeue increments the <code class="highlighter-rouge">front</code> member.</p>

<p><br />
<img src="/assets/images/data_structures/queue_arr.png" alt="Queue Operations" class="img=responsive" /></p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">Queue</span><span class="o">::</span><span class="n">enqueue</span> <span class="p">(</span><span class="kt">int</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rear</span> <span class="o">&gt;=</span> <span class="n">MAXSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">throw</span> <span class="n">out_of_range</span><span class="p">(</span><span class="s">"Queue is full. Nothing can be enqueued now."</span><span class="p">);</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">arr</span><span class="p">[</span><span class="o">++</span><span class="n">rear</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">Queue</span><span class="o">::</span><span class="n">dequeue</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rear</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">throw</span> <span class="n">out_of_range</span><span class="p">(</span><span class="s">"Can not dequeue from empty queue"</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">front</span><span class="o">++</span><span class="p">];</span>
<span class="p">}</span></code></pre>
</figure>

<p>So, when <em>front = rear</em> there is only one element and if <em>front &gt; rear</em>, the queue is empty (recollect that the <code class="highlighter-rouge">front</code> is initialized to 0 and <code class="highlighter-rouge">rear</code> is initialized to -1).</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">bool</span> <span class="n">Queue</span><span class="o">::</span><span class="n">is_empty</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">front</span> <span class="o">&gt;</span> <span class="n">rear</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</figure>

<p>Although pretty straight-forward, Queues have a variety of applications. We will soon see some applications when we discuss Graph data structures.</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/09/queues/">Queues &rarr;</a>
          </h1>

          <p class="post-meta">Nov 9, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/data-structures/">data structures</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/queues/">queues</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Let’s look at another important data structure - the <em>Queue</em>. As the name indicates, it is used just to model a queue of objects. The collection of objects in the queue will be served (or processed) much like how a queue of people in front of a ticket vending counter are served - the first one in the queue gets served first, and the last one in the queue gets served last. This kind of system is more popularly called <em>FIFO</em> (for First-In-First-Out system). Queue, is just a collection of objects - which means we can use an array to model them (to hold the objects) or alternatively we could also use a linked list (which also just holds a collection of objects). The operations on those objects should follow the FIFO order, while the container itself could be anything. Let use first model it using an array:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="cp">#define MAXSIZE 100
</span><span class="k">class</span> <span class="nc">Queue</span> <span class="p">{</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">front</span><span class="p">,</span> <span class="n">rear</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">MAXSIZE</span><span class="p">];</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">Queue</span> <span class="p">();</span>
    <span class="kt">void</span> <span class="n">enqueue</span> <span class="p">(</span><span class="kt">int</span> <span class="n">item</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">dequeue</span> <span class="p">();</span>
    <span class="kt">bool</span> <span class="n">is_empty</span> <span class="p">();</span>
<span class="p">};</span>

<span class="n">Queue</span><span class="o">::</span><span class="n">Queue</span> <span class="p">()</span> <span class="p">{</span>
  <span class="n">front</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">rear</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>We have two private members - <em>front</em> and <em>rear</em> - <em>front</em> gets served first. Objects get added to the container using the <em>enqueue()</em> method and they get processed in FIFO order using <em>dequeue()</em> method. We will look at these operations in future posts.</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/11/08/linked-list-print-reverse-rec/">Reversing a linked list using a recursive algorithm &rarr;</a>
          </h1>

          <p class="post-meta">Nov 8, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/data-structures/">data structures</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/linked-lists/">linked lists</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>In our <a href="https://dotkay.github.io/2017/11/07/linked-list-print-reverse">previous post</a>, we looked at an iterative function to reverse a linked list. I believe it was a lot of fun. Now, we shall look at a recursive function to do the same. As before, whenever you hear recursion, you should just think of the base case and the recursive steps (i.e. what is to be done in each recursive step - like printing the node’s data in our <a href="https://dotkay.github.io/2017/11/06/linked-list-print-rec">recursive print function</a>) - once this is clear, the rest would be straight forward. For reversing a linked list, at each recursive step, we need to update the pointer directions - if there is a pointer <code class="highlighter-rouge">C  --&gt;  D</code>, after the recursive call it would be <code class="highlighter-rouge">C  &lt;--  D</code>. We keep track of two pointers, <code class="highlighter-rouge">head</code> and <code class="highlighter-rouge">rest</code> (everything following <code class="highlighter-rouge">head</code>) - and recursively call the function.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">LinkedList</span><span class="o">::</span><span class="n">reverse_list_r</span> <span class="p">()</span> <span class="p">{</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">first</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
  <span class="n">rest</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">rest</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>                   <span class="c1">// base case
</span>  <span class="k">this</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">rest</span><span class="p">;</span>          <span class="c1">// move forward
</span>  <span class="k">this</span><span class="o">-&gt;</span><span class="n">reverse_list_r</span> <span class="p">();</span>    <span class="c1">// recursive call  
</span>  <span class="n">rest</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>         <span class="c1">// update pointers
</span>  <span class="n">first</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>I will leave it as an (interesting) exercise for the reader to work out this function as we did for the iterative case.</p>

        </div>
        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/7/">&laquo; Older</a>
    

    
      <a class="next" href="/posts/5/">Newer &raquo;</a>
    
  </div>



</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://dotkay.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>

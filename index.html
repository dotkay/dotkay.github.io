<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Quotidien</title>
  <meta name="description" content="Learning by teaching">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://quotidien.github.io/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Quotidien" href="https://quotidien.github.io/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Quotidien">
  <meta name="twitter:description" content="Learning by teaching">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Quotidien</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Posts</a>
      
        
        <a class="page-link" href="https://github.com/dotkay">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/08/18/lets-play-with-some-pokemon-data-1/">Let&#39;s play with some Pokemon data - 1 &rarr;</a>
          </h1>

          <p class="post-meta">Aug 18, 2017 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/data-analysis/">data analysis</a>,
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/python/">python</a>
    
  

</p>
        </header>

        <div class="post-content">
          <p>Let’s take a small break from OCaml and recursion and learn some data analysis. For this purpose, I am using python and a couple of libraries like <a href="http://pandas.pydata.org/">Pandas</a>, <a href="http://www.numpy.org/">Numpy</a> and <a href="https://matplotlib.org/">Matplotlib</a>, which will help us in preprocessing the data, some numerical data-types as well as plotting the data, respectively. In future posts, we will see more such awesome libraries.</p>

<p>For this post, let’s just focus on a Pokemon dataset that I happened to come across in Kaggle. Although I have never played Pokemon and never knew the different Pokemon characters, this is a nice simple example to get us started.</p>

<p>You may want to install python - I personally like <a href="https://www.continuum.io/downloads">Anaconda</a> because it offers a wonderful platform with code editor as well as a console for visualization, etc., which makes it easy to play around and learn. I installed Anaconda and use their development environment <a href="https://github.com/spyder-ide/spyder">Spyder</a>.</p>

<p>Let’s get started right away. First, we import the libraries we will use for this short tutorial.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span></code></pre></figure>

<p>We will use these libraries only very minimally for this short post, but they are very powerful and we will see more of their features in future posts. If you create a (free) account in Kaggle, you can download the Pokemon dataset. I have downloaded it and saved it in a file named <code class="highlighter-rouge">Pokemon.csv</code>. We will use Pandas <code class="highlighter-rouge">read_csv</code> function to read the downloaded csv file.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">pokemon_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'Pokemon.csv'</span><span class="p">)</span></code></pre></figure>

<p>We will call it <code class="highlighter-rouge">pokemon_data</code>. Pandas refers to this type as a <code class="highlighter-rouge">dataframe</code>. If you look at the dataset the first column is just an index, so it’s useless for our analysis purposes. So we will go ahead and grab only the rest of the columns (and all the rows).</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">pokemon_data</span> <span class="o">=</span> <span class="n">pokemon_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">13</span><span class="p">]</span></code></pre></figure>

<p>Here <code class="highlighter-rouge">[:, 1:13]</code> says that “grab all the rows (denoted by <code class="highlighter-rouge">:</code>) and columns <code class="highlighter-rouge">1</code> to <code class="highlighter-rouge">13</code>. Now, let’s explore the data a bit. It’s always a good idea to take a quick look at the dataset to see what are the different columns and what kinds of values or informations they indicate about the dataset. In this case, I see that there’s a column called <code class="highlighter-rouge">Generation</code> and it seems to take values between <code class="highlighter-rouge">1</code> and <code class="highlighter-rouge">6</code>. Probably there are six generations of Pokemons, at least to my understanding. Now, let’s try to see how many Pokemons are there in each generation. If it were a population dataset, this is analogous to finding out how many people are in each continent, or something like that. I will call the number of generations by the variable <code class="highlighter-rouge">no_gens</code>. We need to pick the column named <code class="highlighter-rouge">Generation</code> and count the number of unique entries. Since there are <code class="highlighter-rouge">800</code> Pokemons in all and they belong to one of the <code class="highlighter-rouge">6</code> generations, there will be multiple rows that contain the same value for <code class="highlighter-rouge">Generation</code> and hence we need to find the number of unique values (which after having a quick look at the dataset we know is <code class="highlighter-rouge">6</code>, but it is always better to confirm algorithmically and store in a variable). We achieve this by the function <code class="highlighter-rouge">unique()</code> applying it on the column. We extract the specific column by using the column label, in this case <code class="highlighter-rouge">Generation</code>. Similarly we count the number of values in each generation using the function <code class="highlighter-rouge">value_counts()</code></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">no_gens</span> <span class="o">=</span> <span class="n">pokemon_data</span><span class="p">[</span><span class="s">'Generation'</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
<span class="n">count_per_gen</span> <span class="o">=</span> <span class="n">pokemon_data</span><span class="p">[</span><span class="s">'Generation'</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span></code></pre></figure>

<p>Let’s try to plot the above values to have a better visual representation. I will use matplotlib’s pyplot library utilities for this purpose. It is very simple and intuitive to use. We will plot a bar chart - so we need to find out the values for <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> axes. Let’s first label the plot and the axes.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Generations'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Number of Pokemons'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Number of Pokemons of each generation'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">no_gens</span><span class="p">,</span> <span class="n">count_per_gen</span><span class="p">)</span></code></pre></figure>

<p>This would result in a plot as shown below:
<br />
<img src="/assets/images/data_science/pokemon_generations.png" alt="Pokemons of each generation" /> “Number of Pokemons of each generation”)</p>

<p>That was pretty quick. Let me stop here and let you all digest the information presented. We will analyze the Pokemon dataset more in the coming posts.</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/08/17/lets-practice-some-more-examples/">Let&#39;s practice some more recursion! &rarr;</a>
          </h1>

          <p class="post-meta">Aug 17, 2017 • 
  
  
    
  
    
      <a href="/categories/ocaml/">ocaml</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Let’s continue from our <a href="https://dotkay.github.io/2017/08/15/more-simple-recursion-examples">earlier post</a> and practice some more simple problems just to get more and more familiar with recursion.</p>

<p>Let’s start by writing a simple function to find the last element of a given list <code class="highlighter-rouge">lst</code>:</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">last_elem</span> <span class="n">lst</span> <span class="p">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="p">|</span> <span class="bp">[]</span> <span class="p">-&gt;</span> <span class="nc">None</span>
  <span class="p">|</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">-&gt;</span> <span class="nc">Some</span> <span class="n">x</span>
  <span class="p">|</span> <span class="n">h</span><span class="p">::</span><span class="n">t</span> <span class="p">-&gt;</span> <span class="n">last_elem</span> <span class="n">t</span><span class="p">;;</span>
<span class="c">(* val last_elem : 'a list -&gt; 'a option = &lt;fun&gt; *)</span></code></pre></figure>

<p>This is also a nice way to introduce <code class="highlighter-rouge">Some</code> and <code class="highlighter-rouge">None</code> in OCaml. Just like how we have <code class="highlighter-rouge">'a list</code> which can be an <code class="highlighter-rouge">int list</code> or a <code class="highlighter-rouge">string list</code> or <code class="highlighter-rouge">char list</code>, OCaml also has this wonderful <code class="highlighter-rouge">'a option</code> type that can be nothing (<code class="highlighter-rouge">None</code>) or some type (<code class="highlighter-rouge">Some</code>). Note however that <code class="highlighter-rouge">'a option</code> type is not the same as <code class="highlighter-rouge">'a</code>. So, if the type is <code class="highlighter-rouge">'a</code> you can ask the compiler to treat it as an <code class="highlighter-rouge">int</code>, for example. But you can’t do the same with <code class="highlighter-rouge">'a option</code> type. For friends of Java, C programming languages, you can think of <code class="highlighter-rouge">None</code> as similar to <code class="highlighter-rouge">null</code> type.</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">option</span> <span class="p">=</span> <span class="nc">Some</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="p">|</span> <span class="nc">None</span></code></pre></figure>

<p>For those JavaScript fans wondering if they can use similar <code class="highlighter-rouge">Some</code> and <code class="highlighter-rouge">None</code> in JavaScript, I found an <a href="https://github.com/mwilliamson/node-options">option type implementation here</a> that provides this. I should admit that I have never used this implementation but it seems to serve the same purpose for JavaScript.</p>

<p>Let’s test our <code class="highlighter-rouge">last_elem</code> function on an example.</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">l1</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="o">];;</span>
<span class="n">last_elem</span> <span class="n">l1</span><span class="p">;;</span>
<span class="c">(* - : int option = Some 4 *)</span></code></pre></figure>

<p>Let’s move on and practice some more examples. Let’s now try and grab the last and the last-but-one elements from a list.</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">last_two</span> <span class="n">lst</span> <span class="p">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="p">|</span> <span class="bp">[]</span> <span class="p">|</span> <span class="o">[_]</span> <span class="p">-&gt;</span> <span class="nc">None</span>
  <span class="p">|</span> <span class="p">[</span><span class="n">x</span><span class="p">;</span> <span class="n">y</span><span class="p">]</span> <span class="p">-&gt;</span> <span class="nc">Some</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="p">|</span> <span class="o">_::</span><span class="n">t</span> <span class="p">-&gt;</span> <span class="n">last_two</span> <span class="n">t</span><span class="p">;;</span>
<span class="c">(* val last_two : 'a list -&gt; ('a * 'a) option = &lt;fun&gt; *)</span></code></pre></figure>

<p><code class="highlighter-rouge">('a * 'a)</code> indicates a tuple - a pair in this case. For example, <code class="highlighter-rouge">(3, 4)</code> would be of type <code class="highlighter-rouge">(int * int)</code>. Let’s check our implementation:</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="n">last_two</span> <span class="n">l1</span><span class="p">;;</span>
<span class="c">(* - : (int * int) option = Some (3, 4) *)</span></code></pre></figure>

<p>Let’s now make it more generic and write a function to find the k<sup>th</sup> element of a list and let’s give our function a very creative name <code class="highlighter-rouge">kth</code>.</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">kth</span> <span class="n">lst</span> <span class="n">k</span> <span class="p">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="p">|</span> <span class="bp">[]</span> <span class="p">-&gt;</span> <span class="nc">None</span>
  <span class="p">|</span> <span class="n">h</span><span class="p">::</span><span class="n">t</span> <span class="p">-&gt;</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="p">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">then</span> <span class="p">(</span><span class="nc">Some</span> <span class="n">h</span><span class="p">)</span>
     <span class="k">else</span> <span class="n">kth</span> <span class="n">t</span> <span class="p">(</span><span class="n">k</span><span class="p">-</span><span class="mi">1</span><span class="o">);;</span>
<span class="c">(* val kth : 'a list -&gt; int -&gt; 'a option = &lt;fun&gt; *)</span></code></pre></figure>

<p>Let’s check our implementation on <code class="highlighter-rouge">l1</code> again:</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="n">kth</span> <span class="n">l1</span> <span class="mi">2</span><span class="p">;;</span>
<span class="c">(* - : int option = Some 2 *)</span>
<span class="n">kth</span> <span class="n">l1</span> <span class="mi">6</span><span class="p">;;</span>
<span class="c">(* - : int option = None *)</span></code></pre></figure>

<p>When we try to find the 6<sup>th</sup> element of the list <code class="highlighter-rouge">l1</code>, we get <code class="highlighter-rouge">None</code> type as a result as the list contains only 4 elements.</p>

<p>Let’s now try to reverse an input list. Relax! It just sounds complicated. It is actually super simple when you think in terms of recursion.</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">lst_rev</span> <span class="n">lst</span> <span class="p">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="p">|</span> <span class="bp">[]</span> <span class="p">-&gt;</span> <span class="bp">[]</span>
  <span class="p">|</span> <span class="n">h</span><span class="p">::</span><span class="n">t</span> <span class="p">-&gt;</span>
     <span class="p">(</span><span class="n">lst_rev</span> <span class="n">t</span><span class="p">)</span> <span class="o">@</span> <span class="p">[</span><span class="n">h</span><span class="o">];;</span>
<span class="c">(* val lst_rev : 'a list -&gt; 'a list = &lt;fun&gt; *)</span></code></pre></figure>

<p>Recall from our previous post that <code class="highlighter-rouge">@</code> is the OCaml operator for list concatenation. It is a straight forward observation that after the first recursive call to <code class="highlighter-rouge">rev_lst</code>, the head element <code class="highlighter-rouge">h</code> is pushed to the last and in each recursive call the first element would keep getting pushed to the end of the result list.</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="n">lst_rev</span> <span class="n">l1</span><span class="p">;;</span>
<span class="c">(* - : int list = [4; 3; 2; 1] *)</span></code></pre></figure>

<p>This post is getting long. Please don’t stop reading it! I promise, just one more example to finish this post! Let’s write a function to remove an element from k<sup>th</sup> position in a given list:</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">rem_kth</span> <span class="n">k</span> <span class="n">lst</span> <span class="p">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="p">|</span> <span class="bp">[]</span> <span class="p">-&gt;</span> <span class="bp">[]</span>
  <span class="p">|</span> <span class="n">h</span><span class="p">::</span><span class="n">t</span> <span class="p">-&gt;</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="p">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">then</span> <span class="n">t</span>
     <span class="k">else</span> <span class="n">h</span><span class="o">::(</span><span class="n">rem_kth</span> <span class="p">(</span><span class="n">k</span><span class="p">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">t</span><span class="o">);;</span>
<span class="c">(* val rem_kth : int -&gt; 'a list -&gt; 'a list = &lt;fun&gt; *)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="n">rem_kth</span> <span class="mi">1</span> <span class="n">l1</span><span class="p">;;</span>
<span class="c">(* - : int list = [2; 3; 4] *)</span>
<span class="n">rem_kth</span> <span class="mi">6</span> <span class="n">l1</span><span class="p">;;</span>
<span class="c">(* - : int list = [1; 2; 3; 4] *)</span></code></pre></figure>

<p>That’s all folks. If you have reached this line of this post (assuming you didn’t start reading from the last line), Congratulations for sticking around!</p>


        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/08/16/interesting-podcast-on-education/">An interesting podcast on education &rarr;</a>
          </h1>

          <p class="post-meta">Aug 16, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/education/">education</a>,
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/npr/">NPR</a>,
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/ted/">TED</a>
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>A break from recursions and algorithms for today! But still sticking to the broader goal of education and learning. I am a big fan of radio programs and in particular NPR. Over the weekend, I happened to listen to a very interesting program on education. Hosted by <a href="http://www.npr.org/people/6597623/guy-raz">Guy Raz</a>, last week’s episode of <a href="http://www.npr.org/programs/ted-radio-hour/">TED Radio Hour</a> focussed on education and learning - specifically how it is changing with technology. It was a very interesting podcast and I really encourage all of you to make some time to listen to it. Below is a link to the podcast.</p>

<audio controls="">
<source src="https://play.podtrac.com/npr-510298/npr.mc.tritondigital.com/NPR_510298/media/anon.npr-mp3/npr/ted/2017/08/20170811_ted_tedpod.mp3" />
</audio>
<p><br />
It is an added motivation for me to use more avenues to share my knowledge with the many in this world, as much as I learn through the many channels and from the many wonderful people on this planet.</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/08/15/more-simple-recursion-examples/">Some more recursion examples &rarr;</a>
          </h1>

          <p class="post-meta">Aug 15, 2017 • 
  
  
    
  
    
      <a href="/categories/ocaml/">ocaml</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Continuing with our <a href="http://dotkay.github.io/2017/08/14/ocaml-recursion-simple/">previous post</a> on recursions, let’s play with a couple of more simple examples to get ourselves familiar. This is just to start thinking in terms of recursive functions for the problems we try to solve. This kind of thinking will become more useful when we learn about tail recursion in one of the future posts.</p>

<p>Let’s write a small function, call it <code class="highlighter-rouge">find</code>, to find if a given element belongs to a list. i.e., we are provided with an input list <code class="highlighter-rouge">lst</code> of integers and an integer <code class="highlighter-rouge">x</code> and the function would return <code class="highlighter-rouge">true</code> if <code class="highlighter-rouge">x</code> is one of the elements of <code class="highlighter-rouge">lst</code> and <code class="highlighter-rouge">false</code> otherwise.</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">find</span> <span class="n">x</span> <span class="n">lst</span> <span class="p">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="p">|</span> <span class="bp">[]</span> <span class="p">-&gt;</span> <span class="bp">false</span>
  <span class="p">|</span> <span class="n">h</span><span class="p">::</span><span class="n">t</span> <span class="p">-&gt;</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="p">=</span> <span class="n">x</span><span class="p">)</span> <span class="k">then</span> <span class="bp">true</span>
     <span class="k">else</span> <span class="p">(</span><span class="n">find</span> <span class="n">x</span> <span class="n">t</span><span class="o">);;</span>
<span class="c">(* val find : 'a -&gt; 'a list -&gt; bool = &lt;fun&gt; *)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="n">find</span> <span class="mi">2</span> <span class="n">l1</span><span class="p">;;</span>
<span class="c">(* - : bool = true *)</span>
<span class="n">find</span> <span class="mi">0</span> <span class="n">l1</span><span class="p">;;</span>
<span class="c">(* - : bool = false *)</span></code></pre></figure>

<p>As before, we think of the base case and the recursive step. We recursively call the function on a sub-list of the input list, till the problem reduces to the base case - the empty list.</p>

<p>Let’s try another simple examples - to find the minimum integer in the given list of integers. We will call the function <code class="highlighter-rouge">find_min</code> and it takes an input list <code class="highlighter-rouge">lst</code>.</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="k">exception</span> <span class="nc">Failure</span> <span class="k">of</span> <span class="kt">string</span>                   
<span class="k">let</span> <span class="k">rec</span> <span class="n">find_min</span> <span class="n">lst</span> <span class="p">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="p">|</span> <span class="bp">[]</span> <span class="p">-&gt;</span> <span class="n">failwith</span><span class="p">(</span><span class="s2">"empty list"</span><span class="p">)</span>
  <span class="p">|</span> <span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="p">-&gt;</span> <span class="n">h</span>
  <span class="p">|</span> <span class="n">h</span><span class="p">::</span><span class="n">t</span> <span class="p">-&gt;</span> <span class="n">min</span> <span class="n">h</span> <span class="p">(</span><span class="n">find_min</span> <span class="n">t</span><span class="o">);;</span>
<span class="c">(* val find_min : 'a list -&gt; 'a = &lt;fun&gt; *)</span></code></pre></figure>

<p>Let’s test it out:</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="n">find_min</span> <span class="n">l1</span><span class="p">;;</span>
<span class="c">(* - : int = 1 *)</span>
<span class="k">let</span> <span class="n">l2</span> <span class="p">=</span> <span class="o">[-</span><span class="mi">2</span><span class="p">;</span> <span class="p">-</span><span class="mi">10</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">9</span><span class="p">;</span> <span class="mi">11</span><span class="p">;</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">17</span><span class="o">];;</span>
<span class="n">find_min</span> <span class="n">l2</span><span class="p">;;</span>
<span class="c">(* - : int = -10 *)</span></code></pre></figure>

<p>Let’s now move away from having lists as input, and work on an example that produces an output list. This is a very familiar introductory CS example - converting an input decimal number to it’s base-2 (<code class="highlighter-rouge">binary</code>) representation. Humans naturally count in base-10 (also called <code class="highlighter-rouge">decimal</code>) number system, probably because most of us were born with 10 fingers. Computers, to be technically correct I should say digital circuits, work on base-2 number system - they know <code class="highlighter-rouge">0</code> and <code class="highlighter-rouge">1</code>. Just like how we count 0 .. 9 and then start counting 10 .. 19, followed by 20 .. 29, etc., digital circuits  count 0, 1 followed by 10, 11 and then follow that by 100, 101, and 110,  111, etc. You see the pattern. Probably, it is more apparent if I write it one after the other:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  base-2    	   	  base-10
     0  	  	     0
     1  	  	     1
    10 	 &lt;-- restart	     2
    11 		 	     3
   100   &lt;-- restart 	     4
   101 	 	     	     5
   110 	 	     	     6
   111 	 	     	     7
  1000 	 &lt;-- restart 	     8
  1001 	 	     	     9
  1010 	 	    	    10   &lt;-- restart
  1011 	  	       	    11 
  1100           	    12
  1101           	    13
  1110           	    14
  1111           	    15
</code></pre>
</div>

<p>The usual way we compute the binary representation of a decimal number is to repeatedly divide it and collect the remainders. For example, if we want to compute the binary equivalent of decimal 7:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>2 |_ 7 _          ^
  2 |_ 3 _   - (1) |
    2 |_ 1 _ - (1) |
         ----------&gt;
</code></pre>
</div>

<p>111 is the binary equivalent of decimal 7. Here, 3, 1 are quotients (<code class="highlighter-rouge">n/2</code> - n being the input number initally and then the quotient) and the ones on the right within parantheses are the remainders (<code class="highlighter-rouge">n mod 2</code>).</p>

<p>Let’s work out one more example - the binary equivalent of 13:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>2 |_ 13 _               ^
  2 |_ 6 _        - (1) |
    2 |_ 3 _      - (0) |
      2 |_ 1 _    - (1) |
                --------&gt;
</code></pre>
</div>

<p>If you observe carefully, what we are doing essentially is repeatedly dividing the input number <code class="highlighter-rouge">n</code> by the base we want to convert our number to - in this case base-2, and collect the remainders. Dividing a number is the expression <code class="highlighter-rouge">n/2</code> for algorithmic purposes and the remainder is the expression <code class="highlighter-rouge">n mod 2</code>. What we are going to do is to repeatedly (think “recursively”) divide <code class="highlighter-rouge">n</code> and collect the remainder in a list which we would eventually return as the output result. <code class="highlighter-rouge">@</code> is the OCaml syntax for list concatenation: for example <code class="highlighter-rouge">lst1 @ lst2</code> will concatenate <code class="highlighter-rouge">lst1</code> and <code class="highlighter-rouge">lst2</code>. Note the base case for our computation.</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">bin_of_dec</span> <span class="n">n</span> <span class="p">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="bp">[]</span>
  <span class="k">else</span> <span class="n">bin_of_dec</span> <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">@</span>
         <span class="p">(</span><span class="n">n</span> <span class="ow">mod</span> <span class="mi">2</span><span class="o">)::[];;</span>
<span class="c">(* val bin_of_dec : int -&gt; int list = &lt;fun&gt; *)</span></code></pre></figure>

<p>Let’s check if what we worked out for 7 and 13 are consistent with what this program computes:</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="n">bin_of_dec</span> <span class="mi">7</span><span class="p">;;</span>
<span class="c">(* - : int list = [1; 1; 1] *)</span>
<span class="n">bin_of_dec</span> <span class="mi">13</span><span class="p">;;</span>
<span class="c">(* - : int list = [1; 1; 0; 1] *)</span></code></pre></figure>

<p>I guess it became a longer post than what I intended it to be, but I hope you are getting a better hang of thinking recursively. We will see more examples in future posts - feel motivated to play around with some examples in the mean time!!</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/08/14/ocaml-recursion-simple/">Let&#39;s play with some simple recursion &rarr;</a>
          </h1>

          <p class="post-meta">Aug 14, 2017 • 
  
  
    
  
    
      <a href="/categories/ocaml/">ocaml</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Recursion has been one of my favourite concepts for a very long time much like my fascination for mathematical induction. The subtle differences between the two would be a topic for a separate post.</p>

<p>Let’s do some simple recursive functions just to illustrate the beauty. I chose <a href="http://www.ocaml.org">OCaml</a> for this post as it is one of my favourite programming languages. Somehow, I feel that many algorithms when coded in OCaml look very intuitive and understandable than in other imperative programming languages. We will look at some algorithms in both OCaml and C in a later post and leave it to the reader to decide as to which one looks more intuitive.</p>

<p>OCaml is a very nice functional programming language and it offers <code class="highlighter-rouge">list</code> as a primitive data type. For example, if we want a list of five integers, this is how we do it in OCaml:</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">l1</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="o">];;</span></code></pre></figure>

<p>We would usually think of the list data type itself to be a recursive definition. i.e., a list is made of either an empty list or a list composed of a <code class="highlighter-rouge">head</code> element and <code class="highlighter-rouge">tail</code> where tail itself is a list (possibly empty list). For example, in the list <code class="highlighter-rouge">l1</code> above, <code class="highlighter-rouge">1</code> constitutes the head element and the tail corresponds to the list <code class="highlighter-rouge">2;3;4;5</code>.</p>

<p>Now, let’s write a recursive function to count the number of elements in the list.</p>

<ol>
  <li>Let’s think of the base case: when the list is empty - in which case we just return <code class="highlighter-rouge">0</code> as the result.</li>
  <li>And let’s build our thought process this way - what if the list has just one element? This would correspond to a list where there is a single head element and an empty list as the tail. i.e., we count the single head element and the empty list (the tail) we know contributes <code class="highlighter-rouge">0</code> to our result (the base case we just saw in 1.).</li>
  <li>Now, when the list has 2 elements, we think of it as having a head element and a tail list that consists of a single element. Now, we count the head element and apply the same function (our counting) to count the number of elements in the tail list (which now corresponds to the case we saw in 2.).</li>
</ol>

<p>Essentially what we are doing is:</p>

<ol>
  <li>If the list is empty, return 0 as the result</li>
  <li>If the list is not empty, count the head element (1) and call the function (recursively) to count the number of elements in the tail</li>
</ol>

<p>Now, let’s write the above two steps in the following program which we call <code class="highlighter-rouge">lst_len</code> (for list length), that takes a single input parameter <code class="highlighter-rouge">lst</code>:</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">lst_len</span> <span class="n">lst</span> <span class="p">=</span> 
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="p">|</span> <span class="bp">[]</span> <span class="p">-&gt;</span> <span class="mi">0</span>
  <span class="p">|</span> <span class="n">h</span><span class="p">::</span><span class="n">t</span> <span class="p">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">lst_len</span> <span class="n">t</span><span class="p">;;</span>
<span class="c">(* val len_lst : 'a list -&gt; int = &lt;fun&gt; *)</span></code></pre></figure>

<p>Recursive functions in OCaml are defined with <code class="highlighter-rouge">rec</code> keyword. Let’s use this function to count the number of elements in our list <code class="highlighter-rouge">l1</code>:</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="n">lst_len</span> <span class="n">l1</span><span class="p">;;</span>
<span class="c">(* - : int = 5 *)</span></code></pre></figure>

<p>Let’s use the same thought process to write a recursive function <code class="highlighter-rouge">lst_sum</code> to sum up (add) the elements of the list.</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">lst_sum</span> <span class="n">lst</span> <span class="p">=</span> 
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="p">|</span> <span class="bp">[]</span> <span class="p">-&gt;</span> <span class="mi">0</span>
  <span class="p">|</span> <span class="n">h</span><span class="p">::</span><span class="n">t</span> <span class="p">-&gt;</span> <span class="n">h</span> <span class="o">+</span> <span class="n">lst_sum</span> <span class="n">t</span><span class="p">;;</span>
<span class="c">(* val lst_sum : int list -&gt; int = &lt;fun&gt; *)</span></code></pre></figure>

<p>And let’s use this function to sum up the elements in our list <code class="highlighter-rouge">l1</code>:</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="n">lst_sum</span> <span class="n">l1</span><span class="p">;;</span>
<span class="c">(* - : int = 15 *)</span></code></pre></figure>

<p>Isn’t this intuitive and elegant way of programming? We’ll talk more about simple programs that can be written in an intuitive way and try to develop our understanding of the concepts in a clear way.</p>

<p>Thanks for your interest and keep checking out this space for more.</p>


        </div>
        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/2/">&laquo; Older</a>
    

    
  </div>



</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://quotidien.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>

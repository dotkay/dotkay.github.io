<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Quotidien</title>
  <meta name="description" content="Learning by teaching">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dotkay.github.io/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Quotidien" href="https://dotkay.github.io/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Quotidien">
  <meta name="twitter:description" content="Learning by teaching">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105390377-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Quotidien</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Posts</a>
      
        
        <a class="page-link" href="https://github.com/dotkay">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="home">

  

  

  <ul class="post-list">
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2018/07/15/hidden-brain-languages-mind/">Languages, mind and our way of thinking... &rarr;</a>
          </h1>

          <p class="post-meta">Jul 15, 2018 • 
  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/psychology/">psychology</a>,
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/languages/">languages</a>,
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/npr/">NPR</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Allez les Bleus!!</p>

<p>Just happened to listen to this week’s episode of one of the recent NPR podcast series titled <a href="https://www.npr.org/series/423302056/hidden-brain">Hidden Brain</a> and it got me thinking a lot. I speak almost 5 languages (not fluently but to different degrees of expertise) and I am not sure how my mind thinks. One thing for sure though is that I happen to think in my mother tongue and my mind translates it in (almost) real-time while I communicate, be it talking or writing down my thoughts as I do while writing this blog post. If languages do influence our thinking and understanding and more importantly the biases we cultivate, what does it mean for language translators - do they also convey the biases that are inherently influenced by one’s language? Or as a technologist I am also inclined to think what would it mean for AI systems (say chat-bots) that are meant to facilitate communication? I now tend to believe that they have to be designed with the intricacies of languages and the influences, biases that it carries along encoded into the system in order for it to be more acceptable. Even if not as a chat-bot, it would be a great system to train people to work with people of different cultures so that we understand different cultures better and comfortably communicate taking into account their nuances.</p>

<p>If you are interested in listening to it, here it is:</p>
<audio controls="">
<source src="https://play.podtrac.com/npr-510308/ondemand.npr.org/anon.npr-mp3/npr/hiddenbrain/2018/07/20180712_hiddenbrain_hb_rad_-_watch_your_mouth__-_final_full_for_web.mp3" />
</audio>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/10/06/computing-permutations/">Computing permutations - divide and conquer &rarr;</a>
          </h1>

          <p class="post-meta">Oct 6, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/c/">C++</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>In one of the <a href="https://dotkay.github.io/2017/09/21/permutations-of-a-list/">previous posts</a> we saw how to compute all permutations of a list recursively. Let us attempt the same, but this time with C++, in what is called divide and conquer approach - essentially divide the input into smaller chunks and recursively call the function on each of the smaller chunk.</p>

<p>Let us compute the permutations of say characters in a string. A string of <em>n</em> characters would have <em>n!</em> permutations. For example, if we have the string “ABC”, the permutations (6 in all) are:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ABC
ACB
BAC
BCA
CBA
CAB
</code></pre>
</div>
<p>We shall do it by going through the string of characters and iteratively swapping each character with the neighbouring character to get the permutation. For example, for the string “ABC”:</p>

<p><br />
<img src="/assets/images/algorithms/cpp/perm_1.png" alt="Permutations of &quot;ABC&quot;" class="img=responsive" /></p>

<p>Here is a function <code class="highlighter-rouge">permute()</code> implementing the traversal: We are given a string <em>s</em> with starting index <em>start</em> and ending index <em>end</em>.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">permute</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">start</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">swap</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="n">permute</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
      <span class="n">swap</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>What happens if we use the above algorithms to find permutations of strings that have duplicated characters? For example, the string “AAB” would produce:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>AAB
ABA
AAB  (*)
ABA  (*)
BAA
BAA  (*)
</code></pre>
</div>

<p>As you can see, we are computing the same permutation more than once (marked with *). How can we modify the above function to handle duplicates?</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/10/04/closest-pair-naive/">Computing the closest pair of points - Naïve approach &rarr;</a>
          </h1>

          <p class="post-meta">Oct 4, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/c/">C++</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Given a set of points (say provided to us as <em>(x, y)</em> coordinates) on a plane, let us find the closest pair among the set. The straight forward approach would be to compute the distance of each point with every other point in the given set and store the minimum distance.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#define REP(i, n) for (int i=0; i&lt;n; i++)
#define REPK(i, k, n) for (int i=k; i&lt;n; i++)
</span>
<span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span> 
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">Point</span> <span class="p">()</span> <span class="p">{};</span>
    <span class="n">Point</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
    <span class="k">static</span> <span class="kt">float</span> <span class="n">dist</span><span class="p">(</span><span class="n">Point</span> <span class="n">p</span><span class="p">,</span> <span class="n">Point</span> <span class="n">q</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">float</span> <span class="nf">min_distance</span> <span class="p">(</span><span class="n">Point</span> <span class="n">p</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">float</span> <span class="n">min</span> <span class="o">=</span> <span class="n">MAX_DIST</span><span class="p">;</span>
  <span class="n">REP</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">REPK</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span> 
        <span class="n">min</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
  <span class="k">return</span> <span class="n">min</span><span class="p">;</span>
  <span class="c1">// Time Complexity: O(n^2) - nested for loops (2)
</span><span class="p">}</span></code></pre></figure>

<p>As you can see this is a <em>O(n^2)</em> algorithm. Can we do better than this? It turns out we can - a topic for a future post.</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/10/03/array-inversions-merge-sort/">Computing the number of inversions in an array - using divide and conquer approach &rarr;</a>
          </h1>

          <p class="post-meta">Oct 3, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/c/">C++</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>In our <a href="https://dotkay.github.io/2017/10/02/array-inversions-naive">previous post</a>, we saw an <code class="highlighter-rouge">O(n^2</code> algorithm to compute the number of inversions in an input array. Now, let us see how we can use divide and conquer approach to solve the same problem. We will see that we can do better than <code class="highlighter-rouge">O(n^2)</code> using this approach.</p>

<p>In the traditional recursive version of merge-sort, we divide the input array into two halves and call merge-sort procedure on each of the sub-arrays recursively and eventually merge the results. Suppose our input array is <code class="highlighter-rouge"><span class="p">{</span><span class="err">2,</span><span class="w"> </span><span class="err">4,</span><span class="w"> </span><span class="err">1,</span><span class="w"> </span><span class="err">3,</span><span class="w"> </span><span class="err">5</span><span class="p">}</span></code> and suppose that the merge-sort procedure calls are complete and that we are in the merge process. Let us say that we ended up with the following sorted subarrays and trying to merge them up into a single sorted array - <code class="highlighter-rouge"><span class="p">{</span><span class="err">2,</span><span class="w"> </span><span class="err">4</span><span class="p">}</span></code> and <code class="highlighter-rouge"><span class="p">{</span><span class="err">1,</span><span class="w"> </span><span class="err">3,</span><span class="w"> </span><span class="err">5</span><span class="p">}</span></code>. The way merge procedure works is to compare the two sub-arrays (call it <code class="highlighter-rouge">left</code> and <code class="highlighter-rouge">right</code>) and compare the elements one by one. First, we compare <code class="highlighter-rouge">2</code> and <code class="highlighter-rouge">1</code>, since <code class="highlighter-rouge">1</code> is less than <code class="highlighter-rouge">2</code>, we push <code class="highlighter-rouge">1</code> to the result array (<code class="highlighter-rouge">1</code> being the smaller element). And we have encountered an inversion - the index of <code class="highlighter-rouge">2</code> is smaller than the index of <code class="highlighter-rouge">1</code>. Since we know that each of the sub-arrays are sorted, elements that follow <code class="highlighter-rouge">2</code> in the <code class="highlighter-rouge">left</code> sub-array would be greater than <code class="highlighter-rouge">2</code> and since <code class="highlighter-rouge">2</code> formed an inversion with <code class="highlighter-rouge">1</code> (of the <code class="highlighter-rouge">right</code> sub-array), so will all the elements that follow <code class="highlighter-rouge">2</code> in the <code class="highlighter-rouge">left</code> sub-array. So, we already see two inversions - <code class="highlighter-rouge">(2, 1)</code> and <code class="highlighter-rouge">(4, 1)</code>. Now we move on and compare the next elements - <code class="highlighter-rouge">2</code> and <code class="highlighter-rouge">3</code> and push <code class="highlighter-rouge">2</code> into the result array, and move on to the next. Now, we compare <code class="highlighter-rouge">4</code> and <code class="highlighter-rouge">3</code> and since <code class="highlighter-rouge">3</code> is smaller, we push it into the result array - we also encounter an inversion <code class="highlighter-rouge">(4, 3)</code>. A pair of keen eyes would note that whenever we push an element from the <code class="highlighter-rouge">right</code> sub-array into the result array, we encounter (at least) an inversion and the number of inversions at that step equals the number of elements following the current element in <code class="highlighter-rouge">left</code> sub-array. Think over it.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#define REP(i, n) for (int i=0; i&lt;n; i++)
#define REPK(i, k, n) for (int i=k; i&lt;n; i++)
</span>
<span class="kt">int</span> <span class="nf">merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">inv_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// create tmp arrays for l and r
</span>  <span class="kt">int</span> <span class="n">lsz</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">rsz</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">m</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">left</span><span class="p">[</span><span class="n">lsz</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">right</span><span class="p">[</span><span class="n">rsz</span><span class="p">];</span>
  <span class="c1">// populate
</span>  <span class="n">REP</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lsz</span><span class="p">)</span>
    <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
  <span class="n">REP</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rsz</span><span class="p">)</span>
    <span class="n">right</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
  <span class="c1">// compare and merge
</span>  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">k</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">((</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">lsz</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">rsz</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
      <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
      <span class="n">inv_cnt</span> <span class="o">+=</span> <span class="n">lsz</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// fill in the left-over elements
</span>  <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">lsz</span><span class="p">)</span> 
    <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">rsz</span><span class="p">)</span> 
    <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>

  <span class="k">return</span> <span class="n">inv_cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">mergesort</span> <span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">inv_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span><span class="o">+</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

    <span class="n">inv_cnt</span> <span class="o">=</span> <span class="n">mergesort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
    <span class="n">inv_cnt</span> <span class="o">+=</span> <span class="n">mergesort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="n">inv_cnt</span> <span class="o">+=</span> <span class="n">merge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">inv_cnt</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Since we use divide and conquer, in fact we could re-purpose merge step of merge-sort as shown below to count the number of inversions, the time complexity of this approach is <code class="highlighter-rouge">O(nlogn)</code> which is better than our previous approach.</p>

        </div>
        
      </li>
    
      
      

      <li>
        <header class="post-header">
          <h1 class="post-title">
            <a class="post-link" href="/2017/10/02/array-inversions-naive/">Computing the number of inversions in an array - naïve method &rarr;</a>
          </h1>

          <p class="post-meta">Oct 2, 2017 • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/c/">C++</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
        </header>

        <div class="post-content">
          <p>Let us think about computing the number of inversions in an array. Let us also assume that our array has unique elements.</p>

<blockquote>
  <p>Two elements in an array <em>arr</em> form an inversion if <em>arr[i] &gt; arr[j]</em> for <em>i &lt; j</em>.</p>
</blockquote>

<p>For example, if <code class="highlighter-rouge"><span class="p">{</span><span class="err">2,</span><span class="w"> </span><span class="err">4,</span><span class="w"> </span><span class="err">1,</span><span class="w"> </span><span class="err">3,</span><span class="w"> </span><span class="err">5</span><span class="p">}</span></code> is our input array, it has 3 inversions <code class="highlighter-rouge">(2, 1), (4,1)</code> and <code class="highlighter-rouge">(4, 3)</code>. Let us look for a naïve straight-forward algorithm to solve this problem - i.e., traverse the array comparing the elements and checking if there is an inversion.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">inv_count</span> <span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">inv_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">inv_count</span><span class="o">++</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">inv_count</span><span class="p">;</span>
  <span class="c1">// Time complexity: O(n^2) (two for loops)
</span><span class="p">}</span></code></pre></figure>

<p>Inversion tells us how far the array is from being sorted. For a sorted array, the number of inversions is <code class="highlighter-rouge">0</code> and if the array is sorted in the other order it has maximum number of inversions.</p>

<p>But can we do better than <code class="highlighter-rouge">O(n^2</code>?</p>

        </div>
        
      </li>
    
  </ul>

  
  <div class="pagination">
    
      <a class="previous" href="/posts/2/">&laquo; Older</a>
    

    
  </div>



</div>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://dotkay.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>

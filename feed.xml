<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <generator uri="http://jekyllrb.com" version="3.5.1">Jekyll</generator>
  
  
  <link href="https://quotidien.github.io/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://quotidien.github.io/" rel="alternate" type="text/html" hreflang="en" />
  <updated>2017-08-18T08:08:04+00:00</updated>
  <id>https://quotidien.github.io//</id>

  
    <title type="html">Quotidien</title>
  

  
    <subtitle>Learning by teaching</subtitle>
  

  

  
  
    <entry>
      
      <title type="html">Let’s practice some more recursion! →</title>
      
      <link href="https://quotidien.github.io/2017/08/17/lets-practice-some-more-examples/" rel="alternate" type="text/html" title="Let's practice some more recursion!" />
      <published>2017-08-17T00:00:00+00:00</published>
      <updated>2017-08-17T00:00:00+00:00</updated>
      <id>https://quotidien.github.io/2017/08/17/lets-practice-some-more-examples</id>
      <content type="html" xml:base="https://quotidien.github.io/2017/08/17/lets-practice-some-more-examples/">&lt;p&gt;Let’s continue from our &lt;a href=&quot;https://dotkay.github.io/2017/08/15/more-simple-recursion-examples&quot;&gt;earlier post&lt;/a&gt; and practice some more simple problems just to get more and more familiar with recursion.&lt;/p&gt;

&lt;p&gt;Let’s start by writing a simple function to find the last element of a given list &lt;code class=&quot;highlighter-rouge&quot;&gt;lst&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;rec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_elem&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;None&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Some&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_elem&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* val last_elem : 'a list -&amp;gt; 'a option = &amp;lt;fun&amp;gt; *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is also a nice way to introduce &lt;code class=&quot;highlighter-rouge&quot;&gt;Some&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt; in OCaml. Just like how we have &lt;code class=&quot;highlighter-rouge&quot;&gt;'a list&lt;/code&gt; which can be an &lt;code class=&quot;highlighter-rouge&quot;&gt;int list&lt;/code&gt; or a &lt;code class=&quot;highlighter-rouge&quot;&gt;string list&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;char list&lt;/code&gt;, OCaml also has this wonderful &lt;code class=&quot;highlighter-rouge&quot;&gt;'a option&lt;/code&gt; type that can be nothing (&lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt;) or some type (&lt;code class=&quot;highlighter-rouge&quot;&gt;Some&lt;/code&gt;). Note however that &lt;code class=&quot;highlighter-rouge&quot;&gt;'a option&lt;/code&gt; type is not the same as &lt;code class=&quot;highlighter-rouge&quot;&gt;'a&lt;/code&gt;. So, if the type is &lt;code class=&quot;highlighter-rouge&quot;&gt;'a&lt;/code&gt; you can ask the compiler to treat it as an &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;, for example. But you can’t do the same with &lt;code class=&quot;highlighter-rouge&quot;&gt;'a option&lt;/code&gt; type. For friends of Java, C programming languages, you can think of &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt; as similar to &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; type.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;option&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Some&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;None&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For those JavaScript fans wondering if they can use similar &lt;code class=&quot;highlighter-rouge&quot;&gt;Some&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt; in JavaScript, I found an &lt;a href=&quot;https://github.com/mwilliamson/node-options&quot;&gt;option type implementation here&lt;/a&gt; that provides this. I should admit that I have never used this implementation but it seems to serve the same purpose for JavaScript.&lt;/p&gt;

&lt;p&gt;Let’s test our &lt;code class=&quot;highlighter-rouge&quot;&gt;last_elem&lt;/code&gt; function on an example.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;last_elem&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* - : int option = Some 4 *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s move on and practice some more examples. Let’s now try and grab the last and the last-but-one elements from a list.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;rec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_two&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[_]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;None&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Some&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;_::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_two&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* val last_two : 'a list -&amp;gt; ('a * 'a) option = &amp;lt;fun&amp;gt; *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;('a * 'a)&lt;/code&gt; indicates a tuple - a pair in this case. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;(3, 4)&lt;/code&gt; would be of type &lt;code class=&quot;highlighter-rouge&quot;&gt;(int * int)&lt;/code&gt;. Let’s check our implementation:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;n&quot;&gt;last_two&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* - : (int * int) option = Some (3, 4) *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s now make it more generic and write a function to find the k&lt;sup&gt;th&lt;/sup&gt; element of a list and let’s give our function a very creative name &lt;code class=&quot;highlighter-rouge&quot;&gt;kth&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;rec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kth&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;None&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Some&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kth&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* val kth : 'a list -&amp;gt; int -&amp;gt; 'a option = &amp;lt;fun&amp;gt; *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s check our implementation on &lt;code class=&quot;highlighter-rouge&quot;&gt;l1&lt;/code&gt; again:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;n&quot;&gt;kth&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* - : int option = Some 2 *)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;kth&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* - : int option = None *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When we try to find the 6&lt;sup&gt;th&lt;/sup&gt; element of the list &lt;code class=&quot;highlighter-rouge&quot;&gt;l1&lt;/code&gt;, we get &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt; type as a result as the list contains only 4 elements.&lt;/p&gt;

&lt;p&gt;Let’s now try to reverse an input list. Relax! It just sounds complicated. It is actually super simple when you think in terms of recursion.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;rec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst_rev&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;[]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lst_rev&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* val lst_rev : 'a list -&amp;gt; 'a list = &amp;lt;fun&amp;gt; *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Recall from our previous post that &lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt; is the OCaml operator for list concatenation. It is a straight forward observation that after the first recursive call to &lt;code class=&quot;highlighter-rouge&quot;&gt;rev_lst&lt;/code&gt;, the head element &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; is pushed to the last and in each recursive call the first element would keep getting pushed to the end of the result list.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;n&quot;&gt;lst_rev&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* - : int list = [4; 3; 2; 1] *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This post is getting long. Please don’t stop reading it! I promise, just one more example to finish this post! Let’s write a function to remove an element from k&lt;sup&gt;th&lt;/sup&gt; position in a given list:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;rec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rem_kth&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;[]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rem_kth&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* val rem_kth : int -&amp;gt; 'a list -&amp;gt; 'a list = &amp;lt;fun&amp;gt; *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;n&quot;&gt;rem_kth&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* - : int list = [2; 3; 4] *)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rem_kth&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* - : int list = [1; 2; 3; 4] *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That’s all folks. If you have reached this line of this post (assuming you didn’t start reading from the last line), Congratulations for sticking around!&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="ocaml" />
      
        <category term="recursion" />
      

      

      
        <summary type="html">Let’s continue from our earlier post and practice some more simple problems just to get more and more familiar with recursion. Let’s start by writing a simple function to find the last element of a given list lst: let rec last_elem lst = match lst with | [] -&amp;gt; None | [x] -&amp;gt; Some x | h::t -&amp;gt; last_elem t;; (* val last_elem : 'a list -&amp;gt; 'a option = &amp;lt;fun&amp;gt; *) This is also a nice way to introduce Some and None in OCaml. Just like how we have 'a list which can be an int list or a string list or char list, OCaml also has this wonderful 'a option type that can be nothing (None) or some type (Some). Note however that 'a option type is not the same as 'a. So, if the type is 'a you can ask the compiler to treat it as an int, for example. But you can’t do the same with 'a option type. For friends of Java, C programming languages, you can think of None as similar to null type. type 'a option = Some of 'a | None For those JavaScript fans wondering if they can use similar Some and None in JavaScript, I found an option type implementation here that provides this. I should admit that I have never used this implementation but it seems to serve the same purpose for JavaScript. Let’s test our last_elem function on an example. let l1 = [1;2;3;4];; last_elem l1;; (* - : int option = Some 4 *) Let’s move on and practice some more examples. Let’s now try and grab the last and the last-but-one elements from a list. let rec last_two lst = match lst with | [] | [_] -&amp;gt; None | [x; y] -&amp;gt; Some (x, y) | _::t -&amp;gt; last_two t;; (* val last_two : 'a list -&amp;gt; ('a * 'a) option = &amp;lt;fun&amp;gt; *) ('a * 'a) indicates a tuple - a pair in this case. For example, (3, 4) would be of type (int * int). Let’s check our implementation: last_two l1;; (* - : (int * int) option = Some (3, 4) *) Let’s now make it more generic and write a function to find the kth element of a list and let’s give our function a very creative name kth. let rec kth lst k = match lst with | [] -&amp;gt; None | h::t -&amp;gt; if (k=1) then (Some h) else kth t (k-1);; (* val kth : 'a list -&amp;gt; int -&amp;gt; 'a option = &amp;lt;fun&amp;gt; *) Let’s check our implementation on l1 again: kth l1 2;; (* - : int option = Some 2 *) kth l1 6;; (* - : int option = None *) When we try to find the 6th element of the list l1, we get None type as a result as the list contains only 4 elements. Let’s now try to reverse an input list. Relax! It just sounds complicated. It is actually super simple when you think in terms of recursion. let rec lst_rev lst = match lst with | [] -&amp;gt; [] | h::t -&amp;gt; (lst_rev t) @ [h];; (* val lst_rev : 'a list -&amp;gt; 'a list = &amp;lt;fun&amp;gt; *) Recall from our previous post that @ is the OCaml operator for list concatenation. It is a straight forward observation that after the first recursive call to rev_lst, the head element h is pushed to the last and in each recursive call the first element would keep getting pushed to the end of the result list. lst_rev l1;; (* - : int list = [4; 3; 2; 1] *) This post is getting long. Please don’t stop reading it! I promise, just one more example to finish this post! Let’s write a function to remove an element from kth position in a given list: let rec rem_kth k lst = match lst with | [] -&amp;gt; [] | h::t -&amp;gt; if (k = 1) then t else h::(rem_kth (k-1) t);; (* val rem_kth : int -&amp;gt; 'a list -&amp;gt; 'a list = &amp;lt;fun&amp;gt; *) rem_kth 1 l1;; (* - : int list = [2; 3; 4] *) rem_kth 6 l1;; (* - : int list = [1; 2; 3; 4] *) That’s all folks. If you have reached this line of this post (assuming you didn’t start reading from the last line), Congratulations for sticking around!</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">An interesting podcast on education →</title>
      
      <link href="https://quotidien.github.io/2017/08/16/interesting-podcast-on-education/" rel="alternate" type="text/html" title="An interesting podcast on education" />
      <published>2017-08-16T00:00:00+00:00</published>
      <updated>2017-08-16T00:00:00+00:00</updated>
      <id>https://quotidien.github.io/2017/08/16/interesting-podcast-on-education</id>
      <content type="html" xml:base="https://quotidien.github.io/2017/08/16/interesting-podcast-on-education/">&lt;p&gt;A break from recursions and algorithms for today! But still sticking to the broader goal of education and learning. I am a big fan of radio programs and in particular NPR. Over the weekend, I happened to listen to a very interesting program on education. Hosted by &lt;a href=&quot;http://www.npr.org/people/6597623/guy-raz&quot;&gt;Guy Raz&lt;/a&gt;, last week’s episode of &lt;a href=&quot;http://www.npr.org/programs/ted-radio-hour/&quot;&gt;TED Radio Hour&lt;/a&gt; focussed on education and learning - specifically how it is changing with technology. It was a very interesting podcast and I really encourage all of you to make some time to listen to it. Below is a link to the podcast.&lt;/p&gt;

&lt;audio controls=&quot;&quot;&gt;
&lt;source src=&quot;https://play.podtrac.com/npr-510298/npr.mc.tritondigital.com/NPR_510298/media/anon.npr-mp3/npr/ted/2017/08/20170811_ted_tedpod.mp3&quot; /&gt;
&lt;/audio&gt;
&lt;p&gt;&lt;br /&gt;
It is an added motivation for me to use more avenues to share my knowledge with the many in this world, as much as I learn through the many channels and from the many wonderful people on this planet.&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="education" />
      
        <category term="NPR" />
      
        <category term="TED" />
      

      

      
        <summary type="html">A break from recursions and algorithms for today! But still sticking to the broader goal of education and learning. I am a big fan of radio programs and in particular NPR. Over the weekend, I happened to listen to a very interesting program on education. Hosted by Guy Raz, last week’s episode of TED Radio Hour focussed on education and learning - specifically how it is changing with technology. It was a very interesting podcast and I really encourage all of you to make some time to listen to it. Below is a link to the podcast. It is an added motivation for me to use more avenues to share my knowledge with the many in this world, as much as I learn through the many channels and from the many wonderful people on this planet.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Some more recursion examples →</title>
      
      <link href="https://quotidien.github.io/2017/08/15/more-simple-recursion-examples/" rel="alternate" type="text/html" title="Some more recursion examples" />
      <published>2017-08-15T00:00:00+00:00</published>
      <updated>2017-08-15T00:00:00+00:00</updated>
      <id>https://quotidien.github.io/2017/08/15/more-simple-recursion-examples</id>
      <content type="html" xml:base="https://quotidien.github.io/2017/08/15/more-simple-recursion-examples/">&lt;p&gt;Continuing with our &lt;a href=&quot;http://dotkay.github.io/2017/08/14/ocaml-recursion-simple/&quot;&gt;previous post&lt;/a&gt; on recursions, let’s play with a couple of more simple examples to get ourselves familiar. This is just to start thinking in terms of recursive functions for the problems we try to solve. This kind of thinking will become more useful when we learn about tail recursion in one of the future posts.&lt;/p&gt;

&lt;p&gt;Let’s write a small function, call it &lt;code class=&quot;highlighter-rouge&quot;&gt;find&lt;/code&gt;, to find if a given element belongs to a list. i.e., we are provided with an input list &lt;code class=&quot;highlighter-rouge&quot;&gt;lst&lt;/code&gt; of integers and an integer &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; and the function would return &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; if &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; is one of the elements of &lt;code class=&quot;highlighter-rouge&quot;&gt;lst&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; otherwise.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;rec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;true&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* val find : 'a -&amp;gt; 'a list -&amp;gt; bool = &amp;lt;fun&amp;gt; *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* - : bool = true *)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* - : bool = false *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As before, we think of the base case and the recursive step. We recursively call the function on a sub-list of the input list, till the problem reduces to the base case - the empty list.&lt;/p&gt;

&lt;p&gt;Let’s try another simple examples - to find the minimum integer in the given list of integers. We will call the function &lt;code class=&quot;highlighter-rouge&quot;&gt;find_min&lt;/code&gt; and it takes an input list &lt;code class=&quot;highlighter-rouge&quot;&gt;lst&lt;/code&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;k&quot;&gt;exception&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Failure&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;                   
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;rec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_min&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;failwith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;empty list&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find_min&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* val find_min : 'a list -&amp;gt; 'a = &amp;lt;fun&amp;gt; *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s test it out:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;n&quot;&gt;find_min&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* - : int = 1 *)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;find_min&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* - : int = -10 *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s now move away from having lists as input, and work on an example that produces an output list. This is a very familiar introductory CS example - converting an input decimal number to it’s base-2 (&lt;code class=&quot;highlighter-rouge&quot;&gt;binary&lt;/code&gt;) representation. Humans naturally count in base-10 (also called &lt;code class=&quot;highlighter-rouge&quot;&gt;decimal&lt;/code&gt;) number system, probably because most of us were born with 10 fingers. Computers, to be technically correct I should say digital circuits, work on base-2 number system - they know &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;. Just like how we count 0 .. 9 and then start counting 10 .. 19, followed by 20 .. 29, etc., digital circuits  count 0, 1 followed by 10, 11 and then follow that by 100, 101, and 110,  111, etc. You see the pattern. Probably, it is more apparent if I write it one after the other:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  base-2    	   	  base-10
     0  	  	     0
     1  	  	     1
    10 	 &amp;lt;-- restart	     2
    11 		 	     3
   100   &amp;lt;-- restart 	     4
   101 	 	     	     5
   110 	 	     	     6
   111 	 	     	     7
  1000 	 &amp;lt;-- restart 	     8
  1001 	 	     	     9
  1010 	 	    	    10   &amp;lt;-- restart
  1011 	  	       	    11 
  1100           	    12
  1101           	    13
  1110           	    14
  1111           	    15
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The usual way we compute the binary representation of a decimal number is to repeatedly divide it and collect the remainders. For example, if we want to compute the binary equivalent of decimal 7:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2 |_ 7 _          ^
  2 |_ 3 _   - (1) |
    2 |_ 1 _ - (1) |
         ----------&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;111 is the binary equivalent of decimal 7. Here, 3, 1 are quotients (&lt;code class=&quot;highlighter-rouge&quot;&gt;n/2&lt;/code&gt; - n being the input number initally and then the quotient) and the ones on the right within parantheses are the remainders (&lt;code class=&quot;highlighter-rouge&quot;&gt;n mod 2&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Let’s work out one more example - the binary equivalent of 13:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2 |_ 13 _               ^
  2 |_ 6 _        - (1) |
    2 |_ 3 _      - (0) |
      2 |_ 1 _    - (1) |
                --------&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;If you observe carefully, what we are doing essentially is repeatedly dividing the input number &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; by the base we want to convert our number to - in this case base-2, and collect the remainders. Dividing a number is the expression &lt;code class=&quot;highlighter-rouge&quot;&gt;n/2&lt;/code&gt; for algorithmic purposes and the remainder is the expression &lt;code class=&quot;highlighter-rouge&quot;&gt;n mod 2&lt;/code&gt;. What we are going to do is to repeatedly (think “recursively”) divide &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; and collect the remainder in a list which we would eventually return as the output result. &lt;code class=&quot;highlighter-rouge&quot;&gt;@&lt;/code&gt; is the OCaml syntax for list concatenation: for example &lt;code class=&quot;highlighter-rouge&quot;&gt;lst1 @ lst2&lt;/code&gt; will concatenate &lt;code class=&quot;highlighter-rouge&quot;&gt;lst1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;lst2&lt;/code&gt;. Note the base case for our computation.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;rec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bin_of_dec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;[]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bin_of_dec&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)::[];;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* val bin_of_dec : int -&amp;gt; int list = &amp;lt;fun&amp;gt; *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s check if what we worked out for 7 and 13 are consistent with what this program computes:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;n&quot;&gt;bin_of_dec&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* - : int list = [1; 1; 1] *)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bin_of_dec&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* - : int list = [1; 1; 0; 1] *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I guess it became a longer post than what I intended it to be, but I hope you are getting a better hang of thinking recursively. We will see more examples in future posts - feel motivated to play around with some examples in the mean time!!&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="ocaml" />
      
        <category term="recursion" />
      

      

      
        <summary type="html">Continuing with our previous post on recursions, let’s play with a couple of more simple examples to get ourselves familiar. This is just to start thinking in terms of recursive functions for the problems we try to solve. This kind of thinking will become more useful when we learn about tail recursion in one of the future posts. Let’s write a small function, call it find, to find if a given element belongs to a list. i.e., we are provided with an input list lst of integers and an integer x and the function would return true if x is one of the elements of lst and false otherwise. let rec find x lst = match lst with | [] -&amp;gt; false | h::t -&amp;gt; if (h = x) then true else (find x t);; (* val find : 'a -&amp;gt; 'a list -&amp;gt; bool = &amp;lt;fun&amp;gt; *) find 2 l1;; (* - : bool = true *) find 0 l1;; (* - : bool = false *) As before, we think of the base case and the recursive step. We recursively call the function on a sub-list of the input list, till the problem reduces to the base case - the empty list. Let’s try another simple examples - to find the minimum integer in the given list of integers. We will call the function find_min and it takes an input list lst. exception Failure of string let rec find_min lst = match lst with | [] -&amp;gt; failwith(&quot;empty list&quot;) | [h] -&amp;gt; h | h::t -&amp;gt; min h (find_min t);; (* val find_min : 'a list -&amp;gt; 'a = &amp;lt;fun&amp;gt; *) Let’s test it out: find_min l1;; (* - : int = 1 *) let l2 = [-2; -10; 1; 9; 11; 7; 17];; find_min l2;; (* - : int = -10 *) Let’s now move away from having lists as input, and work on an example that produces an output list. This is a very familiar introductory CS example - converting an input decimal number to it’s base-2 (binary) representation. Humans naturally count in base-10 (also called decimal) number system, probably because most of us were born with 10 fingers. Computers, to be technically correct I should say digital circuits, work on base-2 number system - they know 0 and 1. Just like how we count 0 .. 9 and then start counting 10 .. 19, followed by 20 .. 29, etc., digital circuits count 0, 1 followed by 10, 11 and then follow that by 100, 101, and 110, 111, etc. You see the pattern. Probably, it is more apparent if I write it one after the other: base-2 base-10 0 0 1 1 10 &amp;lt;-- restart 2 11 3 100 &amp;lt;-- restart 4 101 5 110 6 111 7 1000 &amp;lt;-- restart 8 1001 9 1010 10 &amp;lt;-- restart 1011 11 1100 12 1101 13 1110 14 1111 15 The usual way we compute the binary representation of a decimal number is to repeatedly divide it and collect the remainders. For example, if we want to compute the binary equivalent of decimal 7: 2 |_ 7 _ ^ 2 |_ 3 _ - (1) | 2 |_ 1 _ - (1) | ----------&amp;gt; 111 is the binary equivalent of decimal 7. Here, 3, 1 are quotients (n/2 - n being the input number initally and then the quotient) and the ones on the right within parantheses are the remainders (n mod 2). Let’s work out one more example - the binary equivalent of 13: 2 |_ 13 _ ^ 2 |_ 6 _ - (1) | 2 |_ 3 _ - (0) | 2 |_ 1 _ - (1) | --------&amp;gt; If you observe carefully, what we are doing essentially is repeatedly dividing the input number n by the base we want to convert our number to - in this case base-2, and collect the remainders. Dividing a number is the expression n/2 for algorithmic purposes and the remainder is the expression n mod 2. What we are going to do is to repeatedly (think “recursively”) divide n and collect the remainder in a list which we would eventually return as the output result. @ is the OCaml syntax for list concatenation: for example lst1 @ lst2 will concatenate lst1 and lst2. Note the base case for our computation. let rec bin_of_dec n = if n &amp;lt;= 0 then [] else bin_of_dec (n/2) @ (n mod 2)::[];; (* val bin_of_dec : int -&amp;gt; int list = &amp;lt;fun&amp;gt; *) Let’s check if what we worked out for 7 and 13 are consistent with what this program computes: bin_of_dec 7;; (* - : int list = [1; 1; 1] *) bin_of_dec 13;; (* - : int list = [1; 1; 0; 1] *) I guess it became a longer post than what I intended it to be, but I hope you are getting a better hang of thinking recursively. We will see more examples in future posts - feel motivated to play around with some examples in the mean time!!</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Let’s play with some simple recursion →</title>
      
      <link href="https://quotidien.github.io/2017/08/14/ocaml-recursion-simple/" rel="alternate" type="text/html" title="Let's play with some simple recursion" />
      <published>2017-08-14T00:00:00+00:00</published>
      <updated>2017-08-14T00:00:00+00:00</updated>
      <id>https://quotidien.github.io/2017/08/14/ocaml-recursion-simple</id>
      <content type="html" xml:base="https://quotidien.github.io/2017/08/14/ocaml-recursion-simple/">&lt;p&gt;Recursion has been one of my favourite concepts for a very long time much like my fascination for mathematical induction. The subtle differences between the two would be a topic for a separate post.&lt;/p&gt;

&lt;p&gt;Let’s do some simple recursive functions just to illustrate the beauty. I chose &lt;a href=&quot;http://www.ocaml.org&quot;&gt;OCaml&lt;/a&gt; for this post as it is one of my favourite programming languages. Somehow, I feel that many algorithms when coded in OCaml look very intuitive and understandable than in other imperative programming languages. We will look at some algorithms in both OCaml and C in a later post and leave it to the reader to decide as to which one looks more intuitive.&lt;/p&gt;

&lt;p&gt;OCaml is a very nice functional programming language and it offers &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt; as a primitive data type. For example, if we want a list of five integers, this is how we do it in OCaml:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;We would usually think of the list data type itself to be a recursive definition. i.e., a list is made of either an empty list or a list composed of a &lt;code class=&quot;highlighter-rouge&quot;&gt;head&lt;/code&gt; element and &lt;code class=&quot;highlighter-rouge&quot;&gt;tail&lt;/code&gt; where tail itself is a list (possibly empty list). For example, in the list &lt;code class=&quot;highlighter-rouge&quot;&gt;l1&lt;/code&gt; above, &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; constitutes the head element and the tail corresponds to the list &lt;code class=&quot;highlighter-rouge&quot;&gt;2;3;4;5&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, let’s write a recursive function to count the number of elements in the list.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Let’s think of the base case: when the list is empty - in which case we just return &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; as the result.&lt;/li&gt;
  &lt;li&gt;And let’s build our thought process this way - what if the list has just one element? This would correspond to a list where there is a single head element and an empty list as the tail. i.e., we count the single head element and the empty list (the tail) we know contributes &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to our result (the base case we just saw in 1.).&lt;/li&gt;
  &lt;li&gt;Now, when the list has 2 elements, we think of it as having a head element and a tail list that consists of a single element. Now, we count the head element and apply the same function (our counting) to count the number of elements in the tail list (which now corresponds to the case we saw in 2.).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Essentially what we are doing is:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;If the list is empty, return 0 as the result&lt;/li&gt;
  &lt;li&gt;If the list is not empty, count the head element (1) and call the function (recursively) to count the number of elements in the tail&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now, let’s write the above two steps in the following program which we call &lt;code class=&quot;highlighter-rouge&quot;&gt;lst_len&lt;/code&gt; (for list length), that takes a single input parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;lst&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;rec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst_len&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst_len&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* val len_lst : 'a list -&amp;gt; int = &amp;lt;fun&amp;gt; *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Recursive functions in OCaml are defined with &lt;code class=&quot;highlighter-rouge&quot;&gt;rec&lt;/code&gt; keyword. Let’s use this function to count the number of elements in our list &lt;code class=&quot;highlighter-rouge&quot;&gt;l1&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;n&quot;&gt;lst_len&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* - : int = 5 *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Let’s use the same thought process to write a recursive function &lt;code class=&quot;highlighter-rouge&quot;&gt;lst_sum&lt;/code&gt; to sum up (add) the elements of the list.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;rec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst_sum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lst_sum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* val lst_sum : int list -&amp;gt; int = &amp;lt;fun&amp;gt; *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;And let’s use this function to sum up the elements in our list &lt;code class=&quot;highlighter-rouge&quot;&gt;l1&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;n&quot;&gt;lst_sum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;(* - : int = 15 *)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Isn’t this intuitive and elegant way of programming? We’ll talk more about simple programs that can be written in an intuitive way and try to develop our understanding of the concepts in a clear way.&lt;/p&gt;

&lt;p&gt;Thanks for your interest and keep checking out this space for more.&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="ocaml" />
      
        <category term="recursion" />
      

      

      
        <summary type="html">Recursion has been one of my favourite concepts for a very long time much like my fascination for mathematical induction. The subtle differences between the two would be a topic for a separate post. Let’s do some simple recursive functions just to illustrate the beauty. I chose OCaml for this post as it is one of my favourite programming languages. Somehow, I feel that many algorithms when coded in OCaml look very intuitive and understandable than in other imperative programming languages. We will look at some algorithms in both OCaml and C in a later post and leave it to the reader to decide as to which one looks more intuitive. OCaml is a very nice functional programming language and it offers list as a primitive data type. For example, if we want a list of five integers, this is how we do it in OCaml: let l1 = [1;2;3;4;5];; We would usually think of the list data type itself to be a recursive definition. i.e., a list is made of either an empty list or a list composed of a head element and tail where tail itself is a list (possibly empty list). For example, in the list l1 above, 1 constitutes the head element and the tail corresponds to the list 2;3;4;5. Now, let’s write a recursive function to count the number of elements in the list. Let’s think of the base case: when the list is empty - in which case we just return 0 as the result. And let’s build our thought process this way - what if the list has just one element? This would correspond to a list where there is a single head element and an empty list as the tail. i.e., we count the single head element and the empty list (the tail) we know contributes 0 to our result (the base case we just saw in 1.). Now, when the list has 2 elements, we think of it as having a head element and a tail list that consists of a single element. Now, we count the head element and apply the same function (our counting) to count the number of elements in the tail list (which now corresponds to the case we saw in 2.). Essentially what we are doing is: If the list is empty, return 0 as the result If the list is not empty, count the head element (1) and call the function (recursively) to count the number of elements in the tail Now, let’s write the above two steps in the following program which we call lst_len (for list length), that takes a single input parameter lst: let rec lst_len lst = match lst with | [] -&amp;gt; 0 | h::t -&amp;gt; 1 + lst_len t;; (* val len_lst : 'a list -&amp;gt; int = &amp;lt;fun&amp;gt; *) Recursive functions in OCaml are defined with rec keyword. Let’s use this function to count the number of elements in our list l1: lst_len l1;; (* - : int = 5 *) Let’s use the same thought process to write a recursive function lst_sum to sum up (add) the elements of the list. let rec lst_sum lst = match lst with | [] -&amp;gt; 0 | h::t -&amp;gt; h + lst_sum t;; (* val lst_sum : int list -&amp;gt; int = &amp;lt;fun&amp;gt; *) And let’s use this function to sum up the elements in our list l1: lst_sum l1;; (* - : int = 15 *) Isn’t this intuitive and elegant way of programming? We’ll talk more about simple programs that can be written in an intuitive way and try to develop our understanding of the concepts in a clear way. Thanks for your interest and keep checking out this space for more.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">My First Post →</title>
      
      <link href="https://quotidien.github.io/2017/08/10/my-first-post/" rel="alternate" type="text/html" title="My First Post" />
      <published>2017-08-10T00:00:00+00:00</published>
      <updated>2017-08-10T00:00:00+00:00</updated>
      <id>https://quotidien.github.io/2017/08/10/my-first-post</id>
      <content type="html" xml:base="https://quotidien.github.io/2017/08/10/my-first-post/">&lt;p&gt;This is my first post. I will keep this a very short one - nothing interesting to read and learn. The internet is a wonderful place. I learnt a lot by browsing interesting blogs, tutorials, asking questions on the various sites, twitter, etc. and it imperative that I give back to the community that helps me learn continuously. I am hoping to be regular with this effort at learning by teaching the many subjects and topics that interest me. Let’s see how much I can keep up and how much I can learn.&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="misc" />
      

      

      
        <summary type="html">This is my first post. I will keep this a very short one - nothing interesting to read and learn. The internet is a wonderful place. I learnt a lot by browsing interesting blogs, tutorials, asking questions on the various sites, twitter, etc. and it imperative that I give back to the community that helps me learn continuously. I am hoping to be regular with this effort at learning by teaching the many subjects and topics that interest me. Let’s see how much I can keep up and how much I can learn.</summary>
      

      
      
    </entry>
  
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <generator uri="http://jekyllrb.com" version="3.8.6">Jekyll</generator>
  
  
  <link href="https://dotkay.github.io/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://dotkay.github.io/" rel="alternate" type="text/html" hreflang="en" />
  <updated>2019-12-06T05:30:56+00:00</updated>
  <id>https://dotkay.github.io//</id>

  
    <title type="html">Quotidien</title>
  

  
    <subtitle>Learning by teaching</subtitle>
  

  

  
  
    <entry>
      
      <title type="html">LinkedIn’s Business →</title>
      
      <link href="https://dotkay.github.io/2019/12/01/linkedin-business/" rel="alternate" type="text/html" title="LinkedIn's Business" />
      <published>2019-12-01T00:00:00+00:00</published>
      <updated>2019-12-01T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2019/12/01/linkedin-business</id>
      <content type="html" xml:base="https://dotkay.github.io/2019/12/01/linkedin-business/">&lt;p&gt;Lately, I have been reading about several businesses and trying to understand their product offerings, value proposition of the products, business model and how they came to be. With a natural inclination for technology products and a curiosity about startups and business models, this has been an enjoyable learning experience and I am hoping to share a lot of my learning through this medium. Let’s start with LinkedIn.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LinkedIn’s Vision&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Create economic opportunity for every member of the global workforce.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;dl&gt;
  &lt;dt&gt;I liked the simple and clear vision statement but was wondering why it mentions only &lt;em&gt;economic opportunity&lt;/em&gt; while LinkedIn’s products offer much more or could it be the case that all the benefits the products offer can be tied to economic opportunity? I started researching about what this term &lt;em&gt;economic opportunity&lt;/em&gt; entails and found &lt;a href=&quot;https://www.quora.com/How-are-economic-opportunities-defined&quot;&gt;this answer&lt;/a&gt; in Quora:&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;&lt;em&gt;When somebody is willing to pay you money for doing something that you are willing and able to do, that is an “economic opportunity”. It can be a small business idea or a job.If you can produce a product or provide a service that people are willing to pay for, that is a small business opportunity. If you have an ability or skill that an employer needs, that is a job opportunity.&lt;/em&gt;&lt;/p&gt;
  &lt;/dd&gt;
  &lt;dd&gt;
    &lt;p&gt;&lt;em&gt;Basically, an economic opportunity is the chance to do work that somebody is willing to pay you for. You don’t have to “like” the work. You just have to be able to competently do it. If you like your work, all the better for you. But we work to earn money that is paid by other people. The work we do is for other people’s benefit. The money they pay us is for our benefit. It is a reciprocal pay-earn, demand-supply economic relationship. They pay us money for supplying them what they want.&lt;/em&gt;&lt;/p&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;I, however, feel that LinkedIn also provides knowledge opportunity (learning), business/marketing opportunity (sales leads) and career opportunity (jobs for professionals) and talent development (hiring solutions for recruiters) opportunity, etc. There might be some or some aspects of these on which you cannot really put a dollar value on in order for them to be called an &lt;em&gt;economic opportunity&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LinkedIn’s Mission&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The mission of LinkedIn is simple: connect the world’s professionals to make them more productive and successful.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Again, a short and crisp mission statement. But, again I believe that the main benefit is making professionals more skilled, equipped, informed, etc., rather than just productive.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LinkedIn’s Products&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;LinkedIn to many is just a networking site for professionals. But once you look at the suite of products it is much more than that. LinkedIn’s products are organized under four themes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Hire&lt;/li&gt;
  &lt;li&gt;Market&lt;/li&gt;
  &lt;li&gt;Sell&lt;/li&gt;
  &lt;li&gt;Learn&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The various products under each of these themes are shown below:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;/assets/images/products/linkedin_products.jpg&quot; alt=&quot;LinkedIn's Products&quot; class=&quot;img=responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It is difficult to categorize each of the products into &lt;em&gt;advertisement-based&lt;/em&gt; or &lt;em&gt;subscription-based&lt;/em&gt; one as some of them overlap both business models. The &lt;em&gt;HIRE&lt;/em&gt; theme is mainly for human resources professionals to track, follow, and manage recruiting pipeline for their organizations. I believe this could be one of the most active products (along with learning) on the platform. The &lt;em&gt;MARKET&lt;/em&gt; theme helps in setting up marketing campaigns, reach out to potential resources for marketing purposes, set up custom pages, and serve advertisements on the pages and possibly through emails. Although it sounds like a lot of features, I believe they would have a very stiff competition from the likes of Google and Facebook. Although the advertisements would be more relevant to hiring and professional marketing, the eyeballs on these wouldn’t be as much as on Google search and Facebook feeds. However, with the volume of professionals in the network, hiring ads would get the best reach on this platform. The &lt;em&gt;SELL&lt;/em&gt; theme sounds like a specialized Salesforce platform.  The &lt;em&gt;LEARN&lt;/em&gt; theme is an upcoming Coursera. Although it may not offer a wide variety of specializations for now, with data from the &lt;em&gt;HIRE&lt;/em&gt; theme, it would be a more powerful medium for specialized skill development targeted at specific job roles in specific industries. We need to wait and watch how well Microsoft uses the data from one to better the offerings of another. Although LinkedIn membership is free, there is also a premium subscription which could be considered as a separate product in itself (creating significant revenue) and it is needed to use several of the other products, for example InMail.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LinkedIn’s business&lt;/strong&gt;&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;LinkedIn has become a significant business unit of Microsoft. According to a &lt;a href=&quot;https://www.businessofapps.com/data/linkedin-statistics/&quot;&gt;source&lt;/a&gt;&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;In the 2019 fiscal year, LinkedIn brought in $6.8 billion worth of revenue, contributing to $38.1 billion of commercial cloud revenue for Microsoft, which in turn made up part of $126 billion total revenue.&lt;/p&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;Further the numbers below from Microsoft’s earnings and LinkedIn newsroom validate the importance of LinkedIn and its potential.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;/assets/images/products/linkedin_fy20_q1.png&quot; alt=&quot;LinkedIn FY20 Q1&quot; class=&quot;img=responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;/assets/images/products/linkedin_stats.png&quot; alt=&quot;LinkedIn impact&quot; class=&quot;img=responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LinkedIn’s Opportunity&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;/assets/images/products/linkedin_worldwide.png&quot; alt=&quot;LinkedIn Stats&quot; class=&quot;img=responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And that shows the opportunity for LinkedIn. Along with the above, GitHub - the world’s largest software development platform or the playground for developers was snapped up by Microsoft. This indicates a very huge potential. The data from &lt;em&gt;HIRE&lt;/em&gt; theme above combined with &lt;em&gt;LEARN&lt;/em&gt; theme and fueled by GitHub platform is a wonderful growth opportunity. GitHub + LinkedIn for developers would be Instagram for fashionistas and for businesses and recruiters this would be the Instagram for fashion brands seeking ambassadors and influencers. Let me write about the opportunity for data science and AI in stitching all the above products together as one awesome fabric.&lt;/p&gt;

&lt;p&gt;Thats all for now!&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="technology" />
      
        <category term="products" />
      
        <category term="business" />
      
        <category term="LinkedIn" />
      

      

      
        <summary type="html">Lately, I have been reading about several businesses and trying to understand their product offerings, value proposition of the products, business model and how they came to be. With a natural inclination for technology products and a curiosity about startups and business models, this has been an enjoyable learning experience and I am hoping to share a lot of my learning through this medium. Let’s start with LinkedIn. LinkedIn’s Vision Create economic opportunity for every member of the global workforce. I liked the simple and clear vision statement but was wondering why it mentions only economic opportunity while LinkedIn’s products offer much more or could it be the case that all the benefits the products offer can be tied to economic opportunity? I started researching about what this term economic opportunity entails and found this answer in Quora: When somebody is willing to pay you money for doing something that you are willing and able to do, that is an “economic opportunity”. It can be a small business idea or a job.If you can produce a product or provide a service that people are willing to pay for, that is a small business opportunity. If you have an ability or skill that an employer needs, that is a job opportunity. Basically, an economic opportunity is the chance to do work that somebody is willing to pay you for. You don’t have to “like” the work. You just have to be able to competently do it. If you like your work, all the better for you. But we work to earn money that is paid by other people. The work we do is for other people’s benefit. The money they pay us is for our benefit. It is a reciprocal pay-earn, demand-supply economic relationship. They pay us money for supplying them what they want. I, however, feel that LinkedIn also provides knowledge opportunity (learning), business/marketing opportunity (sales leads) and career opportunity (jobs for professionals) and talent development (hiring solutions for recruiters) opportunity, etc. There might be some or some aspects of these on which you cannot really put a dollar value on in order for them to be called an economic opportunity. LinkedIn’s Mission The mission of LinkedIn is simple: connect the world’s professionals to make them more productive and successful. Again, a short and crisp mission statement. But, again I believe that the main benefit is making professionals more skilled, equipped, informed, etc., rather than just productive. LinkedIn’s Products LinkedIn to many is just a networking site for professionals. But once you look at the suite of products it is much more than that. LinkedIn’s products are organized under four themes: Hire Market Sell Learn The various products under each of these themes are shown below: It is difficult to categorize each of the products into advertisement-based or subscription-based one as some of them overlap both business models. The HIRE theme is mainly for human resources professionals to track, follow, and manage recruiting pipeline for their organizations. I believe this could be one of the most active products (along with learning) on the platform. The MARKET theme helps in setting up marketing campaigns, reach out to potential resources for marketing purposes, set up custom pages, and serve advertisements on the pages and possibly through emails. Although it sounds like a lot of features, I believe they would have a very stiff competition from the likes of Google and Facebook. Although the advertisements would be more relevant to hiring and professional marketing, the eyeballs on these wouldn’t be as much as on Google search and Facebook feeds. However, with the volume of professionals in the network, hiring ads would get the best reach on this platform. The SELL theme sounds like a specialized Salesforce platform. The LEARN theme is an upcoming Coursera. Although it may not offer a wide variety of specializations for now, with data from the HIRE theme, it would be a more powerful medium for specialized skill development targeted at specific job roles in specific industries. We need to wait and watch how well Microsoft uses the data from one to better the offerings of another. Although LinkedIn membership is free, there is also a premium subscription which could be considered as a separate product in itself (creating significant revenue) and it is needed to use several of the other products, for example InMail. LinkedIn’s business LinkedIn has become a significant business unit of Microsoft. According to a source In the 2019 fiscal year, LinkedIn brought in $6.8 billion worth of revenue, contributing to $38.1 billion of commercial cloud revenue for Microsoft, which in turn made up part of $126 billion total revenue. Further the numbers below from Microsoft’s earnings and LinkedIn newsroom validate the importance of LinkedIn and its potential. LinkedIn’s Opportunity And that shows the opportunity for LinkedIn. Along with the above, GitHub - the world’s largest software development platform or the playground for developers was snapped up by Microsoft. This indicates a very huge potential. The data from HIRE theme above combined with LEARN theme and fueled by GitHub platform is a wonderful growth opportunity. GitHub + LinkedIn for developers would be Instagram for fashionistas and for businesses and recruiters this would be the Instagram for fashion brands seeking ambassadors and influencers. Let me write about the opportunity for data science and AI in stitching all the above products together as one awesome fabric. Thats all for now!</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">The Magic Money Tree →</title>
      
      <link href="https://dotkay.github.io/2019/07/01/mmt/" rel="alternate" type="text/html" title="The Magic Money Tree" />
      <published>2019-07-01T00:00:00+00:00</published>
      <updated>2019-07-01T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2019/07/01/mmt</id>
      <content type="html" xml:base="https://dotkay.github.io/2019/07/01/mmt/">&lt;p&gt;As people who know me understand, I read articles and listen to podcasts on a variety of topics ranging from technology, social science, society, economics, etc. Economics is one of my favourites, as it is very relatable to our day to day lives, besides involving mathematical modelling (which, for the same reasons as Deep Learning techniques of today, can only be close to a very good approximation but never accurate). While listening to BBC’s Business Daily podcasts, I stumbled upon this episode on Modern Monetary Theory. The title of the podcast - “Magic Money Tree” caught my attention and it turned out to be an interesting take on a proposal by one of the former Hedge Fund manager about central banks being able to print more money when needed. I did have this idea when I was a kid before I realized inflation and value of goods and how they are tied to abundance of ciculation of money, interest rates and consumer spending. I am not an economist but I am worried how this could lead to powerful economies manipulating their inflation thereby leading to disastrous consequences in parts of the world whose currencies are not global trade currencies.&lt;/p&gt;

&lt;p&gt;For those interested in listening to the episode, you can do it here:&lt;/p&gt;
&lt;audio controls=&quot;&quot;&gt;
&lt;source src=&quot;http://open.live.bbc.co.uk/mediaselector/6/redir/version/2.0/mediaset/audio-nondrm-download-low/proto/http/vpid/p079cpnd.mp3&quot; /&gt; 
&lt;/audio&gt;

&lt;p&gt;Are there wonderful teachers among expert economists who can
help me understand?&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="Money" />
      
        <category term="Monetary Policy" />
      

      

      
        <summary type="html">As people who know me understand, I read articles and listen to podcasts on a variety of topics ranging from technology, social science, society, economics, etc. Economics is one of my favourites, as it is very relatable to our day to day lives, besides involving mathematical modelling (which, for the same reasons as Deep Learning techniques of today, can only be close to a very good approximation but never accurate). While listening to BBC’s Business Daily podcasts, I stumbled upon this episode on Modern Monetary Theory. The title of the podcast - “Magic Money Tree” caught my attention and it turned out to be an interesting take on a proposal by one of the former Hedge Fund manager about central banks being able to print more money when needed. I did have this idea when I was a kid before I realized inflation and value of goods and how they are tied to abundance of ciculation of money, interest rates and consumer spending. I am not an economist but I am worried how this could lead to powerful economies manipulating their inflation thereby leading to disastrous consequences in parts of the world whose currencies are not global trade currencies. For those interested in listening to the episode, you can do it here: Are there wonderful teachers among expert economists who can help me understand?</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">The Edge Effect →</title>
      
      <link href="https://dotkay.github.io/2019/01/06/edge-effect/" rel="alternate" type="text/html" title="The Edge Effect" />
      <published>2019-01-06T00:00:00+00:00</published>
      <updated>2019-01-06T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2019/01/06/edge-effect</id>
      <content type="html" xml:base="https://dotkay.github.io/2019/01/06/edge-effect/">&lt;p&gt;On this rainy Sunday in California, with not much motivation to do anything serious, with the last of the India-Australia Test series underway in Sydney delayed due to rain, I started scrolling through the library of my favourite pod-casts and this particular one caught my attention. &lt;em&gt;The Edge Effect&lt;/em&gt; - an episode from NPR’s &lt;a href=&quot;https://www.npr.org/series/423302056/hidden-brain&quot;&gt;Hidden Brain&lt;/a&gt; series.&lt;/p&gt;

&lt;p&gt;The episode talks about the importance of encouraging and developing diversity of thoughts and ideas. It draws examples from science and music and makes compelling arguments supporting diversity. In particular, the experiments by Adam Galinsky and the life story of Cristina Pato were very impressive.&lt;/p&gt;

&lt;p&gt;For those interested, here is a link to the podcast:&lt;/p&gt;

&lt;audio controls=&quot;&quot;&gt;
&lt;source src=&quot;https://play.podtrac.com/npr-510308/npr.mc.tritondigital.com/NPR_510308/media/anon.npr-podcasts/podcast/npr/hiddenbrain/2018/07/20180702_hiddenbrain_hb_diversity_and_creativity__-_final_pod_mix-9012e926-5cd6-4e44-b9d5-0b6e9750801c.mp3&quot; /&gt; 
&lt;/audio&gt;

&lt;p&gt;I should take time to appreciate the diversity my parents exposed me to, while growing up in India.&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="Diversity" />
      
        <category term="Edge Effect" />
      
        <category term="NPR" />
      
        <category term="Hidden Brain" />
      

      

      
        <summary type="html">On this rainy Sunday in California, with not much motivation to do anything serious, with the last of the India-Australia Test series underway in Sydney delayed due to rain, I started scrolling through the library of my favourite pod-casts and this particular one caught my attention. The Edge Effect - an episode from NPR’s Hidden Brain series. The episode talks about the importance of encouraging and developing diversity of thoughts and ideas. It draws examples from science and music and makes compelling arguments supporting diversity. In particular, the experiments by Adam Galinsky and the life story of Cristina Pato were very impressive. For those interested, here is a link to the podcast: I should take time to appreciate the diversity my parents exposed me to, while growing up in India.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Personalized movies … any takers? →</title>
      
      <link href="https://dotkay.github.io/2019/01/02/personalized-movies/" rel="alternate" type="text/html" title="Personalized movies ... any takers?" />
      <published>2019-01-02T00:00:00+00:00</published>
      <updated>2019-01-02T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2019/01/02/personalized-movies</id>
      <content type="html" xml:base="https://dotkay.github.io/2019/01/02/personalized-movies/">&lt;div class=&quot;img_container&quot;&gt;
  &lt;p class=&quot;img=responsive&quot;&gt;&lt;img src=&quot;/assets/images/misc/deewaar2.png&quot; alt=&quot;Amar Akbar Anthony&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;I got into this discussion over lunch when I heard about the Netflix series “Black Mirror” which allows the audience to choose among a set of possible story endings. This is an excellent development, in my view, in that it not only brings more suspense and interest or attention to the content, on the lighter side it would also prevent spoilers.&lt;/p&gt;

&lt;p&gt;Ever since I heard about &lt;a href=&quot;https://newsable.asianetnews.com/kerala/after-solo-other-malayalam-films-supposed-to-have-different-endings&quot;&gt;south Indian movies that had different climaxes&lt;/a&gt; (although to appease the fan base in different regions), I have always wondered why not have multiple possibilities for a movie climax and serve (stream) the appropriate one depending on the goal of the movie audience - i.e., if the goal is to just watch the movie and return home happy, one could have a happy ending, if the viewer is adventurous or an FPS gamer, one could have a violent or tragic ending, etc.&lt;/p&gt;

&lt;p&gt;Now that we have personalization using big data analytics everywhere, it should be possible for a streaming service to identify the likes and dislikes of the audience based on previous perferences, reviews, age, likes, and the many similar features to identify the best climax for each specific viewer, besides providing the viewer the choice to choose from alternate climaxes. Of course, the cost is in the making of several different versions of a movie or TV series which in a way could be reduced using today’s CGI that only gets better over time. The upshot would be more viewership and more discussion centered around the various climaxes. Instead of viewers just watching the movie and rating them, each different climax of the same movie would get rated by different personalities. Such a service could also stream a movie ending in such a way as to cheer you up when you are dull or to pump you up when you are demotivated. Movies will never be the same again!&lt;/p&gt;

&lt;p&gt;If such a personalization of streaming content were to happen who would lead the way? Would it be Amazon Fire TV who has the machine learning backend to make personalization happen, NetFlix who has the influence to get the producers to make several interesting versions of a movie or TV series or Apple TV service if Apple were to get its innovation crown back? What do you think?&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="technology" />
      
        <category term="streaming content" />
      
        <category term="personalization" />
      

      

      
        <summary type="html">I got into this discussion over lunch when I heard about the Netflix series “Black Mirror” which allows the audience to choose among a set of possible story endings. This is an excellent development, in my view, in that it not only brings more suspense and interest or attention to the content, on the lighter side it would also prevent spoilers. Ever since I heard about south Indian movies that had different climaxes (although to appease the fan base in different regions), I have always wondered why not have multiple possibilities for a movie climax and serve (stream) the appropriate one depending on the goal of the movie audience - i.e., if the goal is to just watch the movie and return home happy, one could have a happy ending, if the viewer is adventurous or an FPS gamer, one could have a violent or tragic ending, etc. Now that we have personalization using big data analytics everywhere, it should be possible for a streaming service to identify the likes and dislikes of the audience based on previous perferences, reviews, age, likes, and the many similar features to identify the best climax for each specific viewer, besides providing the viewer the choice to choose from alternate climaxes. Of course, the cost is in the making of several different versions of a movie or TV series which in a way could be reduced using today’s CGI that only gets better over time. The upshot would be more viewership and more discussion centered around the various climaxes. Instead of viewers just watching the movie and rating them, each different climax of the same movie would get rated by different personalities. Such a service could also stream a movie ending in such a way as to cheer you up when you are dull or to pump you up when you are demotivated. Movies will never be the same again! If such a personalization of streaming content were to happen who would lead the way? Would it be Amazon Fire TV who has the machine learning backend to make personalization happen, NetFlix who has the influence to get the producers to make several interesting versions of a movie or TV series or Apple TV service if Apple were to get its innovation crown back? What do you think?</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">New year, Privacy and Security →</title>
      
      <link href="https://dotkay.github.io/2019/01/01/privacy-and-security/" rel="alternate" type="text/html" title="New year, Privacy and Security" />
      <published>2019-01-01T00:00:00+00:00</published>
      <updated>2019-01-01T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2019/01/01/privacy-and-security</id>
      <content type="html" xml:base="https://dotkay.github.io/2019/01/01/privacy-and-security/">&lt;p&gt;Happy New year friends!&lt;/p&gt;

&lt;p&gt;What a year 2018 has been for the topic of privacy and security - from the most loved &lt;a href=&quot;https://www.nytimes.com/2018/03/19/technology/facebook-cambridge-analytica-explained.html&quot;&gt;social network&lt;/a&gt; scrambling for clues to save themselves to the other &lt;a href=&quot;https://www.theguardian.com/technology/2018/dec/10/google-to-shut-down-early-after-privacy-flaw-affects-over-50m-users&quot;&gt;social network&lt;/a&gt; built by the world’s best engineers still couldn’t save their data, besides struggling to stay relevant. While Europe was quick to pass &lt;a href=&quot;https://eugdpr.org/&quot;&gt;GDPR&lt;/a&gt;, many other countries even in the developed world are yet to catch up with such laws and regulations. 2018 was also the year that saw the &lt;a href=&quot;https://techcrunch.com/2018/12/28/smart-speakers-hit-critical-mass-in-2018/&quot;&gt;surge in smart speakers&lt;/a&gt; and home automation - isn’t that ironic?&lt;/p&gt;

&lt;p&gt;But this story is not about the past, but about the future. Many top technology and auto companies rushing to fulfill the promise of self-driving or autonomous vehicles. It will definitely become a reality, to some extent, in at least the parts of the world where the infrastructure supports it. But the notion of foolproof security for such a technology is far from being achieved. With smartphone apps like Facebook, WhatsApp and Google+ security issues, we have only scratched the surface of the malevolent intent that is possible. Once autonomous vehicles and other IoT devices reach critical mass, the security issues are only going to multiply manifold and the impact of security flaws can have disastrous consequences. Imagine a malicious attacker taking control of traffic lights that talk to cars or cars talking to other cars to negotiate who gets to cross an intersection, or a mass rapid transit system that reroutes itself or changes frequency of rides depending on real-time ridership information using neural network based predictions. Imagine the impact of such a thing gone wrong. With the current day deep learning algorithms themselves not being tractable (i.e. one can not reliably track the computation from input data to the prediction step by step as in &lt;a href=&quot;https://skymind.ai/wiki/symbolic-reasoning&quot;&gt;symbolic AI&lt;/a&gt;) it is going to be more challenging to resolve a security issue even after having identified it. Apologies for being pessimistic - but one should see this as a challenge for computer architecture and computer security research - a great time to be working in any of these fields.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you want a job for the next one year, learn web/mobile app development, if you need a job for the next five years, train yourself with deep learning skills, if you need a job for the rest of your life, start working on computer security.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;An interesting short documentary I happened to watch recently:&lt;/p&gt;

&lt;div class=&quot;img_container&quot;&gt;
  &lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/KGX-c5BJNFk&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;</content>

      
      
      
      
      

      

      
        <category term="technology" />
      
        <category term="privacy" />
      
        <category term="security" />
      

      

      
        <summary type="html">Happy New year friends! What a year 2018 has been for the topic of privacy and security - from the most loved social network scrambling for clues to save themselves to the other social network built by the world’s best engineers still couldn’t save their data, besides struggling to stay relevant. While Europe was quick to pass GDPR, many other countries even in the developed world are yet to catch up with such laws and regulations. 2018 was also the year that saw the surge in smart speakers and home automation - isn’t that ironic? But this story is not about the past, but about the future. Many top technology and auto companies rushing to fulfill the promise of self-driving or autonomous vehicles. It will definitely become a reality, to some extent, in at least the parts of the world where the infrastructure supports it. But the notion of foolproof security for such a technology is far from being achieved. With smartphone apps like Facebook, WhatsApp and Google+ security issues, we have only scratched the surface of the malevolent intent that is possible. Once autonomous vehicles and other IoT devices reach critical mass, the security issues are only going to multiply manifold and the impact of security flaws can have disastrous consequences. Imagine a malicious attacker taking control of traffic lights that talk to cars or cars talking to other cars to negotiate who gets to cross an intersection, or a mass rapid transit system that reroutes itself or changes frequency of rides depending on real-time ridership information using neural network based predictions. Imagine the impact of such a thing gone wrong. With the current day deep learning algorithms themselves not being tractable (i.e. one can not reliably track the computation from input data to the prediction step by step as in symbolic AI) it is going to be more challenging to resolve a security issue even after having identified it. Apologies for being pessimistic - but one should see this as a challenge for computer architecture and computer security research - a great time to be working in any of these fields. If you want a job for the next one year, learn web/mobile app development, if you need a job for the next five years, train yourself with deep learning skills, if you need a job for the rest of your life, start working on computer security. An interesting short documentary I happened to watch recently:</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Google’s product portfolio →</title>
      
      <link href="https://dotkay.github.io/2018/08/16/google-product-portfolio/" rel="alternate" type="text/html" title="Google's product portfolio" />
      <published>2018-08-16T00:00:00+00:00</published>
      <updated>2018-08-16T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2018/08/16/google-product-portfolio</id>
      <content type="html" xml:base="https://dotkay.github.io/2018/08/16/google-product-portfolio/">&lt;p&gt;Keeping up with my modest goals from the &lt;a href=&quot;https://dotkay.github.io/2018/08/15/deep-learning-and-tech-products&quot;&gt;previous post&lt;/a&gt;, I started looking at Google’s product portfolio.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Why Google? - Why not?&lt;/li&gt;
  &lt;li&gt;Why their product portfolio? - there is such a rich variety catering to different customer segments.&lt;/li&gt;
  &lt;li&gt;Why for this topic (analysing how machine learning and/or deep learning will impact/improve the products)? - Because we already see the impact (like Google translate, maps, etc.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here’s their product portfolio, right from their webpage:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;img_container&quot;&gt;
  &lt;p&gt;&lt;img src=&quot;/assets/images/products/G_product_portfolio.png&quot; alt=&quot;Google Product Portfolio&quot; class=&quot;img=responsive&quot; /&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;In future posts, we will pick products from this list and analyze.&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="technology" />
      
        <category term="products" />
      
        <category term="Google" />
      

      

      
        <summary type="html">Keeping up with my modest goals from the previous post, I started looking at Google’s product portfolio. Why Google? - Why not? Why their product portfolio? - there is such a rich variety catering to different customer segments. Why for this topic (analysing how machine learning and/or deep learning will impact/improve the products)? - Because we already see the impact (like Google translate, maps, etc.) Here’s their product portfolio, right from their webpage: In future posts, we will pick products from this list and analyze.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Deep Learning and Technology Products →</title>
      
      <link href="https://dotkay.github.io/2018/08/15/deep-learning-and-tech-products/" rel="alternate" type="text/html" title="Deep Learning and Technology Products" />
      <published>2018-08-15T00:00:00+00:00</published>
      <updated>2018-08-15T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2018/08/15/deep-learning-and-tech-products</id>
      <content type="html" xml:base="https://dotkay.github.io/2018/08/15/deep-learning-and-tech-products/">&lt;p&gt;I happened to complete an online course on Deep Learning and just starting to look at different products to see how machine learning or deep learning techniques could be used to make these products better. Since I understand technology products and their landscape better, I am likely to be biased in analysing more technology products than non-tech ones, although I am determined to study some non-tech industries, processes, products and services to see if (at all) and how deep learning could be used there - that is a bigger challenge and one that would stimulate our neurons more. Let’s see how I fare …&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="technology" />
      
        <category term="deep learning" />
      
        <category term="Google" />
      

      

      
        <summary type="html">I happened to complete an online course on Deep Learning and just starting to look at different products to see how machine learning or deep learning techniques could be used to make these products better. Since I understand technology products and their landscape better, I am likely to be biased in analysing more technology products than non-tech ones, although I am determined to study some non-tech industries, processes, products and services to see if (at all) and how deep learning could be used there - that is a bigger challenge and one that would stimulate our neurons more. Let’s see how I fare …</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Drones for fire fighting… →</title>
      
      <link href="https://dotkay.github.io/2018/08/11/drones-for-fire-fighting/" rel="alternate" type="text/html" title="Drones for fire fighting..." />
      <published>2018-08-11T00:00:00+00:00</published>
      <updated>2018-08-11T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2018/08/11/drones-for-fire-fighting</id>
      <content type="html" xml:base="https://dotkay.github.io/2018/08/11/drones-for-fire-fighting/">&lt;p&gt;While driving back from a camping along with my friends and looking at the vast possibly burnt areas, we started thinking why even in the &lt;em&gt;so called&lt;/em&gt; hot bed of technology (Silicon Valley) we &lt;a href=&quot;https://www.mercurynews.com/2018/07/30/why-planes-cant-fight-shastas-deadly-carr-fire/&quot;&gt;hear&lt;/a&gt; that fire fighting aircrafts had visibility problems because of the dense smoke. Why can’t we use autonomous drone technology for fighting wild fires (given that we use unmanned drones for warfare). Something to think about seriously.&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="technology" />
      
        <category term="autonomous transport" />
      

      

      
        <summary type="html">While driving back from a camping along with my friends and looking at the vast possibly burnt areas, we started thinking why even in the so called hot bed of technology (Silicon Valley) we hear that fire fighting aircrafts had visibility problems because of the dense smoke. Why can’t we use autonomous drone technology for fighting wild fires (given that we use unmanned drones for warfare). Something to think about seriously.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Languages, mind and our way of thinking… →</title>
      
      <link href="https://dotkay.github.io/2018/07/15/hidden-brain-languages-mind/" rel="alternate" type="text/html" title="Languages, mind and our way of thinking..." />
      <published>2018-07-15T00:00:00+00:00</published>
      <updated>2018-07-15T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2018/07/15/hidden-brain-languages-mind</id>
      <content type="html" xml:base="https://dotkay.github.io/2018/07/15/hidden-brain-languages-mind/">&lt;p&gt;Allez les Bleus!!&lt;/p&gt;

&lt;p&gt;Just happened to listen to this week’s episode of one of the recent NPR podcast series titled &lt;a href=&quot;https://www.npr.org/series/423302056/hidden-brain&quot;&gt;Hidden Brain&lt;/a&gt; and it got me thinking a lot. I speak almost 5 languages (not fluently but to different degrees of expertise) and I am not sure how my mind thinks. One thing for sure though is that I happen to think in my mother tongue and my mind translates it in (almost) real-time while I communicate, be it talking or writing down my thoughts as I do while writing this blog post. If languages do influence our thinking and understanding and more importantly the biases we cultivate, what does it mean for language translators - do they also convey the biases that are inherently influenced by one’s language? Or as a technologist I am also inclined to think what would it mean for AI systems (say chat-bots) that are meant to facilitate communication? I now tend to believe that they have to be designed with the intricacies of languages and the influences, biases that it carries along encoded into the system in order for it to be more acceptable. Even if not as a chat-bot, it would be a great system to train people to work with people of different cultures so that we understand different cultures better and comfortably communicate taking into account their nuances.&lt;/p&gt;

&lt;p&gt;If you are interested in listening to it, here it is:&lt;/p&gt;
&lt;audio controls=&quot;&quot;&gt;
&lt;source src=&quot;https://play.podtrac.com/npr-510308/ondemand.npr.org/anon.npr-mp3/npr/hiddenbrain/2018/07/20180712_hiddenbrain_hb_rad_-_watch_your_mouth__-_final_full_for_web.mp3&quot; /&gt;
&lt;/audio&gt;</content>

      
      
      
      
      

      

      
        <category term="psychology" />
      
        <category term="languages" />
      
        <category term="NPR" />
      

      

      
        <summary type="html">Allez les Bleus!! Just happened to listen to this week’s episode of one of the recent NPR podcast series titled Hidden Brain and it got me thinking a lot. I speak almost 5 languages (not fluently but to different degrees of expertise) and I am not sure how my mind thinks. One thing for sure though is that I happen to think in my mother tongue and my mind translates it in (almost) real-time while I communicate, be it talking or writing down my thoughts as I do while writing this blog post. If languages do influence our thinking and understanding and more importantly the biases we cultivate, what does it mean for language translators - do they also convey the biases that are inherently influenced by one’s language? Or as a technologist I am also inclined to think what would it mean for AI systems (say chat-bots) that are meant to facilitate communication? I now tend to believe that they have to be designed with the intricacies of languages and the influences, biases that it carries along encoded into the system in order for it to be more acceptable. Even if not as a chat-bot, it would be a great system to train people to work with people of different cultures so that we understand different cultures better and comfortably communicate taking into account their nuances. If you are interested in listening to it, here it is:</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Climbing stairs and remembering the past… →</title>
      
      <link href="https://dotkay.github.io/2018/05/06/climbing-stairs-dp/" rel="alternate" type="text/html" title="Climbing stairs and remembering the past..." />
      <published>2018-05-06T00:00:00+00:00</published>
      <updated>2018-05-06T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2018/05/06/climbing-stairs-dp</id>
      <content type="html" xml:base="https://dotkay.github.io/2018/05/06/climbing-stairs-dp/">&lt;blockquote&gt;
  &lt;p&gt;Those who cannot remember the past are condemned to repeat it!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In our &lt;a href=&quot;https://dotkay.github.io/2018/05/05/climbing-stairs-recursively&quot;&gt;previous post&lt;/a&gt; we saw a recursive algorithm to compute the number of ways one can climb a fleet of &lt;em&gt;n&lt;/em&gt; steps. If you draw the recursion tree for such an algorithm, we would soon find that we are computing some of the sub-problems repeatedly. We can do better by remembering (i.e. storing in some data structure) what we computed so that we can retrieve it and reuse it when needed again. Or in other fancy computer science parlance, we can use &lt;em&gt;dynamic programming&lt;/em&gt; technique to solve such recursive problems more efficiently.&lt;/p&gt;

&lt;p&gt;Here is the recursion tree for a hypothetical problem, similar to climbing stairs from our &lt;a href=&quot;https://dotkay.github.io/2018/05/05/climbing-stairs-recursively&quot;&gt;previous post&lt;/a&gt; where each function call for an input parameter value &lt;em&gt;n&lt;/em&gt; leads to two calls for values &lt;em&gt;n-1&lt;/em&gt; and &lt;em&gt;n-2&lt;/em&gt;. We can readily see, even in this very small example, that the all the function calls in the sub-tree rooted at &lt;em&gt;2&lt;/em&gt; is computed again unnecessarily. One of the main ideas in dynamic programming is to store such computations so that we can reuse them when needed again.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;/assets/images/algorithms/cpp/rec_tree.jpg&quot; alt=&quot;recursion tree&quot; class=&quot;img=responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Let us try to use dynamic programming and rewrite our algorithm for computing the number of ways of climbing &lt;em&gt;n&lt;/em&gt; steps. We shall use a simple array (a C++ vector) to store intermediate computations. More concretely, we will store the number of ways of climbing 1 step, the number of ways of climbing 2 steps, and so on. So, our array &lt;code class=&quot;highlighter-rouge&quot;&gt;ways&lt;/code&gt; stores the number of ways - &lt;code class=&quot;highlighter-rouge&quot;&gt;ways[i]&lt;/code&gt; gives us the number of ways of climbing &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; steps. As we saw in our previous post, the algorithm just needs to compute &lt;code class=&quot;highlighter-rouge&quot;&gt;ways[i-1] + ways[i-2]&lt;/code&gt; for different values of &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; upto &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; and finally return &lt;code class=&quot;highlighter-rouge&quot;&gt;ways[n]&lt;/code&gt; as the result.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;
  &lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;stairs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ways&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// base case&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;ways&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;ways&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ways&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ways&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ways&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ways&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;

&lt;p&gt;An astute reader would start thinking how this is different from divide-and-conquer approaches for solving recursive problems. I will let you think about it for now and find out for yourself what  technique is beneficial for what specific structure of the recursive problem - that was already a hint there!&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="algorithms" />
      
        <category term="dynamic programming" />
      
        <category term="C++" />
      

      

      
        <summary type="html">Those who cannot remember the past are condemned to repeat it! In our previous post we saw a recursive algorithm to compute the number of ways one can climb a fleet of n steps. If you draw the recursion tree for such an algorithm, we would soon find that we are computing some of the sub-problems repeatedly. We can do better by remembering (i.e. storing in some data structure) what we computed so that we can retrieve it and reuse it when needed again. Or in other fancy computer science parlance, we can use dynamic programming technique to solve such recursive problems more efficiently. Here is the recursion tree for a hypothetical problem, similar to climbing stairs from our previous post where each function call for an input parameter value n leads to two calls for values n-1 and n-2. We can readily see, even in this very small example, that the all the function calls in the sub-tree rooted at 2 is computed again unnecessarily. One of the main ideas in dynamic programming is to store such computations so that we can reuse them when needed again. Let us try to use dynamic programming and rewrite our algorithm for computing the number of ways of climbing n steps. We shall use a simple array (a C++ vector) to store intermediate computations. More concretely, we will store the number of ways of climbing 1 step, the number of ways of climbing 2 steps, and so on. So, our array ways stores the number of ways - ways[i] gives us the number of ways of climbing i steps. As we saw in our previous post, the algorithm just needs to compute ways[i-1] + ways[i-2] for different values of i upto n and finally return ways[n] as the result. int stairs(int n) { std::vector&amp;lt;int&amp;gt; ways(n+1); // base case if (n &amp;lt;= 1) return 1; ways[0] = 1; ways[1] = 1; for (int i = 2; i &amp;lt;= n; i++) ways[i] = ways[i-1] + ways[i-2]; return ways[n]; } An astute reader would start thinking how this is different from divide-and-conquer approaches for solving recursive problems. I will let you think about it for now and find out for yourself what technique is beneficial for what specific structure of the recursive problem - that was already a hint there!</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Climbing stairs recursively →</title>
      
      <link href="https://dotkay.github.io/2018/05/05/climbing-stairs-recursively/" rel="alternate" type="text/html" title="Climbing stairs recursively" />
      <published>2018-05-05T00:00:00+00:00</published>
      <updated>2018-05-05T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2018/05/05/climbing-stairs-recursively</id>
      <content type="html" xml:base="https://dotkay.github.io/2018/05/05/climbing-stairs-recursively/">&lt;blockquote&gt;
  &lt;p&gt;How many different ways can you reach atop a fleet of &lt;em&gt;n&lt;/em&gt; step stairs taking one or two step jumps at a time?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This question might ring a bell for some who have heard about an Italian mathematician who computed a similar sequence for counting rabbits in his garden. Let us think about it using a smaller example and generalize the solution. Let us say we have only 2 steps to climb. Given the constraints (1 step or 2 step climbs only), we can complete 2 steps in the following ways:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;1 step, 1 step&lt;/li&gt;
  &lt;li&gt;2 steps&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2 possible ways. How about 3 steps?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;1 step, 1 step, 1 step&lt;/li&gt;
  &lt;li&gt;1 step, 2 steps&lt;/li&gt;
  &lt;li&gt;2 steps, 1 step&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;/assets/images/algorithms/cpp/three_steps.jpg&quot; alt=&quot;3 steps&quot; class=&quot;img=responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So, 3 possible ways. What about if we have an additional one to climb (i.e. total of 4 steps to climb)? We can do it in the following ways:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;1 step, 1 step, 1 step, 1 step&lt;/li&gt;
  &lt;li&gt;1 step, 2 steps, 1 step&lt;/li&gt;
  &lt;li&gt;1 step, 1 step, 2 steps&lt;/li&gt;
  &lt;li&gt;2 steps, 1 step, 1 step&lt;/li&gt;
  &lt;li&gt;2 steps, 2 steps&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;/assets/images/algorithms/cpp/four_steps.jpg&quot; alt=&quot;4 steps&quot; class=&quot;img=responsive&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We also notice that the number of ways of climbing 4 steps is the number of ways of climbing 2 steps + the number of ways we could climb 3 steps. Recursively, we could compute for any &lt;em&gt;n&lt;/em&gt; steps, given the constraints, we could climb it by computing the number of ways of climbing &lt;em&gt;n-1&lt;/em&gt; and &lt;em&gt;n-2&lt;/em&gt; steps.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;
  &lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;stairs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// base cases&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stairs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stairs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;</content>

      
      
      
      
      

      

      
        <category term="algorithms" />
      
        <category term="recursion" />
      
        <category term="C++" />
      

      

      
        <summary type="html">How many different ways can you reach atop a fleet of n step stairs taking one or two step jumps at a time? This question might ring a bell for some who have heard about an Italian mathematician who computed a similar sequence for counting rabbits in his garden. Let us think about it using a smaller example and generalize the solution. Let us say we have only 2 steps to climb. Given the constraints (1 step or 2 step climbs only), we can complete 2 steps in the following ways: 1 step, 1 step 2 steps 2 possible ways. How about 3 steps? 1 step, 1 step, 1 step 1 step, 2 steps 2 steps, 1 step So, 3 possible ways. What about if we have an additional one to climb (i.e. total of 4 steps to climb)? We can do it in the following ways: 1 step, 1 step, 1 step, 1 step 1 step, 2 steps, 1 step 1 step, 1 step, 2 steps 2 steps, 1 step, 1 step 2 steps, 2 steps We also notice that the number of ways of climbing 4 steps is the number of ways of climbing 2 steps + the number of ways we could climb 3 steps. Recursively, we could compute for any n steps, given the constraints, we could climb it by computing the number of ways of climbing n-1 and n-2 steps. int stairs(int n) { // base cases if (n &amp;lt;= 2) return n; int res = stairs(n-1) + stairs(n-2); return res; }</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">More efficient computation of equillibrium index in an array →</title>
      
      <link href="https://dotkay.github.io/2018/04/23/arr-equillibrium/" rel="alternate" type="text/html" title="More efficient computation of equillibrium index in an array" />
      <published>2018-04-23T00:00:00+00:00</published>
      <updated>2018-04-23T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2018/04/23/arr-equillibrium</id>
      <content type="html" xml:base="https://dotkay.github.io/2018/04/23/arr-equillibrium/">&lt;p&gt;In an &lt;a href=&quot;https://dotkay.github.io/2018/04/20/arr-equillibrium-naive&quot;&gt;earlier post&lt;/a&gt;, we saw how to compute the equillibrium index of an array. But it was a very ordinary implementation - &lt;code class=&quot;highlighter-rouge&quot;&gt;O(n^2)&lt;/code&gt;. We could do much better with some auxiliary space spent, i.e. we maintain an auxiliary array to keep a running sum of the elements to the left as we traverse the array.&lt;/p&gt;

&lt;p&gt;Here is the idea. We would create an auxiliary array of the same size as the input array. As we traverse the input array from left to right, we compute the &lt;em&gt;prefix sum&lt;/em&gt; of the elements in the array and store it in this auxiliary array (&lt;code class=&quot;highlighter-rouge&quot;&gt;left_sum&lt;/code&gt; in the code fragment below). Now, &lt;code class=&quot;highlighter-rouge&quot;&gt;left sum&lt;/code&gt; can be used to query, for example, the sum of elements to the left of any index &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; as we traverse the array.&lt;/p&gt;

&lt;p&gt;We now traverse the input array, this time from right to left, and keep a running sum of the elements in a single variable (&lt;code class=&quot;highlighter-rouge&quot;&gt;right_sum&lt;/code&gt; in code fragment below). As we traverse, we check for a match in the auxiliary array we had built earlier for the left sum, and if there is a match we have found an equillibrium point. Since we do array traversal only twice, this becomes an &lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt; solution with &lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt; auxiliary space for storing the prefix sums.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;
  &lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;eq_index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// compute the left sum&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left_sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;left_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;left_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// traverse input array from the right,&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// computing right_sum and matching it with&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// left sum (i.e. looking for equillibrium)&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right_sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right_sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;equillibrium found at index: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;right_sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;

&lt;p&gt;Power of prefix sums!&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="algorithms" />
      
        <category term="data structures" />
      
        <category term="arrays" />
      

      

      
        <summary type="html">In an earlier post, we saw how to compute the equillibrium index of an array. But it was a very ordinary implementation - O(n^2). We could do much better with some auxiliary space spent, i.e. we maintain an auxiliary array to keep a running sum of the elements to the left as we traverse the array. Here is the idea. We would create an auxiliary array of the same size as the input array. As we traverse the input array from left to right, we compute the prefix sum of the elements in the array and store it in this auxiliary array (left_sum in the code fragment below). Now, left sum can be used to query, for example, the sum of elements to the left of any index i as we traverse the array. We now traverse the input array, this time from right to left, and keep a running sum of the elements in a single variable (right_sum in code fragment below). As we traverse, we check for a match in the auxiliary array we had built earlier for the left sum, and if there is a match we have found an equillibrium point. Since we do array traversal only twice, this becomes an O(n) solution with O(n) auxiliary space for storing the prefix sums. void eq_index(int arr[], int n) { // compute the left sum int* left_sum = new int[n]; left_sum[0] = arr[0]; for (int i = 1; i &amp;lt; n; i++) left_sum[i] = left_sum[i-1] + arr[i-1]; // traverse input array from the right, // computing right_sum and matching it with // left sum (i.e. looking for equillibrium) int right_sum = 0; for (int i = n-1; i &amp;gt;= 0; i--) { if (right_sum == left_sum[i]) std::cout &amp;lt;&amp;lt; &quot;equillibrium found at index: &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; right_sum += arr[i]; } } Power of prefix sums!</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Finding the equillibrium index in an array →</title>
      
      <link href="https://dotkay.github.io/2018/04/20/arr-equillibrium-naive/" rel="alternate" type="text/html" title="Finding the equillibrium index in an array" />
      <published>2018-04-20T00:00:00+00:00</published>
      <updated>2018-04-20T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2018/04/20/arr-equillibrium-naive</id>
      <content type="html" xml:base="https://dotkay.github.io/2018/04/20/arr-equillibrium-naive/">&lt;blockquote&gt;
  &lt;p&gt;The equillibrium point in a given array is said to be the index such that the sum of all the elements before the index equals the sum of all the elements to the right of the index.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example, if the input array is &lt;code class=&quot;highlighter-rouge&quot;&gt;[0, -3, 5, -4, -2, 3, 1, 0]&lt;/code&gt;, the equillibrium indices are 7, 3 and 0. Note that &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; is an equillibrium index if the sum of all the elements until the end of the array are 0 and similarly, &lt;code class=&quot;highlighter-rouge&quot;&gt;n-1&lt;/code&gt; is an equillibrium index of all the elements from 0 until &lt;code class=&quot;highlighter-rouge&quot;&gt;n-1&lt;/code&gt; add up to 0.&lt;/p&gt;

&lt;p&gt;Let us look at a very straight-forward solution. We could just traverse the array and for each element compute the sum of elements to the left and the sum of elements to the right (&lt;code class=&quot;highlighter-rouge&quot;&gt;lsum&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;rsum&lt;/code&gt; in the code fragment below) and check if they are equal as we traverse the array.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;
  &lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;eq_index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lsum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rsum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lsum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rsum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;lsum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;rsum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lsum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rsum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;equillibrium found at index: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;

&lt;p&gt;As you can realize immediately, this is an &lt;code class=&quot;highlighter-rouge&quot;&gt;O(n^2)&lt;/code&gt; solution. Can we do better?&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="algorithms" />
      
        <category term="data structures" />
      
        <category term="arrays" />
      

      

      
        <summary type="html">The equillibrium point in a given array is said to be the index such that the sum of all the elements before the index equals the sum of all the elements to the right of the index. For example, if the input array is [0, -3, 5, -4, -2, 3, 1, 0], the equillibrium indices are 7, 3 and 0. Note that 0 is an equillibrium index if the sum of all the elements until the end of the array are 0 and similarly, n-1 is an equillibrium index of all the elements from 0 until n-1 add up to 0. Let us look at a very straight-forward solution. We could just traverse the array and for each element compute the sum of elements to the left and the sum of elements to the right (lsum and rsum in the code fragment below) and check if they are equal as we traverse the array. void eq_index(int arr[], int n) { int lsum, rsum; for (int i = 0; i &amp;lt; n; i++) { lsum = 0; rsum = 0; for (int j = 0; j &amp;lt; i; j++) lsum += arr[j]; for (int j = i+1; j &amp;lt;n; j++) rsum += arr[j]; if (lsum == rsum) std::cout &amp;lt;&amp;lt; &quot;equillibrium found at index: &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; } } As you can realize immediately, this is an O(n^2) solution. Can we do better?</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Reversing elements of an array in groups →</title>
      
      <link href="https://dotkay.github.io/2018/04/17/reverse-subarray-groups/" rel="alternate" type="text/html" title="Reversing elements of an array in groups" />
      <published>2018-04-17T00:00:00+00:00</published>
      <updated>2018-04-17T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2018/04/17/reverse-subarray-groups</id>
      <content type="html" xml:base="https://dotkay.github.io/2018/04/17/reverse-subarray-groups/">&lt;p&gt;Earlier, we &lt;a href=&quot;https://dotkay.github.io/2018/04/05/reverse-a-subarray&quot;&gt;saw how to reverse a sub-array&lt;/a&gt; given the window to be reversed. How do we reverse an array in subarray groups? For example, if our input array is &lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 2, 3, 4, 5, 6, 7, 8]&lt;/code&gt; and group size is &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;, we want to reverse every group of 3 elements in the array and the remaining ones. Something like:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 2 3 4 5 6 7 8                 -&amp;gt; input array
(3 2 1) 4 5 6 7 8               -&amp;gt; first group of 3 elements reversed;
                                   group denoted by (..)
(3 2 1) (6 5 4) 7 8             -&amp;gt; second group of 3 elements reversed
(3 2 1) (6 5 4) (8 7)           -&amp;gt; remaining elements (less than group size)
                                   reversed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The algorithm is very similar to the earlier one, just that we need to take care of the group boundaries while traversal and reversing, just like how we took care of boundaries while reversing subarrays.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;
  &lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reverse_in_groups&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;

&lt;p&gt;Here, &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; denotes the size of the input array &lt;code class=&quot;highlighter-rouge&quot;&gt;arr&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;g&lt;/code&gt; denotes the size of the group.&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="algorithms" />
      
        <category term="data structures" />
      
        <category term="arrays" />
      

      

      
        <summary type="html">Earlier, we saw how to reverse a sub-array given the window to be reversed. How do we reverse an array in subarray groups? For example, if our input array is [1, 2, 3, 4, 5, 6, 7, 8] and group size is 3, we want to reverse every group of 3 elements in the array and the remaining ones. Something like: 1 2 3 4 5 6 7 8 -&amp;gt; input array (3 2 1) 4 5 6 7 8 -&amp;gt; first group of 3 elements reversed; group denoted by (..) (3 2 1) (6 5 4) 7 8 -&amp;gt; second group of 3 elements reversed (3 2 1) (6 5 4) (8 7) -&amp;gt; remaining elements (less than group size) reversed The algorithm is very similar to the earlier one, just that we need to take care of the group boundaries while traversal and reversing, just like how we took care of boundaries while reversing subarrays. void reverse_in_groups(int arr[], int n, int g) { for (int i = 0; i &amp;lt; n; i += g) { int lo = i; int hi = min(i + g - 1, n - 1); while (lo &amp;lt; hi) { swap(&amp;amp;arr[lo++], &amp;amp;arr[hi--]); } } } Here, n denotes the size of the input array arr and g denotes the size of the group.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Finding the minimum absolute difference among array elements →</title>
      
      <link href="https://dotkay.github.io/2018/04/14/array-min-abs-diff/" rel="alternate" type="text/html" title="Finding the minimum absolute difference among array elements" />
      <published>2018-04-14T00:00:00+00:00</published>
      <updated>2018-04-14T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2018/04/14/array-min-abs-diff</id>
      <content type="html" xml:base="https://dotkay.github.io/2018/04/14/array-min-abs-diff/">&lt;p&gt;Let us see how do we compute the minimum absolute difference among elements of an array. Given that we are concerened about all the elements of the array tells us that we need to&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Traverse all the elements of the array (so complexity is already O(n))&lt;/li&gt;
  &lt;li&gt;Maintain a running counter that captures the minimum difference as we traverse the array - the idea is also to initialize this variable to MAX value so that we can record the minimum difference easily&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;
  &lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;min_abs_diff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min_diff&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT8_MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;diff&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;diff&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min_diff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;min_diff&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;diff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min_diff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;

&lt;p&gt;Note how we try not to overflow the array index (while evaluating &lt;code class=&quot;highlighter-rouge&quot;&gt;arr[i+1]&lt;/code&gt;) by computing modulo &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; - the size of the array.&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="algorithms" />
      
        <category term="data structures" />
      
        <category term="arrays" />
      

      

      
        <summary type="html">Let us see how do we compute the minimum absolute difference among elements of an array. Given that we are concerened about all the elements of the array tells us that we need to Traverse all the elements of the array (so complexity is already O(n)) Maintain a running counter that captures the minimum difference as we traverse the array - the idea is also to initialize this variable to MAX value so that we can record the minimum difference easily int min_abs_diff(int arr[], int n) { int min_diff = INT8_MAX; for (int i = 0; i &amp;lt; n; i++) { int diff = abs(arr[i] - arr[(i+1) % n]); if (diff &amp;lt; min_diff) min_diff = diff; } return min_diff; } Note how we try not to overflow the array index (while evaluating arr[i+1]) by computing modulo n - the size of the array.</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Searching for occurence of a pattern in a string →</title>
      
      <link href="https://dotkay.github.io/2018/04/09/string-pattern-search/" rel="alternate" type="text/html" title="Searching for occurence of a pattern in a string" />
      <published>2018-04-09T00:00:00+00:00</published>
      <updated>2018-04-09T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2018/04/09/string-pattern-search</id>
      <content type="html" xml:base="https://dotkay.github.io/2018/04/09/string-pattern-search/">&lt;p&gt;Let us write a very simple program to implement a simple variant of &lt;em&gt;str.find()&lt;/em&gt; that we used in our &lt;a href=&quot;https://dotkay.github.io/2018/04/04/string-rotation-by-n-check&quot;&gt;previous post&lt;/a&gt;. Basically, we want to write a function that accepts an input string and a pattern string and identifies if the pattern forms a substring of the input string and if it does tells us the &lt;em&gt;first&lt;/em&gt; index position of occurence in the input string.&lt;/p&gt;

&lt;p&gt;The naïve way is to traverse the input string looking for the pattern string. In order to do this, whenever we encounter the first character of the pattern string in the input string, we need to remember it and check if the following characters in the input string are the subsequent characters in the pattern string as well. We need to do this check (if successful) for as many characters as the length of the pattern string - quite intuitive.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Traverse the input string&lt;/li&gt;
  &lt;li&gt;As we traverse the input string, check if we encounter the first character of the pattern string
    &lt;ol&gt;
      &lt;li&gt;If the pattern string’s first character &lt;em&gt;does not&lt;/em&gt; match the current index character of the input string, keep moving forward in the input string while still waiting for a match for the first character of the pattern string.&lt;/li&gt;
      &lt;li&gt;If the pattern string’s first character &lt;em&gt;does&lt;/em&gt; match the current index character of the input string, move forward in the pattern string and check if the second character of the pattern string matches the next character in the input string&lt;/li&gt;
      &lt;li&gt;If we successfully match the subsequent characters of input string and we have reached the end of the pattern string (i.e. successfully matched as many characters as the length of the pattern string) return the index of the input string that matched the first character of the input string (from 2.2)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let us write it down as a C++ function:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;
  &lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pat_search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;plen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;plen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;plen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;plen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;

&lt;p&gt;This algorithm however matches only the first occurence of the pattern and not all occurences (there might be more than one occurence of the pattern in the input string). How do we modify the above algorithm to handle this case?&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="algorithms" />
      
        <category term="data structures" />
      
        <category term="strings" />
      

      

      
        <summary type="html">Let us write a very simple program to implement a simple variant of str.find() that we used in our previous post. Basically, we want to write a function that accepts an input string and a pattern string and identifies if the pattern forms a substring of the input string and if it does tells us the first index position of occurence in the input string. The naïve way is to traverse the input string looking for the pattern string. In order to do this, whenever we encounter the first character of the pattern string in the input string, we need to remember it and check if the following characters in the input string are the subsequent characters in the pattern string as well. We need to do this check (if successful) for as many characters as the length of the pattern string - quite intuitive. Traverse the input string As we traverse the input string, check if we encounter the first character of the pattern string If the pattern string’s first character does not match the current index character of the input string, keep moving forward in the input string while still waiting for a match for the first character of the pattern string. If the pattern string’s first character does match the current index character of the input string, move forward in the pattern string and check if the second character of the pattern string matches the next character in the input string If we successfully match the subsequent characters of input string and we have reached the end of the pattern string (i.e. successfully matched as many characters as the length of the pattern string) return the index of the input string that matched the first character of the input string (from 2.2) Let us write it down as a C++ function: int pat_search(std::string s, std::string pat) { int slen = s.length(); int plen = pat.length(); int res = -1; for (int i = 0; i &amp;lt;= slen - plen; i++) { int j; for (j = 0; j &amp;lt; plen; j++) { if (s[i+j] != pat[j]) break; } if (j == plen) return i; } return res; } This algorithm however matches only the first occurence of the pattern and not all occurences (there might be more than one occurence of the pattern in the input string). How do we modify the above algorithm to handle this case?</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Rotating an array counter clockwise around a given index →</title>
      
      <link href="https://dotkay.github.io/2018/04/08/rotate-array-ccw/" rel="alternate" type="text/html" title="Rotating an array counter clockwise around a given index" />
      <published>2018-04-08T00:00:00+00:00</published>
      <updated>2018-04-08T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2018/04/08/rotate-array-ccw</id>
      <content type="html" xml:base="https://dotkay.github.io/2018/04/08/rotate-array-ccw/">&lt;p&gt;Given an array, how do you rotate it counter clockwise around a given input index position? i.e. If the input array was &lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 2, 3, 4, 5, 6, 7, 8]&lt;/code&gt;, the result of rotation around index &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt; (that has the element 4) in the counter clockwise direction would be &lt;code class=&quot;highlighter-rouge&quot;&gt;[5, 6, 7, 8, 1, 2, 3, 4]&lt;/code&gt;. The sequence of transformations the array goes through as each of the elements until the given index rotates would be:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 2 3 4 5 6 7 8            --&amp;gt; input array
2 3 4 5 6 7 8 1            --&amp;gt; 1 has rotated away to the end of the array
3 4 5 6 7 8 1 2            --&amp;gt; 2 has rotated away following 1
4 5 6 7 8 1 2 3            --&amp;gt; now, it's 3's turn
5 6 7 8 1 2 3 4            --&amp;gt; the element at index 3 (i.e. 4) around which we
                               wanted to rotate has also completed.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can use the &lt;a href=&quot;https://dotkay.github.io/2018/04/05/reverse-a-subarray&quot;&gt;algorithm we developed to reverse a sub-array&lt;/a&gt;, in order to achieve this rotation. The idea is simple:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;First, reverse the sub-array consisting of elements from the beginning of the array until the pivot (around which we want to rotate the array) in place&lt;/li&gt;
  &lt;li&gt;Now, rotate the remaining sub-array alone (i.e. from the pivot until the end of the array&lt;/li&gt;
  &lt;li&gt;Complete it by reversing the entire array once&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 2 3 4 5 6 7 8            --&amp;gt; input array
4 3 2 1 5 6 7 8            --&amp;gt; step-1 first sub-array reversed
4 3 2 1 8 7 6 5            --&amp;gt; step-2 second sub-array reversed
5 6 7 8 1 2 3 4            --&amp;gt; step-3 rotation of the entire array 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;An implementation would look like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;
  &lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;rotate_arr_ccw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;reverse_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;reverse_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;reverse_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;</content>

      
      
      
      
      

      

      
        <category term="algorithms" />
      
        <category term="data structures" />
      
        <category term="arrays" />
      

      

      
        <summary type="html">Given an array, how do you rotate it counter clockwise around a given input index position? i.e. If the input array was [1, 2, 3, 4, 5, 6, 7, 8], the result of rotation around index 3 (that has the element 4) in the counter clockwise direction would be [5, 6, 7, 8, 1, 2, 3, 4]. The sequence of transformations the array goes through as each of the elements until the given index rotates would be: 1 2 3 4 5 6 7 8 --&amp;gt; input array 2 3 4 5 6 7 8 1 --&amp;gt; 1 has rotated away to the end of the array 3 4 5 6 7 8 1 2 --&amp;gt; 2 has rotated away following 1 4 5 6 7 8 1 2 3 --&amp;gt; now, it's 3's turn 5 6 7 8 1 2 3 4 --&amp;gt; the element at index 3 (i.e. 4) around which we wanted to rotate has also completed. We can use the algorithm we developed to reverse a sub-array, in order to achieve this rotation. The idea is simple: First, reverse the sub-array consisting of elements from the beginning of the array until the pivot (around which we want to rotate the array) in place Now, rotate the remaining sub-array alone (i.e. from the pivot until the end of the array Complete it by reversing the entire array once 1 2 3 4 5 6 7 8 --&amp;gt; input array 4 3 2 1 5 6 7 8 --&amp;gt; step-1 first sub-array reversed 4 3 2 1 8 7 6 5 --&amp;gt; step-2 second sub-array reversed 5 6 7 8 1 2 3 4 --&amp;gt; step-3 rotation of the entire array An implementation would look like: void rotate_arr_ccw(int arr[], int size, int pivot) { reverse_arr(arr, 0, pivot); reverse_arr(arr, pivot+1, size-1); reverse_arr(arr, 0, size-1); }</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Checking if a string is an isogram →</title>
      
      <link href="https://dotkay.github.io/2018/04/07/string-isogram/" rel="alternate" type="text/html" title="Checking if a string is an isogram" />
      <published>2018-04-07T00:00:00+00:00</published>
      <updated>2018-04-07T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2018/04/07/string-isogram</id>
      <content type="html" xml:base="https://dotkay.github.io/2018/04/07/string-isogram/">&lt;blockquote&gt;
  &lt;p&gt;A string is an isogram if no character in it appears more than once.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let us write a simple algorithm to identify if a given input string is an isogram. For simplicity let us consider only strings that have small characters and no spaces or special characters i.e. - only characters from &lt;em&gt;a&lt;/em&gt; to &lt;em&gt;z&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In our previous post, we learnt how to keep track of characters that appear in a string as we traverse the input string. We use the same idea here, just this time we simplify it to be 26 characters (&lt;em&gt;a&lt;/em&gt; to &lt;em&gt;z&lt;/em&gt;) instead of 256.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We traverse the input string and maintain a counter for each of the occurences in the string. Note that we subtract ‘a’ from the ASCII value as our strings contain only &lt;em&gt;a&lt;/em&gt; to &lt;em&gt;z&lt;/em&gt; and we want our index &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; to correspond to &lt;em&gt;a&lt;/em&gt;. The intention of this simplification was precisely to learn how to modify our algorithm for such specific use cases.&lt;/li&gt;
  &lt;li&gt;We traverse the counter array (which is essentially a mapping &lt;code class=&quot;highlighter-rouge&quot;&gt;seen: character -&amp;gt; count&lt;/code&gt; to see if any of the characters appeared more than once (i.e. their count mapping is greater than 1).&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;highlight&quot;&gt;
  &lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define MAX_CHARS 26
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isogram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_CHARS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// (1)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;seen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// (2)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;</content>

      
      
      
      
      

      

      
        <category term="algorithms" />
      
        <category term="data structures" />
      
        <category term="strings" />
      

      

      
        <summary type="html">A string is an isogram if no character in it appears more than once. Let us write a simple algorithm to identify if a given input string is an isogram. For simplicity let us consider only strings that have small characters and no spaces or special characters i.e. - only characters from a to z. In our previous post, we learnt how to keep track of characters that appear in a string as we traverse the input string. We use the same idea here, just this time we simplify it to be 26 characters (a to z) instead of 256. We traverse the input string and maintain a counter for each of the occurences in the string. Note that we subtract ‘a’ from the ASCII value as our strings contain only a to z and we want our index 0 to correspond to a. The intention of this simplification was precisely to learn how to modify our algorithm for such specific use cases. We traverse the counter array (which is essentially a mapping seen: character -&amp;gt; count to see if any of the characters appeared more than once (i.e. their count mapping is greater than 1). #define MAX_CHARS 26 bool isogram(std::string s) { int seen[MAX_CHARS] = {0}; int slen = s.length(); bool res = true; // (1) for (int i = 0; i &amp;lt; slen; i++) seen[s[i] - 'a']++; // (2) for (int i = 0; i &amp;lt; 26; i++) { if (seen[i] &amp;gt; 1) { res = false; break; } } return res; }</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Checking if two strings are isomorphic →</title>
      
      <link href="https://dotkay.github.io/2018/04/06/isomorphic-strings/" rel="alternate" type="text/html" title="Checking if two strings are isomorphic" />
      <published>2018-04-06T00:00:00+00:00</published>
      <updated>2018-04-06T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2018/04/06/isomorphic-strings</id>
      <content type="html" xml:base="https://dotkay.github.io/2018/04/06/isomorphic-strings/">&lt;p&gt;Today, let us see how we can figure out if two given input strings are &lt;em&gt;isomorphic&lt;/em&gt; using a time-efficient algorithm.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Given two strings s1 and s2 if there is a unique mapping from each of the characters of one to the other, then they are isomorphic&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;anna&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;naan&lt;/code&gt; are isomorphic with the mapping &lt;code class=&quot;highlighter-rouge&quot;&gt;a -&amp;gt; n&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;n -&amp;gt; a&lt;/code&gt;. Similarly &lt;code class=&quot;highlighter-rouge&quot;&gt;aab&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;xxy&lt;/code&gt; are isomorphic with the mapping &lt;code class=&quot;highlighter-rouge&quot;&gt;a -&amp;gt; x&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;b -&amp;gt; y&lt;/code&gt;, while &lt;code class=&quot;highlighter-rouge&quot;&gt;aab&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;xyz&lt;/code&gt; are not isomorphic. However, &lt;code class=&quot;highlighter-rouge&quot;&gt;anna&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;naa&lt;/code&gt; are not isomorphic as there is no direct mapping for the last &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;anna&lt;/code&gt; (a hint that the strings should be of equal length for them to be isomorphic).&lt;/p&gt;

&lt;p&gt;An approach is to traverse one of the strings and mark the occurence of the character in the string. The nice thing about character strings is that there are only 256 &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII characters&lt;/a&gt; and hence we can have a character array of size 256 to mark the occurence of characters in a string. Along with marking the occurence, we need to store the mapping of this character to the corresponding (array index) character of the second string.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;During the very first encounter of a character, say the first &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; (index 0) in &lt;code class=&quot;highlighter-rouge&quot;&gt;anna&lt;/code&gt;, we check if the corresponding index in the other string &lt;code class=&quot;highlighter-rouge&quot;&gt;naan&lt;/code&gt; has already been visited.&lt;/li&gt;
  &lt;li&gt;We visit it (i.e. remember it in some algorithmic way).&lt;/li&gt;
  &lt;li&gt;We store the mapping of this visit (i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;a -&amp;gt; n&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;If we encounter a character again, say the last &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;anna&lt;/code&gt;, we check for the mapping to see if the corresponding index in the second string is as per our expectations (i.e. obeys the mapping).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The way we maintain the mapping is through an array &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt; and we also maintain whether we already visited a particular character using an array &lt;code class=&quot;highlighter-rouge&quot;&gt;visited&lt;/code&gt;. Since we need two additional arrays of size 256 each, there is some cost we pay for this space. However, we traverse the input array only once and so it would be &lt;em&gt;O(n)&lt;/em&gt; time algorithm. These four steps are noted in the code fragment below for easier reference.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;
  &lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#define MAX_CHARS 256
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isomorphic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_CHARS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX_CHARS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// initialize map&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX_CHARS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// check if both strings are of equal length&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slen1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slen2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slen1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slen2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// traverse s1 and update marked and visited&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slen1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (1) first occurence&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// check if corresponding s2 char is visited&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;// (2) update visited&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                          

      &lt;span class=&quot;c1&quot;&gt;// (3) store mapping&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;                             
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (4) not the first occurence? check the mapping&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; 
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;</content>

      
      
      
      
      

      

      
        <category term="algorithms" />
      
        <category term="data structures" />
      
        <category term="strings" />
      

      

      
        <summary type="html">Today, let us see how we can figure out if two given input strings are isomorphic using a time-efficient algorithm. Given two strings s1 and s2 if there is a unique mapping from each of the characters of one to the other, then they are isomorphic For example, anna and naan are isomorphic with the mapping a -&amp;gt; n and n -&amp;gt; a. Similarly aab and xxy are isomorphic with the mapping a -&amp;gt; x and b -&amp;gt; y, while aab and xyz are not isomorphic. However, anna and naa are not isomorphic as there is no direct mapping for the last a of anna (a hint that the strings should be of equal length for them to be isomorphic). An approach is to traverse one of the strings and mark the occurence of the character in the string. The nice thing about character strings is that there are only 256 ASCII characters and hence we can have a character array of size 256 to mark the occurence of characters in a string. Along with marking the occurence, we need to store the mapping of this character to the corresponding (array index) character of the second string. During the very first encounter of a character, say the first a (index 0) in anna, we check if the corresponding index in the other string naan has already been visited. We visit it (i.e. remember it in some algorithmic way). We store the mapping of this visit (i.e. a -&amp;gt; n). If we encounter a character again, say the last a in anna, we check for the mapping to see if the corresponding index in the second string is as per our expectations (i.e. obeys the mapping). The way we maintain the mapping is through an array map and we also maintain whether we already visited a particular character using an array visited. Since we need two additional arrays of size 256 each, there is some cost we pay for this space. However, we traverse the input array only once and so it would be O(n) time algorithm. These four steps are noted in the code fragment below for easier reference. #define MAX_CHARS 256 bool isomorphic(std::string s1, std::string s2) { bool visited[MAX_CHARS] = { false }; int map[MAX_CHARS]; // initialize map for (int i = 0; i &amp;lt; MAX_CHARS; i++) map[i] = -1; // check if both strings are of equal length int slen1 = s1.length(); int slen2 = s2.length(); if (slen1 != slen2) return false; // traverse s1 and update marked and visited for (int i = 0; i &amp;lt; slen1; i++) { // (1) first occurence if (map[s1[i]] == -1) { // check if corresponding s2 char is visited if (visited[s2[i]] == true) return false; // (2) update visited visited[s2[i]] = true; // (3) store mapping map[s1[i]] = s2[i]; } // (4) not the first occurence? check the mapping else if (map[s1[i]] != s2[i]) return false; } return true; }</summary>
      

      
      
    </entry>
  
  
  
    <entry>
      
      <title type="html">Reversing a sub-array of an array in place →</title>
      
      <link href="https://dotkay.github.io/2018/04/05/reverse-a-subarray/" rel="alternate" type="text/html" title="Reversing a sub-array of an array in place" />
      <published>2018-04-05T00:00:00+00:00</published>
      <updated>2018-04-05T00:00:00+00:00</updated>
      <id>https://dotkay.github.io/2018/04/05/reverse-a-subarray</id>
      <content type="html" xml:base="https://dotkay.github.io/2018/04/05/reverse-a-subarray/">&lt;p&gt;In an &lt;a href=&quot;https://dotkay.github.io/2018/04/02/reverse-an-array/&quot;&gt;earlier post&lt;/a&gt;, we saw how to reverse a given input array. But, it reversed the entire array. What if we want to pick a fragment of the input array and reverse only that?&lt;/p&gt;

&lt;p&gt;Let us assume we are given the &lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;end&lt;/code&gt; indices - the window that we want to reverse. It is very similar to our previous approach, except that we need to be careful computing the indices to iterate on.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;
  &lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;reverse_arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/figure&gt;

&lt;p&gt;There is an &lt;a href=&quot;https://thebittheories.com/the-curious-case-of-binary-search-the-famous-bug-that-remained-undetected-for-20-years-973e89fc212&quot;&gt;interesting story&lt;/a&gt; about computation of mid-point given two window boundaries. At first glance, it would seem tempting to write it as &lt;code class=&quot;highlighter-rouge&quot;&gt;(start + end) / 2&lt;/code&gt; but it is safer (and more correct) to write it as &lt;code class=&quot;highlighter-rouge&quot;&gt;start + ((end - start) / 2)&lt;/code&gt;.&lt;/p&gt;</content>

      
      
      
      
      

      

      
        <category term="algorithms" />
      
        <category term="data structures" />
      
        <category term="arrays" />
      

      

      
        <summary type="html">In an earlier post, we saw how to reverse a given input array. But, it reversed the entire array. What if we want to pick a fragment of the input array and reverse only that? Let us assume we are given the start and end indices - the window that we want to reverse. It is very similar to our previous approach, except that we need to be careful computing the indices to iterate on. void reverse_arr(int arr[], int start, int end) { int mid = (start + ((end - start)/2)); for (int i = start; i &amp;lt;= mid; i++) swap(&amp;amp;arr[i], &amp;amp;arr[end - (i - start)]); } There is an interesting story about computation of mid-point given two window boundaries. At first glance, it would seem tempting to write it as (start + end) / 2 but it is safer (and more correct) to write it as start + ((end - start) / 2).</summary>
      

      
      
    </entry>
  
  
</feed>

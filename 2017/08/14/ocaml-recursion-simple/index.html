<!DOCTYPE html>
<html lang="en">
  <head>
  <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']],
            processEscapes: true
          }
        });
    </script>
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML">
  </script>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Let&#39;s play with some simple recursion</title>
  <meta name="description" content="Recursion has been one of my favourite concepts for a very long time much like my fascination for mathematical induction. The subtle differences between the two would be a topic for a separate post. Let’s do some simple recursive functions just to illustrate the beauty. I chose OCaml for this post as it is one of my favourite programming languages. Somehow, I feel that many algorithms when coded in OCaml look very intuitive and understandable than in other imperative programming languages. We will look at some algorithms in both OCaml and C in a later post and leave it to the reader to decide as to which one looks more intuitive. OCaml is a very nice functional programming language and it offers list as a primitive data type. For example, if we want a list of five integers, this is how we do it in OCaml: let l1 = [1;2;3;4;5];; We would usually think of the list data type itself to be a recursive definition. i.e., a list is made of either an empty list or a list composed of a head element and tail where tail itself is a list (possibly empty list). For example, in the list l1 above, 1 constitutes the head element and the tail corresponds to the list 2;3;4;5. Now, let’s write a recursive function to count the number of elements in the list. Let’s think of the base case: when the list is empty - in which case we just return 0 as the result. And let’s build our thought process this way - what if the list has just one element? This would correspond to a list where there is a single head element and an empty list as the tail. i.e., we count the single head element and the empty list (the tail) we know contributes 0 to our result (the base case we just saw in 1.). Now, when the list has 2 elements, we think of it as having a head element and a tail list that consists of a single element. Now, we count the head element and apply the same function (our counting) to count the number of elements in the tail list (which now corresponds to the case we saw in 2.). Essentially what we are doing is: If the list is empty, return 0 as the result If the list is not empty, count the head element (1) and call the function (recursively) to count the number of elements in the tail Now, let’s write the above two steps in the following program which we call lst_len (for list length), that takes a single input parameter lst: let rec lst_len lst = match lst with | [] -&amp;gt; 0 | h::t -&amp;gt; 1 + lst_len t;; (* val len_lst : &#39;a list -&amp;gt; int = &amp;lt;fun&amp;gt; *) Recursive functions in OCaml are defined with rec keyword. Let’s use this function to count the number of elements in our list l1: lst_len l1;; (* - : int = 5 *) Let’s use the same thought process to write a recursive function lst_sum to sum up (add) the elements of the list. let rec lst_sum lst = match lst with | [] -&amp;gt; 0 | h::t -&amp;gt; h + lst_sum t;; (* val lst_sum : int list -&amp;gt; int = &amp;lt;fun&amp;gt; *) And let’s use this function to sum up the elements in our list l1: lst_sum l1;; (* - : int = 15 *) Isn’t this intuitive and elegant way of programming? We’ll talk more about simple programs that can be written in an intuitive way and try to develop our understanding of the concepts in a clear way. Thanks for your interest and keep checking out this space for more.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dotkay.github.io/2017/08/14/ocaml-recursion-simple/">
  
  
  <link rel="alternate" type="application/rss+xml" title="" href="https://dotkay.github.io/feed.xml">

  

  
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Let&#39;s play with some simple recursion">
  <meta name="twitter:description" content="Recursion has been one of my favourite concepts for a very long time much like my fascination for mathematical induction. The subtle differences between the two would be a topic for a separate post...">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105390377-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">
    <!-- Mathjax Support 
    <a class="site-title" href="/"></a> 
    -->
    <img src="/assets/images/dotk.png" width="40" height="30">
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Posts</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline"><a href="http://dotkay.github.io/2017/08/14/ocaml-recursion-simple/">Let&#39;s play with some simple recursion &rarr;</a></h1>
    
    <p class="post-meta"><time datetime="2017-08-14T00:00:00+00:00" itemprop="datePublished">Aug 14, 2017</time> • 
  
  
    
  
    
      <a href="/categories/ocaml/">ocaml</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Recursion has been one of my favourite concepts for a very long time much like my fascination for mathematical induction. The subtle differences between the two would be a topic for a separate post.</p>

<p>Let’s do some simple recursive functions just to illustrate the beauty. I chose <a href="http://www.ocaml.org">OCaml</a> for this post as it is one of my favourite programming languages. Somehow, I feel that many algorithms when coded in OCaml look very intuitive and understandable than in other imperative programming languages. We will look at some algorithms in both OCaml and C in a later post and leave it to the reader to decide as to which one looks more intuitive.</p>

<p>OCaml is a very nice functional programming language and it offers <code class="language-plaintext highlighter-rouge">list</code> as a primitive data type. For example, if we want a list of five integers, this is how we do it in OCaml:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">];;</span></code></pre>
</figure>

<p>We would usually think of the list data type itself to be a recursive definition. i.e., a list is made of either an empty list or a list composed of a <code class="language-plaintext highlighter-rouge">head</code> element and <code class="language-plaintext highlighter-rouge">tail</code> where tail itself is a list (possibly empty list). For example, in the list <code class="language-plaintext highlighter-rouge">l1</code> above, <code class="language-plaintext highlighter-rouge">1</code> constitutes the head element and the tail corresponds to the list <code class="language-plaintext highlighter-rouge">2;3;4;5</code>.</p>

<p>Now, let’s write a recursive function to count the number of elements in the list.</p>

<ol>
  <li>Let’s think of the base case: when the list is empty - in which case we just return <code class="language-plaintext highlighter-rouge">0</code> as the result.</li>
  <li>And let’s build our thought process this way - what if the list has just one element? This would correspond to a list where there is a single head element and an empty list as the tail. i.e., we count the single head element and the empty list (the tail) we know contributes <code class="language-plaintext highlighter-rouge">0</code> to our result (the base case we just saw in 1.).</li>
  <li>Now, when the list has 2 elements, we think of it as having a head element and a tail list that consists of a single element. Now, we count the head element and apply the same function (our counting) to count the number of elements in the tail list (which now corresponds to the case we saw in 2.).</li>
</ol>

<p>Essentially what we are doing is:</p>

<ol>
  <li>If the list is empty, return 0 as the result</li>
  <li>If the list is not empty, count the head element (1) and call the function (recursively) to count the number of elements in the tail</li>
</ol>

<p>Now, let’s write the above two steps in the following program which we call <code class="language-plaintext highlighter-rouge">lst_len</code> (for list length), that takes a single input parameter <code class="language-plaintext highlighter-rouge">lst</code>:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">lst_len</span> <span class="n">lst</span> <span class="o">=</span> 
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="mi">0</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">lst_len</span> <span class="n">t</span><span class="p">;;</span>
<span class="c">(* val len_lst : 'a list -&gt; int = &lt;fun&gt; *)</span></code></pre>
</figure>

<p>Recursive functions in OCaml are defined with <code class="language-plaintext highlighter-rouge">rec</code> keyword. Let’s use this function to count the number of elements in our list <code class="language-plaintext highlighter-rouge">l1</code>:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="n">lst_len</span> <span class="n">l1</span><span class="p">;;</span>
<span class="c">(* - : int = 5 *)</span></code></pre>
</figure>

<p>Let’s use the same thought process to write a recursive function <code class="language-plaintext highlighter-rouge">lst_sum</code> to sum up (add) the elements of the list.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">lst_sum</span> <span class="n">lst</span> <span class="o">=</span> 
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="mi">0</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">h</span> <span class="o">+</span> <span class="n">lst_sum</span> <span class="n">t</span><span class="p">;;</span>
<span class="c">(* val lst_sum : int list -&gt; int = &lt;fun&gt; *)</span></code></pre>
</figure>

<p>And let’s use this function to sum up the elements in our list <code class="language-plaintext highlighter-rouge">l1</code>:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="n">lst_sum</span> <span class="n">l1</span><span class="p">;;</span>
<span class="c">(* - : int = 15 *)</span></code></pre>
</figure>

<p>Isn’t this intuitive and elegant way of programming? We’ll talk more about simple programs that can be written in an intuitive way and try to develop our understanding of the concepts in a clear way.</p>

<p>Thanks for your interest and keep checking out this space for more.</p>


  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://dotkay.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>

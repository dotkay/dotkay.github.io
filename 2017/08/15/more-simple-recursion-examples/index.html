<!DOCTYPE html>
<html lang="en">
  <!-- Mathjax Support -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>
<script type="text/javascript" async
src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML">
</script>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Some more recursion examples</title>
  <meta name="description" content="Continuing with our previous post on recursions, let’s play with a couple of more simple examples to get ourselves familiar. This is just to start thinking in terms of recursive functions for the problems we try to solve. This kind of thinking will become more useful when we learn about tail recursion in one of the future posts. Let’s write a small function, call it find, to find if a given element exists in a list. i.e., we are provided with an input list lst of integers and an integer x and the function would return true if x exists as one of the elements of lst and false otherwise. let rec find x lst = match lst with | [] -&amp;gt; false | h::t -&amp;gt; if (h = x) then true else (find x t);; (* val find : &#39;a -&amp;gt; &#39;a list -&amp;gt; bool = &amp;lt;fun&amp;gt; *) find 2 l1;; (* - : bool = true *) find 0 l1;; (* - : bool = false *) As before, we think of the base case and the recursive step. We recursively call the function on a sub-list of the input list, till the problem reduces to the base case - the empty list. Let’s try another simple examples - to find the minimum integer in the given list of integers. We will call the function find_min and it takes an input list lst. exception Failure of string let rec find_min lst = match lst with | [] -&amp;gt; failwith(&quot;empty list&quot;) | [h] -&amp;gt; h | h::t -&amp;gt; min h (find_min t);; (* val find_min : &#39;a list -&amp;gt; &#39;a = &amp;lt;fun&amp;gt; *) Let’s test it out: find_min l1;; (* - : int = 1 *) let l2 = [-2; -10; 1; 9; 11; 7; 17];; find_min l2;; (* - : int = -10 *) Let’s now move away from having lists as input, and work on an example that produces an output list. This is a very familiar introductory CS example - converting an input decimal number to it’s base-2 (binary) representation. Humans naturally count in base-10 (also called decimal) number system, probably because most of us were born with 10 fingers. Computers, to be technically correct I should say digital circuits, work on base-2 number system - they know 0 and 1. Just like how we count 0 .. 9 and then start counting 10 .. 19, followed by 20 .. 29, etc., digital circuits count 0, 1 followed by 10, 11 and then follow that by 100, 101, and 110, 111, etc. You see the pattern. Probably, it is more apparent if I write it one after the other: base-2 base-10 0 0 1 1 10 &amp;lt;-- restart 2 11 3 100 &amp;lt;-- restart 4 101 5 110 6 111 7 1000 &amp;lt;-- restart 8 1001 9 1010 10 &amp;lt;-- restart 1011 11 1100 12 1101 13 1110 14 1111 15 The usual way we compute the binary representation of a decimal number is to repeatedly divide it and collect the remainders. For example, if we want to compute the binary equivalent of decimal 7: 2 |_ 7 _ ^ 2 |_ 3 _ - (1) | 2 |_ 1 _ - (1) | ----------&amp;gt; 111 is the binary equivalent of decimal 7. Here, 3, 1 are quotients (n/2 - n being the input number initally and then the quotient) and the ones on the right within parantheses are the remainders (n mod 2). Let’s work out one more example - the binary equivalent of 13: 2 |_ 13 _ ^ 2 |_ 6 _ - (1) | 2 |_ 3 _ - (0) | 2 |_ 1 _ - (1) | --------&amp;gt; If you observe carefully, what we are doing essentially is repeatedly dividing the input number n by the base we want to convert our number to - in this case base-2, and collect the remainders. Dividing a number is the expression n/2 for algorithmic purposes and the remainder is the expression n mod 2. What we are going to do is to repeatedly (think “recursively”) divide n and collect the remainder in a list which we would eventually return as the output result. @ is the OCaml syntax for list concatenation: for example lst1 @ lst2 will concatenate lst1 and lst2. Note the base case for our computation. let rec bin_of_dec n = if n &amp;lt;= 0 then [] else bin_of_dec (n/2) @ (n mod 2)::[];; (* val bin_of_dec : int -&amp;gt; int list = &amp;lt;fun&amp;gt; *) Let’s check if what we worked out for 7 and 13 are consistent with what this program computes: bin_of_dec 7;; (* - : int list = [1; 1; 1] *) bin_of_dec 13;; (* - : int list = [1; 1; 0; 1] *) I guess it became a longer post than what I intended it to be, but I hope you are getting a better hang of thinking recursively. We will see more examples in future posts - feel motivated to play around with some examples in the mean time!!">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dotkay.github.io/2017/08/15/more-simple-recursion-examples/">
  
  
  <link rel="alternate" type="application/rss+xml" title="" href="https://dotkay.github.io/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Some more recursion examples">
  <meta name="twitter:description" content="Continuing with our previous post on recursions, let’s play with a couple of more simple examples to get ourselves familiar. This is just to start thinking in terms of recursive functions for the p...">
  
  

  
  
  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105390377-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">/assets/images/dotkay.png</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Posts</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline"><a href="https://dotkay.github.io/2017/08/15/more-simple-recursion-examples">Some more recursion examples &rarr;</a></h1>
    
    <p class="post-meta"><time datetime="2017-08-15T00:00:00+00:00" itemprop="datePublished">Aug 15, 2017</time> • 
  
  
    
  
    
      <a href="/categories/ocaml/">ocaml</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Continuing with our <a href="http://dotkay.github.io/2017/08/14/ocaml-recursion-simple/">previous post</a> on recursions, let’s play with a couple of more simple examples to get ourselves familiar. This is just to start thinking in terms of recursive functions for the problems we try to solve. This kind of thinking will become more useful when we learn about tail recursion in one of the future posts.</p>

<p>Let’s write a small function, call it <code class="language-plaintext highlighter-rouge">find</code>, to find if a given element exists in a list. i.e., we are provided with an input list <code class="language-plaintext highlighter-rouge">lst</code> of integers and an integer <code class="language-plaintext highlighter-rouge">x</code> and the function would return <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">x</code> exists as one of the elements of <code class="language-plaintext highlighter-rouge">lst</code> and <code class="language-plaintext highlighter-rouge">false</code> otherwise.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">find</span> <span class="n">x</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">false</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">x</span><span class="p">)</span> <span class="k">then</span> <span class="bp">true</span>
     <span class="k">else</span> <span class="p">(</span><span class="n">find</span> <span class="n">x</span> <span class="n">t</span><span class="p">);;</span>
<span class="c">(* val find : 'a -&gt; 'a list -&gt; bool = &lt;fun&gt; *)</span></code></pre>
</figure>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="n">find</span> <span class="mi">2</span> <span class="n">l1</span><span class="p">;;</span>
<span class="c">(* - : bool = true *)</span>
<span class="n">find</span> <span class="mi">0</span> <span class="n">l1</span><span class="p">;;</span>
<span class="c">(* - : bool = false *)</span></code></pre>
</figure>

<p>As before, we think of the base case and the recursive step. We recursively call the function on a sub-list of the input list, till the problem reduces to the base case - the empty list.</p>

<p>Let’s try another simple examples - to find the minimum integer in the given list of integers. We will call the function <code class="language-plaintext highlighter-rouge">find_min</code> and it takes an input list <code class="language-plaintext highlighter-rouge">lst</code>.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">exception</span> <span class="nc">Failure</span> <span class="k">of</span> <span class="kt">string</span>                   
<span class="k">let</span> <span class="k">rec</span> <span class="n">find_min</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">failwith</span><span class="p">(</span><span class="s2">"empty list"</span><span class="p">)</span>
  <span class="o">|</span> <span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">h</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">min</span> <span class="n">h</span> <span class="p">(</span><span class="n">find_min</span> <span class="n">t</span><span class="p">);;</span>
<span class="c">(* val find_min : 'a list -&gt; 'a = &lt;fun&gt; *)</span></code></pre>
</figure>

<p>Let’s test it out:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="n">find_min</span> <span class="n">l1</span><span class="p">;;</span>
<span class="c">(* - : int = 1 *)</span>
<span class="k">let</span> <span class="n">l2</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="o">-</span><span class="mi">10</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">9</span><span class="p">;</span> <span class="mi">11</span><span class="p">;</span> <span class="mi">7</span><span class="p">;</span> <span class="mi">17</span><span class="p">];;</span>
<span class="n">find_min</span> <span class="n">l2</span><span class="p">;;</span>
<span class="c">(* - : int = -10 *)</span></code></pre>
</figure>

<p>Let’s now move away from having lists as input, and work on an example that produces an output list. This is a very familiar introductory CS example - converting an input decimal number to it’s base-2 (<code class="language-plaintext highlighter-rouge">binary</code>) representation. Humans naturally count in base-10 (also called <code class="language-plaintext highlighter-rouge">decimal</code>) number system, probably because most of us were born with 10 fingers. Computers, to be technically correct I should say digital circuits, work on base-2 number system - they know <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">1</code>. Just like how we count 0 .. 9 and then start counting 10 .. 19, followed by 20 .. 29, etc., digital circuits  count 0, 1 followed by 10, 11 and then follow that by 100, 101, and 110,  111, etc. You see the pattern. Probably, it is more apparent if I write it one after the other:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  base-2    	   	  base-10
     0  	  	     0
     1  	  	     1
    10 	 &lt;-- restart	     2
    11 		 	     3
   100   &lt;-- restart 	     4
   101 	 	     	     5
   110 	 	     	     6
   111 	 	     	     7
  1000 	 &lt;-- restart 	     8
  1001 	 	     	     9
  1010 	 	    	    10   &lt;-- restart
  1011 	  	       	    11 
  1100           	    12
  1101           	    13
  1110           	    14
  1111           	    15
</code></pre></div></div>

<p>The usual way we compute the binary representation of a decimal number is to repeatedly divide it and collect the remainders. For example, if we want to compute the binary equivalent of decimal 7:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2 |_ 7 _          ^
  2 |_ 3 _   - (1) |
    2 |_ 1 _ - (1) |
         ----------&gt;
</code></pre></div></div>

<p>111 is the binary equivalent of decimal 7. Here, 3, 1 are quotients (<code class="language-plaintext highlighter-rouge">n/2</code> - n being the input number initally and then the quotient) and the ones on the right within parantheses are the remainders (<code class="language-plaintext highlighter-rouge">n mod 2</code>).</p>

<p>Let’s work out one more example - the binary equivalent of 13:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2 |_ 13 _               ^
  2 |_ 6 _        - (1) |
    2 |_ 3 _      - (0) |
      2 |_ 1 _    - (1) |
                --------&gt;
</code></pre></div></div>

<p>If you observe carefully, what we are doing essentially is repeatedly dividing the input number <code class="language-plaintext highlighter-rouge">n</code> by the base we want to convert our number to - in this case base-2, and collect the remainders. Dividing a number is the expression <code class="language-plaintext highlighter-rouge">n/2</code> for algorithmic purposes and the remainder is the expression <code class="language-plaintext highlighter-rouge">n mod 2</code>. What we are going to do is to repeatedly (think “recursively”) divide <code class="language-plaintext highlighter-rouge">n</code> and collect the remainder in a list which we would eventually return as the output result. <code class="language-plaintext highlighter-rouge">@</code> is the OCaml syntax for list concatenation: for example <code class="language-plaintext highlighter-rouge">lst1 @ lst2</code> will concatenate <code class="language-plaintext highlighter-rouge">lst1</code> and <code class="language-plaintext highlighter-rouge">lst2</code>. Note the base case for our computation.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">bin_of_dec</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="bp">[]</span>
  <span class="k">else</span> <span class="n">bin_of_dec</span> <span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">@</span>
         <span class="p">(</span><span class="n">n</span> <span class="ow">mod</span> <span class="mi">2</span><span class="p">)</span><span class="o">::</span><span class="bp">[]</span><span class="p">;;</span>
<span class="c">(* val bin_of_dec : int -&gt; int list = &lt;fun&gt; *)</span></code></pre>
</figure>

<p>Let’s check if what we worked out for 7 and 13 are consistent with what this program computes:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="n">bin_of_dec</span> <span class="mi">7</span><span class="p">;;</span>
<span class="c">(* - : int list = [1; 1; 1] *)</span>
<span class="n">bin_of_dec</span> <span class="mi">13</span><span class="p">;;</span>
<span class="c">(* - : int list = [1; 1; 0; 1] *)</span></code></pre>
</figure>

<p>I guess it became a longer post than what I intended it to be, but I hope you are getting a better hang of thinking recursively. We will see more examples in future posts - feel motivated to play around with some examples in the mean time!!</p>

  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://dotkay.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>

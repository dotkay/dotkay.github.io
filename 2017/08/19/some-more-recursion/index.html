<!DOCTYPE html>
<html lang="en">
  <!-- Mathjax Support -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>
<script type="text/javascript" async
src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML">
</script>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Some more recursion please...</title>
  <meta name="description" content="Let’s put on our thinking-in-recursion hat and put to use all that we have learned from our examples. We will do this by working out only two (so this will be a short post) examples that will use the recursion concepts that are bread and butter for us now. As a first example, we will write a function to eliminate consecutive repetitions of elements in a list. For example, if we pass the list [1;1;2;2;3;3;3;4;5;5] to our function, it should return [1;2;3;4;5], after removing the repetitions. How do we go about doing this? The moment we see consecutive repetitions, we know that we can easily track this by observing any two consecutive elements in the list while traversing the list. We need to observe at least two consecutive elements in order to find out if they are repetitions. So far, in our previous examples, we have usually been observing one element, the first element of a list (or a sub-list) calling it the head and denoting it h. Remember the pattern-matchings of the form | h::t -&amp;gt; in our previous code snippets? We were observing an element h concatenated with a list t. Now, we need to observe two consecutive elements instead of one, to check if they are repetitions - something of this shape | h1 :: h2::t. Now, we can compare h1 and h2 and check if h2 is a repetition of h1. If they are not the same, we can always treat h2::t as the rest-of-the-list, which we called t (as in h::t) in our previous examples. Now, let’s jump in to the algorithm: Base case - if it’s an empty list, nothing to check so we will just return an empty list Otherwise - we think of the list to be made up of a head element x1 and the rest-of-the-list. The rest-of-the-list part we will further expand (in order to allow for checking repetitions). So, let’s say the rest-of-the-list is made up of x2::x3 - x2 is the head element of rest-of-the-list and x3 is the rest-of-the-list part of our original rest-of-the-list. Our pattern to match would look something of this shape: x1 :: (x2::x3 as t) - the as t just gives a name t to x2::x3. if x1 and x2 are the same, then we recursively call the function on x2::x3. But, we threw x1 away and that’s fine because it was meant to be eliminated. We still have x2 that has the same value. If x1 and x2 are not the same, we know that x1 does not have a doppelganger following it, and so we will include it in our result list that we will eventually return. We just append x1 to the result of the function call on rest-of-the-list. Any other pattern, we just return the same pattern. Why do we need this? Because we want the patterns we match to be exhaustive - to cover all the cases. Suppose we have a list with a single element, this pattern would match that. let rec compress lst = match lst with | [] -&amp;gt; [] | x1 :: (x2::x3 as t) -&amp;gt; if (x1 = x2) then compress t else x1 :: compress t | smth_else -&amp;gt; smth_else;; It turned out to be pretty simple, right? Now, let’s work out another example before our enthusiasm dies down. Let’s do insertion sort. We will write it out as two recursive functions. Wait, don’t run away. It’s going to be simple. First, let us write a function that inserts an element x to a list lst, and it will insert x in such a way that the element next to x in lst would be great than x and the element before it would be less than or equal to x. Why are we writing this function? This is not insertion sort. Wait, it will be clear in a minute. We will call this function insert, takes two arguments x and lst. Base case - if lst is empty, we just insert x into the empty list and return it Otherwise, we have to traverse the list and see where to insert x. If head element is greater than x, it is easy - we just insert x at the head of the input list lst and return it. If not, we look for a position in the rest-of-the-list t to insert our x. let rec insert x lst = match lst with | [] -&amp;gt; [x] | h::t -&amp;gt; if (x &amp;lt;= h) then x::h::t else h::(insert x t);; Now, we will use the above function to write our insertion sort function isort. Just think what would happen if lst was already sorted in the above case. In that case, we would be inserting x to lst to maintain sorted order (just because of the rules that we imposed for inserting x). Let’s write down the algorithm. Base case - if lst is empty, return the empty list If the list has just one element, it is trivially sorted, just return the input list If the list has two or more elements, pick elements one by one, starting from the head element h and use our insert function to insert it into the appropriate position. let rec isort lst = match lst with | [] -&amp;gt; [] | [x] -&amp;gt; [x] | h::t -&amp;gt; insert h (isort t) Let’s check if it works on a simple test example: let l1 = [1;7;9;3;11;2;10];; isort l1;; (* - : int list = [1; 2; 3; 7; 9; 10; 11] *) That’s too much for my head for today. Let’s do more interesting examples in future posts when we get into the concept of tail recursion.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dotkay.github.io/2017/08/19/some-more-recursion/">
  
  
  <link rel="alternate" type="application/rss+xml" title="" href="https://dotkay.github.io/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Some more recursion please...">
  <meta name="twitter:description" content="Let’s put on our thinking-in-recursion hat and put to use all that we have learned from our examples. We will do this by working out only two (so this will be a short post) examples that will use t...">
  
  

  
  
  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105390377-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">
    <!-- Mathjax Support 
    <a class="site-title" href="/"></a> 
    -->
    <img src="/assets/images/dotk.png" width="50" height="30">
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Posts</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline"><a href="https://dotkay.github.io/2017/08/19/some-more-recursion">Some more recursion please... &rarr;</a></h1>
    
    <p class="post-meta"><time datetime="2017-08-19T00:00:00+00:00" itemprop="datePublished">Aug 19, 2017</time> • 
  
  
    
  
    
      <a href="/categories/ocaml/">ocaml</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Let’s put on our thinking-in-recursion hat and put to use all that we have learned from our examples. We will do this by working out only two (so this will be a short post) examples that will use the recursion concepts that are bread and butter for us now.</p>

<p>As a first example, we will write a function to eliminate consecutive repetitions of elements in a list. For example, if we pass the list <code class="language-plaintext highlighter-rouge">[1;1;2;2;3;3;3;4;5;5]</code> to our function, it should return <code class="language-plaintext highlighter-rouge">[1;2;3;4;5]</code>, after removing the repetitions. How do we go about doing this? The moment we see consecutive repetitions, we know that we can easily track this by observing any two consecutive elements in the list while traversing the list. We need to observe at least two consecutive elements in order to find out if they are repetitions. So far, in our previous examples, we have usually been observing one element, the first element of a list (or a sub-list) calling it the <code class="language-plaintext highlighter-rouge">head</code> and denoting it <code class="language-plaintext highlighter-rouge">h</code>. Remember the pattern-matchings of the form <code class="language-plaintext highlighter-rouge">| h::t -&gt; </code> in our previous code snippets? We were observing an element <code class="language-plaintext highlighter-rouge">h</code> concatenated with a list <code class="language-plaintext highlighter-rouge">t</code>. Now, we need to observe two consecutive elements instead of one, to check if they are repetitions - something of this shape <code class="language-plaintext highlighter-rouge">| h1 :: h2::t</code>. Now, we can compare <code class="language-plaintext highlighter-rouge">h1</code> and <code class="language-plaintext highlighter-rouge">h2</code> and check if <code class="language-plaintext highlighter-rouge">h2</code> is a repetition of <code class="language-plaintext highlighter-rouge">h1</code>. If they are not the same, we can always treat <code class="language-plaintext highlighter-rouge">h2::t</code> as the rest-of-the-list, which we called <code class="language-plaintext highlighter-rouge">t</code> (as in <code class="language-plaintext highlighter-rouge">h::t</code>) in our previous examples. Now, let’s jump in to the algorithm:</p>

<ol>
  <li>Base case - if it’s an empty list, nothing to check so we will just return an empty list</li>
  <li>Otherwise - we think of the list to be made up of a head element <code class="language-plaintext highlighter-rouge">x1</code> and the rest-of-the-list. The rest-of-the-list part we will further expand (in order to allow for checking repetitions). So, let’s say the rest-of-the-list is made up of <code class="language-plaintext highlighter-rouge">x2::x3</code> - <code class="language-plaintext highlighter-rouge">x2</code> is the head element of rest-of-the-list and <code class="language-plaintext highlighter-rouge">x3</code> is the rest-of-the-list part of our original rest-of-the-list. Our pattern to match would look something of this shape: <code class="language-plaintext highlighter-rouge">x1 :: (x2::x3 as t)</code> - the <code class="language-plaintext highlighter-rouge">as t</code> just gives a name <code class="language-plaintext highlighter-rouge">t</code> to <code class="language-plaintext highlighter-rouge">x2::x3</code>.
    <ul>
      <li>if <code class="language-plaintext highlighter-rouge">x1</code> and <code class="language-plaintext highlighter-rouge">x2</code> are the same, then we recursively call the function on <code class="language-plaintext highlighter-rouge">x2::x3</code>. But, we threw <code class="language-plaintext highlighter-rouge">x1</code> away and that’s fine because it was meant to be eliminated. We still have <code class="language-plaintext highlighter-rouge">x2</code> that has the same value.</li>
      <li>If <code class="language-plaintext highlighter-rouge">x1</code> and <code class="language-plaintext highlighter-rouge">x2</code> are not the same, we know that <code class="language-plaintext highlighter-rouge">x1</code> does not have a doppelganger following it, and so we will include it in our result list that we will eventually return. We just append <code class="language-plaintext highlighter-rouge">x1</code> to the result of the function call on rest-of-the-list.</li>
    </ul>
  </li>
  <li>Any other pattern, we just return the same pattern. Why do we need this? Because we want the patterns we match to be exhaustive - to cover all the cases. Suppose we have a list with a single element, this pattern would match that.</li>
</ol>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">compress</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">x1</span> <span class="o">::</span> <span class="p">(</span><span class="n">x2</span><span class="o">::</span><span class="n">x3</span> <span class="k">as</span> <span class="n">t</span><span class="p">)</span> <span class="o">-&gt;</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">x1</span> <span class="o">=</span> <span class="n">x2</span><span class="p">)</span> <span class="k">then</span> <span class="n">compress</span> <span class="n">t</span>
     <span class="k">else</span> <span class="n">x1</span> <span class="o">::</span> <span class="n">compress</span> <span class="n">t</span>
  <span class="o">|</span> <span class="n">smth_else</span> <span class="o">-&gt;</span> <span class="n">smth_else</span><span class="p">;;</span></code></pre>
</figure>

<p>It turned out to be pretty simple, right?</p>

<p>Now, let’s work out another example before our enthusiasm dies down. Let’s do insertion sort. We will write it out as two recursive functions. Wait, don’t run away. It’s going to be simple. First, let us write a function that inserts an element <code class="language-plaintext highlighter-rouge">x</code> to a list <code class="language-plaintext highlighter-rouge">lst</code>, and it will insert <code class="language-plaintext highlighter-rouge">x</code> in such a way that the element next to <code class="language-plaintext highlighter-rouge">x</code> in <code class="language-plaintext highlighter-rouge">lst</code> would be great than <code class="language-plaintext highlighter-rouge">x</code> and the element before it would be less than or equal to <code class="language-plaintext highlighter-rouge">x</code>. Why are we writing this function? This is not insertion sort. Wait, it will be clear in a minute. We will call this function <code class="language-plaintext highlighter-rouge">insert</code>, takes two arguments <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">lst</code>.</p>

<ol>
  <li>Base case - if <code class="language-plaintext highlighter-rouge">lst</code> is empty, we just insert <code class="language-plaintext highlighter-rouge">x</code> into the empty list and return it</li>
  <li>Otherwise, we have to traverse the list and see where to insert <code class="language-plaintext highlighter-rouge">x</code>. If head element is greater than <code class="language-plaintext highlighter-rouge">x</code>, it is easy - we just insert <code class="language-plaintext highlighter-rouge">x</code> at the head of the input list <code class="language-plaintext highlighter-rouge">lst</code> and return it. If not, we look for a position in the rest-of-the-list <code class="language-plaintext highlighter-rouge">t</code> to insert our <code class="language-plaintext highlighter-rouge">x</code>.</li>
</ol>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">insert</span> <span class="n">x</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">h</span><span class="p">)</span> <span class="k">then</span> <span class="n">x</span><span class="o">::</span><span class="n">h</span><span class="o">::</span><span class="n">t</span>
     <span class="k">else</span> <span class="n">h</span><span class="o">::</span><span class="p">(</span><span class="n">insert</span> <span class="n">x</span> <span class="n">t</span><span class="p">);;</span></code></pre>
</figure>

<p>Now, we will use the above function to write our insertion sort function <code class="language-plaintext highlighter-rouge">isort</code>. Just think what would happen if <code class="language-plaintext highlighter-rouge">lst</code> was already sorted in the above case. In that case, we would be inserting <code class="language-plaintext highlighter-rouge">x</code> to <code class="language-plaintext highlighter-rouge">lst</code> to maintain sorted order (just because of the rules that we imposed for inserting <code class="language-plaintext highlighter-rouge">x</code>). Let’s write down the algorithm.</p>

<ol>
  <li>Base case - if <code class="language-plaintext highlighter-rouge">lst</code> is empty, return the empty list</li>
  <li>If the list has just one element, it is trivially sorted, just return the input list</li>
  <li>If the list has two or more elements, pick elements one by one, starting from the head element <code class="language-plaintext highlighter-rouge">h</code> and use our <code class="language-plaintext highlighter-rouge">insert</code> function to insert it into the appropriate position.</li>
</ol>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">isort</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">insert</span> <span class="n">h</span> <span class="p">(</span><span class="n">isort</span> <span class="n">t</span><span class="p">)</span></code></pre>
</figure>

<p>Let’s check if it works on a simple test example:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">l1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">7</span><span class="p">;</span><span class="mi">9</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">11</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">10</span><span class="p">];;</span>
<span class="n">isort</span> <span class="n">l1</span><span class="p">;;</span>
<span class="c">(* - : int list = [1; 2; 3; 7; 9; 10; 11] *)</span></code></pre>
</figure>

<p>That’s too much for my head for today. Let’s do more interesting examples in future posts when we get into the concept of tail recursion.</p>

  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://dotkay.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>

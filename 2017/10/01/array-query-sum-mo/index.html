<!DOCTYPE html>
<html lang="en">
  <!-- Mathjax Support -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>
<script type="text/javascript" async
src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML">
</script>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Computing sub-array sum given a set of queries on sub-array indices - Mo&#39;s Algorithm</title>
  <meta name="description" content="In the previous post, we saw the naïve way of computing sub-array sums, given a set of queries. Now, following the hint provided in the previous post, let us try to think what would make it better. First, let us try to understand it with an example. If we had an inpur array a and three queries of the form {0, 3}, {4, 8} and {0, 8}, we were independently computing a[0] + a[1] + a[2] + a[3], a[4] + a[5] + a[6] + a[7] and a[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8]. Although the sub-array sums we computed for the first two queries {0, 3} and {4, 8} could have just been reused instead of computing the sum all over again. Even in the case where the third query was of the form {0, 10} we could have used the results computed for the queries {0, 3} and {4, 8}. This also means that we need to compute the queries {0, 3} and {4, 8} so that we could reuse them for {0, 8} - i.e., if we computed {0, 8} first, we already lost the advantage. Which means that we need to order our queries in such a way that we compute the queries that have the potential to be reused before computing the other queries - in the above example {0, 3} and {4, 8}. The ordering of queries themselves could be done in several ways. In this post, we shall look at one Mo’s algorithm that buckets the queries into a number of buckets which are a function of the size of the input array. If the input array is of size n, we put all the queries whose left index (L) ranges from 0 … \sqrt(n) -1 in the first bucket, (\sqrt n) … (2 * \sqrt(n) - 1), and so on. Within each bucket, we shall order the queries in increasing order of the right indices - the queries’ R values. // a, b : two Queries to be compared in order to sort bool compare(Query a, Query b) { // first, sort by L if they are in different buckets if (a.L/bucket != b.L/bucket) return a.L/bucket &amp;lt; b.L/bucket; // within the same bucket, queries are sorted // according to R values return a.R &amp;lt; b.R; } Now, we need to adjust for over-lapping ranges in the queries. For example, if the previous (already computed) query was {2, 5} and the query that is currently being worked upon is {4, 7} then we need to discount a[2] and a[3] from the already computed sum (for {2, 5}) and also add a[6] and a[7] to it. Very similarly, we may have to remove elements from the right as well (i.e. tracking the R indices). For example, if the previous range was {0, 5} and the current range {2, 3}, we need to discount a[4] and a[5] from the previous sum, as well (besides a[0] and a[1] which were taken care when we were handling L (previous paragraph)). // initialize the current L and R values int currL = 0, currR = 0; // initialize an accumulator for the sum int curr_sum = 0; // iterate over the queries for (int i=0; i&amp;lt;m; i++) { int L = q[i].L, R = q[i].R; // taking care of L // taking care of discarding // sub-parts from the sum while (currL &amp;lt; L) { curr_sum -= a[currL]; currL++; } // taking care of adding // sub-parts to the sum while (currL &amp;gt; L) { curr_sum += a[currL]; currL--; } // taking care of R // adding elements to R while (currR &amp;lt;= R) { curr_sum += a[currR]; currR++; } // discounting elements while (currR &amp;gt; R+1) { curr_sum -= a[currR - 1]; currR--; } } Let us run this on an example. Let us assume we are provided with an input array a which is { 1 2 3 1 1 2 4 1 3 4 2 1 2 3 4 1 1 3 4 2 3 2 1 2 3 } of size 25 (n) and the following 8 (m) queries (2,4) (1,7) (0,8) (5,8) (10,15) (12,16) (17,20) (18,21). Now, since n is 25, we need to put the queries with L values in the range 0 … \sqrt(n) -1 in the first bucket and so on. The first bucket, for example, would initially (arranged according to L values from 0..\sqrt(25) - 1), i.e. 0..4, will have the queries (0, 8) (2, 4) (1, 7) and then re-ordered as per their R values to (2, 4) (1, 7) (0, 8). The other buckets are second: (5,8), third: (10, 15) (12, 16), fourth: (17, 20) (18, 21). Take some time to work through it. It would be worth the time to enhance the understanding.">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dotkay.github.io/2017/10/01/array-query-sum-mo/">
  
  
  <link rel="alternate" type="application/rss+xml" title="" href="https://dotkay.github.io/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Computing sub-array sum given a set of queries on sub-array indices...">
  <meta name="twitter:description" content="In the previous post, we saw the naïve way of computing sub-array sums, given a set of queries. Now, following the hint provided in the previous post, let us try to think what would make it better....">
  
  

  
  
  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105390377-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">/assets/images/dotkay.png</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Posts</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline"><a href="https://dotkay.github.io/2017/10/01/array-query-sum-mo">Computing sub-array sum given a set of queries on sub-array indices - Mo&#39;s Algorithm &rarr;</a></h1>
    
    <p class="post-meta"><time datetime="2017-10-01T00:00:00+00:00" itemprop="datePublished">Oct 1, 2017</time> • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/c/">C++</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>In the <a href="https://dotkay.github.io/2017/09/30/array-query-sum/">previous post</a>, we saw the naïve way of computing sub-array sums, given a set of queries. Now, following the hint provided in the previous post, let us try to think what would make it better.</p>

<p>First, let us try to understand it with an example. If we had an inpur array <code class="language-plaintext highlighter-rouge">a</code> and three queries of the form <code class="language-plaintext highlighter-rouge">{0, 3}</code>, <code class="language-plaintext highlighter-rouge">{4, 8}</code> and <code class="language-plaintext highlighter-rouge">{0, 8}</code>, we were independently computing <code class="language-plaintext highlighter-rouge">a[0] + a[1] + a[2] + a[3]</code>, <code class="language-plaintext highlighter-rouge">a[4] + a[5] + a[6] + a[7]</code> and <code class="language-plaintext highlighter-rouge">a[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8]</code>. Although the sub-array sums we computed for the first two queries <code class="language-plaintext highlighter-rouge">{0, 3}</code> and <code class="language-plaintext highlighter-rouge">{4, 8}</code> could have just been reused instead of computing the sum all over again. Even in the case where the third query was of the form <code class="language-plaintext highlighter-rouge">{0, 10}</code> we could have used the results computed for the queries <code class="language-plaintext highlighter-rouge">{0, 3}</code> and <code class="language-plaintext highlighter-rouge">{4, 8}</code>. This also means that we need to compute the queries <code class="language-plaintext highlighter-rouge">{0, 3}</code> and <code class="language-plaintext highlighter-rouge">{4, 8}</code> so that we could reuse them for <code class="language-plaintext highlighter-rouge">{0, 8}</code> - i.e., if we computed <code class="language-plaintext highlighter-rouge">{0, 8}</code> first, we already lost the advantage. Which means that we need to order our queries in such a way that we compute the queries that have the potential to be reused before computing the other queries - in the above example <code class="language-plaintext highlighter-rouge">{0, 3}</code> and <code class="language-plaintext highlighter-rouge">{4, 8}</code>.</p>

<p>The ordering of queries themselves could be done in several ways. In this post, we shall look at one Mo’s algorithm that buckets the queries into a number of buckets which are a function of the size of the input array. If the input array is of size <code class="language-plaintext highlighter-rouge">n</code>, we put all the queries whose left index (<code class="language-plaintext highlighter-rouge">L</code>) ranges from 0 … \sqrt(n) -1 in the first bucket, (\sqrt n) … (2 * \sqrt(n) - 1), and so on. Within each bucket, we shall order the queries in increasing order of the right indices - the queries’ <code class="language-plaintext highlighter-rouge">R</code> values.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="c1">// a, b : two Queries to be compared in order to sort</span>
<span class="kt">bool</span> <span class="nf">compare</span><span class="p">(</span><span class="n">Query</span> <span class="n">a</span><span class="p">,</span> <span class="n">Query</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// first, sort by L if they are in different buckets</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">L</span><span class="o">/</span><span class="n">bucket</span> <span class="o">!=</span> <span class="n">b</span><span class="p">.</span><span class="n">L</span><span class="o">/</span><span class="n">bucket</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">L</span><span class="o">/</span><span class="n">bucket</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">L</span><span class="o">/</span><span class="n">bucket</span><span class="p">;</span>
  <span class="c1">// within the same bucket, queries are sorted</span>
  <span class="c1">// according to R values</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">R</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">R</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>Now, we need to adjust for over-lapping ranges in the queries. For example, if the previous (already computed) query was <code class="language-plaintext highlighter-rouge">{2, 5}</code> and the query that is currently being worked upon is <code class="language-plaintext highlighter-rouge">{4, 7}</code> then we need to discount <code class="language-plaintext highlighter-rouge">a[2]</code> and <code class="language-plaintext highlighter-rouge">a[3]</code> from the already computed sum (for <code class="language-plaintext highlighter-rouge">{2, 5}</code>) and also add <code class="language-plaintext highlighter-rouge">a[6]</code> and <code class="language-plaintext highlighter-rouge">a[7]</code> to it.</p>

<p>Very similarly, we may have to remove elements from the right as well (i.e. tracking the <code class="language-plaintext highlighter-rouge">R</code> indices). For example, if the previous range was <code class="language-plaintext highlighter-rouge">{0, 5}</code> and the current range <code class="language-plaintext highlighter-rouge">{2, 3}</code>, we need to discount <code class="language-plaintext highlighter-rouge">a[4]</code> and <code class="language-plaintext highlighter-rouge">a[5]</code> from the previous sum, as well (besides <code class="language-plaintext highlighter-rouge">a[0]</code> and <code class="language-plaintext highlighter-rouge">a[1]</code> which were taken care when we were handling L (previous paragraph)).</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="c1">// initialize the current L and R values</span>
<span class="kt">int</span> <span class="n">currL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">currR</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// initialize an accumulator for the sum</span>
<span class="kt">int</span> <span class="n">curr_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// iterate over the queries</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">L</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">L</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">R</span><span class="p">;</span>

  <span class="c1">// taking care of L</span>
  <span class="c1">// taking care of discarding</span>
  <span class="c1">// sub-parts from the sum</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">currL</span> <span class="o">&lt;</span> <span class="n">L</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">curr_sum</span> <span class="o">-=</span> <span class="n">a</span><span class="p">[</span><span class="n">currL</span><span class="p">];</span>
    <span class="n">currL</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// taking care of adding </span>
  <span class="c1">// sub-parts to the sum</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">currL</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">curr_sum</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">currL</span><span class="p">];</span>
    <span class="n">currL</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// taking care of R</span>
  <span class="c1">// adding elements to R</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">currR</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">curr_sum</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">currR</span><span class="p">];</span>
    <span class="n">currR</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// discounting elements</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">currR</span> <span class="o">&gt;</span> <span class="n">R</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">curr_sum</span> <span class="o">-=</span> <span class="n">a</span><span class="p">[</span><span class="n">currR</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="n">currR</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>Let us run this on an example. Let us assume we are provided with an input array <code class="language-plaintext highlighter-rouge">a</code> which is <code class="language-plaintext highlighter-rouge">{ 1 2 3 1 1 2 4 1 3 4 2 1 2 3 4 1 1 3 4 2 3 2 1 2 3 }</code> of size 25 (<code class="language-plaintext highlighter-rouge">n</code>) and the following 8 (<code class="language-plaintext highlighter-rouge">m</code>) queries <code class="language-plaintext highlighter-rouge">(2,4) (1,7) (0,8) (5,8) (10,15) (12,16) (17,20) (18,21)</code>. Now, since <code class="language-plaintext highlighter-rouge">n</code> is 25, we need to put the queries with L values in the range 0 … \sqrt(n) -1 in the first bucket and so on. The first bucket, for example, would initially (arranged according to L values from 0..\sqrt(25) - 1), i.e. 0..4, will have the queries <code class="language-plaintext highlighter-rouge">(0, 8) (2, 4) (1, 7)</code> and then re-ordered as per their <code class="language-plaintext highlighter-rouge">R</code> values to <code class="language-plaintext highlighter-rouge">(2, 4) (1, 7) (0, 8)</code>. The other buckets are second: <code class="language-plaintext highlighter-rouge">(5,8)</code>, third: <code class="language-plaintext highlighter-rouge">(10, 15) (12, 16)</code>, fourth: <code class="language-plaintext highlighter-rouge">(17, 20) (18, 21)</code>.</p>

<p>Take some time to work through it. It would be worth the time to enhance the understanding.</p>

  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://dotkay.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>

<!DOCTYPE html>
<html lang="en">
  <!-- Mathjax Support -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
      processEscapes: true
    }
  });
</script>
<script type="text/javascript" async
src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML">
</script>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>List Partitioning and Quicksort</title>
  <meta name="description" content="Before we try to come up with a better solution for the problem in the previous post, let us look at another familiar problem - Quicksort. A quick refresher of mergesort from one of the earlier posts will make this exercise much simpler. In mergesort, we essentially wrote a split function to split an input list into two lists and recursively called the mergesort algorithm on each of the sub-lists produced by split and eventually merged them using a merge function that merges two lists by comparing the element at the head of the sub-lists. The idea behind quicksort is similar. Instead of just splitting the list into two sub-lists, we are going to choose a pivot element (a fancy name for just an element from our input list) and split the list into two sub-lists in such a way that all the elements in the input list that are less than the pivot element would fall into one sub-list and the rest of the elements will fall into the other. Now that we are very much comfortable with writing recursive functions using accumulators, let us go ahead and write one for partitioning the list into a pair of lists (two sub-lists) given a pivot element. So, the inputs to our function are a list lst (to split) and a pivot element. let partition pivot lst = let rec aux (acc1, acc2) l = match l with | [] -&amp;gt; (acc1, acc2) | h::t -&amp;gt; if (h &amp;lt; pivot) then aux (h::acc1, acc2) t else aux (acc1, h::acc2) t in aux ([], []) lst;; Let’s go ahead and see what it does on a sample list lst1 which contains [1; 11; 9; 3; 6; 7; 2; 29]. Let’s pick 7 to be our pivot element. let lst1 = [1;11;9;3;6;7;2;29];; partition 7 lst1;; (* - : int list * int list = ([2; 6; 3; 1], [29; 7; 9; 11]) *) As we see, all the elements less than our pivot element, 7 in this case, are in one of the sub-lists generated by partition function. Now, quicksort is just choosing the head element as the pivot, generating two sub-lists l1 and l2 and calling quicksort recursively on each of the sub-lists. Since each recursive call pushes the smaller element further towards the left, eventually when all recursive calls return, the list would be sorted in acsending order. let rec quicksort lst = match lst with | [] -&amp;gt; [] | x::[] -&amp;gt; [x] | h::t -&amp;gt; let l1, l2 = partition h t in quicksort l1 @ (h::quicksort l2);; And let us try it on lst1: quicksort lst1;; (* - : int list = [1; 2; 3; 6; 7; 9; 11; 29] *) This exercise will help us find a better solution to the problem of finding the minimum missing natural number from an unsorted list. Does this ring any bell?">
  
    
    <meta name="keywords" content="algorithms,recursion,ocaml">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dotkay.github.io/2017/09/19/list-partitioning-and-quick-sort/">
  
  
  <link rel="alternate" type="application/rss+xml" title="" href="https://dotkay.github.io/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="List Partitioning and Quicksort">
  <meta name="twitter:description" content="Before we try to come up with a better solution for the problem in the previous post, let us look at another familiar problem - Quicksort. A quick refresher of mergesort from one of the earlier pos...">
  
  

  
  
  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105390377-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">
    <!-- Mathjax Support 
    <a class="site-title" href="/"></a> 
    -->
    <img src="/assets/images/dotk.png" width="40" height="30">
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Posts</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline"><a href="https://dotkay.github.io/2017/09/19/list-partitioning-and-quicksort">List Partitioning and Quicksort &rarr;</a></h1>
    
    <p class="post-meta"><time datetime="2017-09-19T00:00:00+00:00" itemprop="datePublished">Sep 19, 2017</time> • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
      <a href="/categories/ocaml/">ocaml</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Before we try to come up with a better solution for the problem in the <a href="https://dotkay.github.io/2017/09/18/minimum-missing-natural-number">previous post</a>, let us look at another familiar problem - Quicksort. A quick refresher of mergesort from one of the <a href="https://dotkay.github.io/2017/08/31/recursions-and-merge-sort">earlier posts</a> will make this exercise much simpler. In mergesort, we essentially wrote a <code class="language-plaintext highlighter-rouge">split</code> function to split an input list into two lists and recursively called the mergesort algorithm on each of the sub-lists produced by <code class="language-plaintext highlighter-rouge">split</code> and eventually merged them using a <code class="language-plaintext highlighter-rouge">merge</code> function that merges two lists by comparing the element at the head of the sub-lists.</p>

<p>The idea behind quicksort is similar. Instead of just splitting the list into two sub-lists, we are going to choose a <em>pivot</em> element (a fancy name for <em>just an element</em> from our input list) and split the list into two sub-lists in such a way that all the elements in the input list that are less than the pivot element would fall into one sub-list and the rest of the elements will fall into the other. Now that we are very much comfortable with writing recursive functions using accumulators, let us go ahead and write one for partitioning the list into a pair of lists (two sub-lists) given a pivot element. So, the inputs to our function are a list <code class="language-plaintext highlighter-rouge">lst</code> (to split) and a <code class="language-plaintext highlighter-rouge">pivot</code> element.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">partition</span> <span class="n">pivot</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">aux</span> <span class="p">(</span><span class="n">acc1</span><span class="o">,</span> <span class="n">acc2</span><span class="p">)</span> <span class="n">l</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">acc1</span><span class="o">,</span> <span class="n">acc2</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> 
      <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">)</span> <span class="k">then</span> <span class="n">aux</span> <span class="p">(</span><span class="n">h</span><span class="o">::</span><span class="n">acc1</span><span class="o">,</span> <span class="n">acc2</span><span class="p">)</span> <span class="n">t</span>
      <span class="k">else</span> <span class="n">aux</span> <span class="p">(</span><span class="n">acc1</span><span class="o">,</span> <span class="n">h</span><span class="o">::</span><span class="n">acc2</span><span class="p">)</span> <span class="n">t</span>
  <span class="k">in</span>
  <span class="n">aux</span> <span class="p">([]</span><span class="o">,</span> <span class="bp">[]</span><span class="p">)</span> <span class="n">lst</span><span class="p">;;</span></code></pre>
</figure>

<p>Let’s go ahead and see what it does on a sample list <code class="language-plaintext highlighter-rouge">lst1</code> which contains <code class="language-plaintext highlighter-rouge">[1; 11; 9; 3; 6; 7; 2; 29]</code>. Let’s pick <code class="language-plaintext highlighter-rouge">7</code> to be our pivot element.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">lst1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">11</span><span class="p">;</span><span class="mi">9</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">6</span><span class="p">;</span><span class="mi">7</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">29</span><span class="p">];;</span>
<span class="n">partition</span> <span class="mi">7</span> <span class="n">lst1</span><span class="p">;;</span>
<span class="c">(* - : int list * int list = ([2; 6; 3; 1], [29; 7; 9; 11]) *)</span></code></pre>
</figure>

<p>As we see, all the elements less than our pivot element, <code class="language-plaintext highlighter-rouge">7</code> in this case, are in one of the sub-lists generated by <code class="language-plaintext highlighter-rouge">partition</code> function.</p>

<p>Now, quicksort is just choosing the head element as the pivot, generating two sub-lists <code class="language-plaintext highlighter-rouge">l1</code> and <code class="language-plaintext highlighter-rouge">l2</code> and calling quicksort recursively on each of the sub-lists. Since each recursive call pushes the smaller element further towards the left, eventually when all recursive calls return, the list would be sorted in acsending order.</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="k">rec</span> <span class="n">quicksort</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
   <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
   <span class="o">|</span> <span class="n">x</span><span class="o">::</span><span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
   <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="k">let</span> <span class="n">l1</span><span class="o">,</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">partition</span> <span class="n">h</span> <span class="n">t</span> <span class="k">in</span>
     <span class="n">quicksort</span> <span class="n">l1</span> <span class="o">@</span> <span class="p">(</span><span class="n">h</span><span class="o">::</span><span class="n">quicksort</span> <span class="n">l2</span><span class="p">);;</span></code></pre>
</figure>

<p>And let us try it on <code class="language-plaintext highlighter-rouge">lst1</code>:</p>

<figure class="highlight">
  <pre><code class="language-ocaml" data-lang="ocaml"><span class="n">quicksort</span> <span class="n">lst1</span><span class="p">;;</span>
<span class="c">(* - : int list = [1; 2; 3; 6; 7; 9; 11; 29] *)</span></code></pre>
</figure>

<p>This exercise will help us find a better solution to the problem of finding the minimum missing natural number from an unsorted list. Does this ring any bell?</p>


  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://dotkay.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>

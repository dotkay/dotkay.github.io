<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Finding the minimum missing natural number - a better way!</title>
  <meta name="description" content="In one of the earlier posts we saw a straight forward way to find the minimum missing natural number in a list. That solution, although very straight forward, required us to sort the list before finding the minimum missing number. The question was - can we get away without that expense of sorting that list? The answer seems to be yes. Since we know that we are not allowing any duplicates and we consider only natural numbers, we can use a very nice property: In a perfectly consecutive sequence of natural numbers, any chosen number is also the number of natural numbers less than it. That is, if we consider the consecutive sequence of number 0 1 2 3 4 5 and choose 3, we see that there are exactly three natural numbers before it - 0 1 2. A curious mind would have noted that these three numbers actually need not be in order - they should just exist. For example 1 0 2 3 4 5 has three numbers before 3, they are not in sequence, but the fact that there are three of them assures us that nothing less than three is missing in the sequence. This is the property we are going to use to come up with a simpler search. Just like how we partitioned a list of numbers around a pivot element for quicksort, we will choose an element x and push all the numbers less than it (in any order) to the left of it and the rest to the right of it. We will also need to keep track of the number of elements num to the left of the chosen number (in order to check our fancy property mentioned above). Let’s write the partition function first: let partition x lst = let aux (num, left, right) y = if (y &amp;lt; x) then num+1, y::left, right else num, left, y::right in List.fold_left aux (0, [], []) lst;; If the number of elements tracked is equal to the chosen number, it just means that there is no missing number in the left partition (just like the example above where the number of elements less than 3 is equal to three, and we don’t have any missing natural number to the left of 3). Now, we will use this partition function to find the missing natural number: let min_missing_num lst = (* m is the least nat number - 0 *) let rec find_min m l = match l with | [] -&amp;gt; m (* we return 0 as the missing num *) (* as it is the least nat num *) | h::t -&amp;gt; let (num, left, right) = partition h t in (* if (num = h) left side is perfect *) (* search on the right partition *) if (num + m = h) then find_min (h+1) right else find_min m left in find_min 0 lst;; Think of m as the accumulator - we know that 0 is the first natural number, so in case our input list is an empty one (base case), we just return the first (minimum) natural number that is missing. Is there too much going on in this? If you could work this out in a sample input, say [0; 3; 2; 9; 1] it would help understand it better.">
  
    
    <meta name="keywords" content="recursion,ocaml">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dotkay.github.io/2017/09/20/minimum-missing-nat-number-2/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Quotidien" href="https://dotkay.github.io/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Finding the minimum missing natural number - a better way!">
  <meta name="twitter:description" content="In one of the earlier posts we saw a straight forward way to find the minimum missing natural number in a list. That solution, although very straight forward, required us to sort the list before fi...">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105390377-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Quotidien</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Posts</a>
      
        
        <a class="page-link" href="https://github.com/dotkay">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline"><a href="https://dotkay.github.io/2017/09/20/minimum-missing-nat-number-2">Finding the minimum missing natural number - a better way! &rarr;</a></h1>
    
    <p class="post-meta"><time datetime="2017-09-20T00:00:00+00:00" itemprop="datePublished">Sep 20, 2017</time> • 
  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
      <a href="/categories/ocaml/">ocaml</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>In one of the <a href="https://dotkay.github.io/2017/09/18/minimum-missing-natural-number">earlier posts</a> we saw a straight forward way to find the minimum missing natural number in a list. That solution, although very straight forward, required us to sort the list before finding the minimum missing number. The question was - can we get away without that expense of sorting that list?</p>

<p>The answer seems to be <em>yes</em>. Since we know that we are not allowing any duplicates and we consider only natural numbers, we can use a very nice property:</p>

<blockquote>
  <p>In a perfectly consecutive sequence of natural numbers, any chosen number is also the number of natural numbers less than it.</p>
</blockquote>

<p>That is, if we consider the consecutive sequence of number <code class="highlighter-rouge">0 1 2 3 4 5</code> and choose <code class="highlighter-rouge">3</code>, we see that there are exactly three natural numbers before it - <code class="highlighter-rouge">0 1 2</code>. A curious mind would have noted that these three numbers actually need not be in order - they should just exist. For example <code class="highlighter-rouge">1 0 2 3 4 5</code> has three numbers before <code class="highlighter-rouge">3</code>, they are not in sequence, but the fact that there are three of them assures us that nothing less than three is missing in the sequence. This is the property we are going to use to come up with a simpler search. Just like how we <a href="https://dotkay.github.io/2017/09/19/list-partitioning-and-quicksort">partitioned a list of numbers around a pivot element for quicksort</a>, we will choose an element <code class="highlighter-rouge">x</code> and push all the numbers less than it (in any order) to the left of it and the rest to the right of it. We will also need to keep track of the number of elements <code class="highlighter-rouge">num</code> to the left of the chosen number (in order to check our fancy property mentioned above). Let’s write the partition function first:</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">partition</span> <span class="n">x</span> <span class="n">lst</span> <span class="p">=</span> 
  <span class="k">let</span> <span class="n">aux</span> <span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="n">y</span> <span class="p">=</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="p">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="k">then</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">::</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span>
    <span class="k">else</span> <span class="n">num</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">y</span><span class="p">::</span><span class="n">right</span>
  <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="n">aux</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">[]</span><span class="p">,</span> <span class="bp">[]</span><span class="p">)</span> <span class="n">lst</span><span class="p">;;</span></code></pre></figure>

<p>If the number of elements tracked is equal to the chosen number, it just means that there is no missing number in the left partition (just like the example above where the number of elements less than <code class="highlighter-rouge">3</code> is equal to three, and we don’t have any missing natural number to the left of <code class="highlighter-rouge">3</code>). Now, we will use this partition function to find the missing natural number:</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="k">let</span> <span class="n">min_missing_num</span> <span class="n">lst</span> <span class="p">=</span>
  <span class="c">(* m is the least nat number - 0 *)</span> 
  <span class="k">let</span> <span class="k">rec</span> <span class="n">find_min</span> <span class="n">m</span> <span class="n">l</span> <span class="p">=</span> 
    <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
    <span class="p">|</span> <span class="bp">[]</span> <span class="p">-&gt;</span> <span class="n">m</span>  <span class="c">(* we return 0 as the missing num *)</span>
               <span class="c">(* as it is the least nat num *)</span>
    <span class="p">|</span> <span class="n">h</span><span class="p">::</span><span class="n">t</span> <span class="p">-&gt;</span> 
      <span class="k">let</span> <span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="p">=</span> <span class="n">partition</span> <span class="n">h</span> <span class="n">t</span> <span class="k">in</span>
      <span class="c">(* if (num = h) left side is perfect *)</span>
      <span class="c">(* search on the right partition *)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">+</span> <span class="n">m</span> <span class="p">=</span> <span class="n">h</span><span class="p">)</span> <span class="k">then</span> <span class="n">find_min</span> <span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">right</span>
      <span class="k">else</span> <span class="n">find_min</span> <span class="n">m</span> <span class="n">left</span>
    <span class="k">in</span>
    <span class="n">find_min</span> <span class="mi">0</span> <span class="n">lst</span><span class="p">;;</span></code></pre></figure>

<p>Think of <code class="highlighter-rouge">m</code> as the accumulator - we know that <code class="highlighter-rouge">0</code> is the first natural number, so in case our input list is an empty one (base case), we just return the first (minimum) natural number that is missing. Is there too much going on in this? If you could work this out in a sample input, say <code class="highlighter-rouge">[0; 3; 2; 9; 1]</code> it would help understand it better.</p>

  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://dotkay.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>

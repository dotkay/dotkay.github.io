<!DOCTYPE html>
<html lang="en">
  <!-- Mathjax Support -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>
<script type="text/javascript" async
src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML">
</script>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Counting the number of rotations of a sorted array</title>
  <meta name="description" content="Let’s look at another simple, interesting problem: Given a sorted array, with no duplicates, that has been rotated (also called circularly sorted array), find out the number of times it has been rotated For example, [2 3 5 8 11 12] is a sorted list of numbers and if we rotate it twice, we end up in [11 12 2 3 5 8]. We are required to find the number of times it has been sorted, looking at this list. The straight forward way is to look for the minimum element of the array and the index of the mimimum element gives us the number of times it has been rotated. In this case 2 is the minimum element and the index of the mimumum element is 2 (indices start at 0 in most of the languages we use here). The time complexity would be O(n) as we need to traverse the array looking for the mimimum element. Can we do better? Can we use a nice property of circularly sorted arrays (lists)? For the element we are looking for, call it the pivot element, both the left and right neighbours are greater than the pivot element. This is the only element in a circularly sorted array with this property. So, our goal is to find the pivot element. We already know that the array has been sorted - so we can use binary search to look for the pivot element. We compute the middle element of the array, call it mid and search in the left and right halves of the middle element. Let’s call the lower index low and higher index high for the purposes of computation. So, we compute the middle element as mid = (high - low) / 2. The neighbours of this middle element, called prev and next are computed as prev = (mid + 1) % n where n is the size of the array (since it is circularly sorted we need to wrap around and hence we do this modulo n operation) and next = (mid + n -1) % n. Now, if mid turns out to be our pivot element, i.e. we check for pivot property, we are done - we just return mid as the result. Otherwise, we keep moving low and high to decide which half of the array we want to search for the pivot element. Recollect that we know the array is (circularly) sorted and this makes our job easier. For example, if the element at mid is less than the one at high we can deduce that the right half of the array is sorted, and so we adjust high to be mid - 1 (i.e. make left half our focus of pivot element search). int rotation_count(int A[], int n) { int low = 0; int high = n-1; int mid = (high - low) / 2; int next, prev; while (low &amp;lt;= high) { if (A[low] &amp;lt;= A[high]) return low; next = (mid + 1) % n; prev = (mid + n - 1) % n; // check pivot element property! if (A[mid] &amp;lt;= A[next] &amp;amp;&amp;amp; A[mid] &amp;lt;= A[prev]) return mid; else if (A[mid] &amp;lt;= A[high]) high = mid - 1; else if (A[mid] &amp;gt;= A[low]) low = mid + 1; } } Isn’t it interesting? That’s all for now!">
  
    
    <meta name="keywords" content="algorithms,C++">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dotkay.github.io/2017/09/03/counting-rotations/">
  
  
  <link rel="alternate" type="application/rss+xml" title="" href="https://dotkay.github.io/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Counting the number of rotations of a sorted array">
  <meta name="twitter:description" content="Let’s look at another simple, interesting problem: Given a sorted array, with no duplicates, that has been rotated (also called circularly sorted array), find out the number of times it has been ro...">
  
  

  
  
  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105390377-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">
    <!-- Mathjax Support 
    <a class="site-title" href="/"></a> 
    -->
    <img src="/assets/images/dotk.png" width="50" height="30">
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Posts</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline"><a href="https://dotkay.github.io/2017/09/03/counting-rotations">Counting the number of rotations of a sorted array &rarr;</a></h1>
    
    <p class="post-meta"><time datetime="2017-09-03T00:00:00+00:00" itemprop="datePublished">Sep 3, 2017</time> • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/c/">C++</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Let’s look at another simple, interesting problem:</p>

<p><em>Given a sorted array, with no duplicates, that has been rotated (also called circularly sorted array), find out the number of times it has been rotated</em></p>

<p>For example, <code class="language-plaintext highlighter-rouge">[2 3 5 8 11 12]</code> is a sorted list of numbers and if we rotate it twice, we end up in <code class="language-plaintext highlighter-rouge">[11 12 2 3 5 8]</code>. We are required to find the number of times it has been sorted, looking at this list. The straight forward way is to look for the minimum element of the array and the index of the mimimum element gives us the number of times it has been rotated. In this case <code class="language-plaintext highlighter-rouge">2</code> is the minimum element and the index of the mimumum element is <code class="language-plaintext highlighter-rouge">2</code> (indices start at <code class="language-plaintext highlighter-rouge">0</code> in most of the languages we use here). The time complexity would be O(n) as we need to traverse the array looking for the mimimum element.</p>

<p>Can we do better? Can we use a nice property of circularly sorted arrays (lists)?</p>

<blockquote>
  <p>For the element we are looking for, call it the pivot element, both the left and right neighbours are greater than the pivot element. This is the only element in a circularly sorted array with this property.</p>
</blockquote>

<p>So, our goal is to find the pivot element. We already know that the array has been sorted - so we can use binary search to look for the pivot element. We compute the middle element of the array, call it <code class="language-plaintext highlighter-rouge">mid</code> and search in the left and right halves of the middle element. Let’s call the lower index <code class="language-plaintext highlighter-rouge">low</code> and higher index <code class="language-plaintext highlighter-rouge">high</code> for the purposes of computation. So, we compute the middle element as <code class="language-plaintext highlighter-rouge">mid = (high - low) / 2</code>. The neighbours of this middle element, called <code class="language-plaintext highlighter-rouge">prev</code> and <code class="language-plaintext highlighter-rouge">next</code> are computed as <code class="language-plaintext highlighter-rouge">prev = (mid + 1) % n</code> where <code class="language-plaintext highlighter-rouge">n</code> is the size of the array (since it is circularly sorted we need to wrap around and hence we do this <code class="language-plaintext highlighter-rouge">modulo n</code> operation) and <code class="language-plaintext highlighter-rouge">next = (mid + n -1) % n</code>. Now, if <code class="language-plaintext highlighter-rouge">mid</code> turns out to be our pivot element, i.e. we check for pivot property, we are done - we just return <code class="language-plaintext highlighter-rouge">mid</code> as the result. Otherwise, we keep moving <code class="language-plaintext highlighter-rouge">low</code> and <code class="language-plaintext highlighter-rouge">high</code> to decide which half of the array we want to search for the pivot element. Recollect that we know the array is (circularly) sorted and this makes our job easier. For example, if the element at <code class="language-plaintext highlighter-rouge">mid</code> is less than the one at <code class="language-plaintext highlighter-rouge">high</code> we can deduce that the right half of the array is sorted, and so we adjust <code class="language-plaintext highlighter-rouge">high</code> to be <code class="language-plaintext highlighter-rouge">mid - 1</code> (i.e. make left half our focus of pivot element search).</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">rotation_count</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">next</span><span class="p">,</span> <span class="n">prev</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">low</span><span class="p">;</span>
    <span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
    <span class="c1">// check pivot element property!</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="p">[</span><span class="n">prev</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="p">])</span>
        <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">])</span>
        <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>Isn’t it interesting? That’s all for now!</p>

  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://dotkay.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>

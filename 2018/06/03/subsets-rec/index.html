<!DOCTYPE html>
<html lang="en">
  <!-- Mathjax Support -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>
<script type="text/javascript" async
src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML">
</script>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Computing subsets of a set</title>
  <meta name="description" content="Let us try and compute all subsets of a given set of integers. Let us try a recursive solution in this post. We will also see how to implement it in a more efficient manner in a later post. Suppose that the user is given the set of elements as a vector of integers and to further simplify, let us assume that there are no duplicates in the input set (and that’s why we call it a set). We want to return the set of all possible subsets that can be formed - a vector of vectors. At this point, we have some idea of what data-type we could use. If you are programming in C++, one could straight away use a std::vector. If you are using Python or some other functional language, you could use a list. Let’s think recursively now. What would be the base condition? That is we are given an empty set as input. We just return. That was simple. Now, if we had just one element in our input set, what would be our result? The result would have a set containing the one element, and an empty set (as empty set is a valid subset of any set). This already gives us an operational hint - may be, we can start with an empty result set to begin with and traverse the given input set and add elements from it to our result set. In this simple case, let us suppose that the input set is just [1]. Here’s how we would proceed [] - empty result set [] [1] - adding the one element from our input set Let’s keep going. What happens when there are two elements in our input set? Say, [1 2]? As we saw above, we will start with an empty result set []. We can traverse the input set and pick and add more elements from it to our result set, until we exhaust the input set: [] - empty result set [] [1] - adding the first element [] [1] [1 2] - adding the second element At this point, we have exhausted the input set. But we have not captured [2] as a part of our solution yet. What do we need to do in order to capture that? Just like how we added the first element 1 to our initial empty set, we should add only the second element 2 to our initial input set. In order words, we backtrack to the state (since we are going to be writing a recursive algorithm, this would correspond to popping from the recursion stack) where we had only the empty set, and add the second element. The entire sequence of operations would now appear like: [] - empty result set [] [1] - adding the first element [] [1] [1 2] - adding the second element - ** backtrack ** [] [1] [1 2] [2] - adding only the second element We can keep going. Note that when we have three elements [1 2 3], we will need to backtrack to the state where our result had [1] and add 3 to it yielding [1 3] and later on (when? when we exhaust the rest of the input list) backtrack to the state where our result had [] and add 2, and similarly 3 to the empty result set. I would leave it as an exercise to work out the steps as we did above. We see there are three major operations: insert the intermediate result set to our result set of sets (like how we added empty set in the left most column above traverse the input set starting from the index pointing to the first element, picking elements one by one and adding it to our intermediate result set, until we exhaust all the elements in our input set backtrack (corresponding to moving the index to point to the second element) and pick and add elements one by one as in step 2. Let’s write it in C++ language. void all_subsets_rec(std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; result, std::vector&amp;lt;int&amp;gt;&amp;amp; int_result, std::vector&amp;lt;int&amp;gt; input_set, int start_index) { int input_size = input_set.size(); // base case if (input_size == 0) return; // populate result set of sets result.push_back(int_result); // traverse for (int i = start_index; i &amp;lt; input_size; i++) { // populate intermediate result int_result.push_back(input_set[i]); // recurse find_all_subsets(result, int_result, input_set, i+1); // backtrack int_result.pop_back(); } } and the above recursive function is called in the driver program as: std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; result; std::vector&amp;lt;int&amp;gt; int_result; all_subsets_rec(result, int_result, input_set, 0); At the face of it, it looks like a very simple problem and it is. But this is one of those problems which is very easy to get it wrong. Many things could go wrong here - you could overflow some bounds, add the same element twice or more times to the result array and so on.">
  
    
    <meta name="keywords" content="recursion,algorithms,C++,power set">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dotkay.github.io/2018/06/03/subsets-rec/">
  
  
  <link rel="alternate" type="application/rss+xml" title="" href="https://dotkay.github.io/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Computing subsets of a set">
  <meta name="twitter:description" content="Let us try and compute all subsets of a given set of integers. Let us try a recursive solution in this post. We will also see how to implement it in a more efficient manner in a later post. Suppose...">
  
  

  
  
  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105390377-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">
    <!-- Mathjax Support 
    <a class="site-title" href="/"></a> 
    -->
    <img src="/assets/images/dotk.png" width="60" height="40">
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Posts</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline"><a href="https://dotkay.github.io/2018/06/03/subsets-rec">Computing subsets of a set &rarr;</a></h1>
    
    <p class="post-meta"><time datetime="2018-06-03T00:00:00+00:00" itemprop="datePublished">Jun 3, 2018</time> • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
      <a href="/categories/recursion/">recursion</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/c/">C++</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/power-set/">power set</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Let us try and compute all subsets of a given set of integers.</p>

<p>Let us try a recursive solution in this post. We will also see how to implement it in a more efficient manner in a later post. Suppose that the user is given the set of elements as a vector of integers and to further simplify, let us assume that there are no duplicates in the input set (and that’s why we call it a set). We want to return the set of all possible subsets that can be formed - a  vector of vectors. At this point, we have some idea of what data-type we could use. If you are programming in C++, one could straight away use a <code class="language-plaintext highlighter-rouge">std::vector</code>. If you are using Python or some other functional language, you could use a list.</p>

<p>Let’s think recursively now. What would be the base condition? That is we are given an empty set as input. We just return. That was simple.</p>

<p>Now, if we had just one element in our input set, what would be our result? The result would have a set containing the one element, and an empty set (as empty set is a valid subset of any set). This already gives us an operational hint - may be, we can start with an empty result set to begin with and traverse the given input set and add elements from it to our result set. In this simple case, let us suppose that the input set is just <code class="language-plaintext highlighter-rouge">[1]</code>. Here’s how we would proceed</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[]        - empty result set
[] [1]    - adding the one element from our input set
</code></pre></div></div>

<p>Let’s keep going. What happens when there are two elements in our input set? Say, <code class="language-plaintext highlighter-rouge">[1 2]</code>? As we saw above, we will start with an empty result set <code class="language-plaintext highlighter-rouge">[]</code>. We can traverse the input set and pick and add more elements from it to our result set, until we exhaust the input set:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[]              - empty result set
[] [1]          - adding the first element
[] [1] [1 2]    - adding the second element
</code></pre></div></div>

<p>At this point, we have exhausted the input set. But we have not captured <code class="language-plaintext highlighter-rouge">[2]</code> as a part of our solution yet. What do we need to do in order to capture that? Just like how we added the first element <code class="language-plaintext highlighter-rouge">1</code> to our initial empty set, we should add only the second element <code class="language-plaintext highlighter-rouge">2</code> to our initial input set. In order words, we backtrack to the state (since we are going to be writing a recursive algorithm, this would correspond to popping from the recursion stack) where we had only the empty set, and add the second element. The entire sequence of operations would now appear like:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[]                - empty result set
[] [1]            - adding the first element
[] [1] [1 2]      - adding the second element
                  - ** backtrack **
[] [1] [1 2] [2]  - adding only the second element
</code></pre></div></div>

<p>We can keep going. Note that when we have three elements <code class="language-plaintext highlighter-rouge">[1 2 3]</code>, we will need to backtrack to the state where our result had <code class="language-plaintext highlighter-rouge">[1]</code> and add <code class="language-plaintext highlighter-rouge">3</code> to it yielding <code class="language-plaintext highlighter-rouge">[1 3]</code> and later on (when? when we exhaust the rest of the input list) backtrack to the state where our result had <code class="language-plaintext highlighter-rouge">[]</code> and add <code class="language-plaintext highlighter-rouge">2</code>, and similarly <code class="language-plaintext highlighter-rouge">3</code> to the empty result set. I would leave it as an exercise to work out the steps as we did above.</p>

<p>We see there are three major operations:</p>

<ol>
  <li>insert the intermediate result set to our result set of sets (like how we added empty set in the left most column above</li>
  <li>traverse the input set starting from the index pointing to the first element, picking elements one by one and adding it to our intermediate result set, until we exhaust all the elements in our input set</li>
  <li>backtrack (corresponding to moving the index to point to the second element) and pick and add elements one by one as in step 2.</li>
</ol>

<p>Let’s write it in C++ language.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">all_subsets_rec</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">result</span><span class="p">,</span>
                     <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">int_result</span><span class="p">,</span>
                     <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">input_set</span><span class="p">,</span>
                     <span class="kt">int</span> <span class="n">start_index</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">input_size</span> <span class="o">=</span> <span class="n">input_set</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="c1">// base case</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">input_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>
  
  <span class="c1">// populate result set of sets</span>
  <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">int_result</span><span class="p">);</span>

  <span class="c1">// traverse</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start_index</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">input_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// populate intermediate result</span>
    <span class="n">int_result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">input_set</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="c1">// recurse</span>
    <span class="n">find_all_subsets</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">int_result</span><span class="p">,</span> <span class="n">input_set</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// backtrack</span>
    <span class="n">int_result</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>
</figure>

<p>and the above recursive function is called in the driver program as:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_result</span><span class="p">;</span>
<span class="n">all_subsets_rec</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">int_result</span><span class="p">,</span> <span class="n">input_set</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></code></pre>
</figure>

<p>At the face of it, it looks like a very simple problem and it is. But this is one of those problems which is very easy to get it wrong. Many things could go wrong here - you could overflow some bounds, add the same element twice or more times to the result array and so on.</p>


  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://dotkay.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>

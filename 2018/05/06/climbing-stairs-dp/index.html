<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Climbing stairs and remembering the past...</title>
  <meta name="description" content="Those who cannot remember the past are condemned to repeat it! In our previous post we saw a recursive algorithm to compute the number of ways one can climb a fleet of n steps. If you draw the recursion tree for such an algorithm, we would soon find that we are computing some of the sub-problems repeatedly. We can do better by remembering (i.e. storing in some data structure) what we computed so that we can retrieve it and reuse it when needed again. Or in other fancy computer science parlance, we can use dynamic programming technique to solve such recursive problems more efficiently. Here is the recursion tree for a hypothetical problem, similar to climbing stairs from our previous post where each function call for an input parameter value n leads to two calls for values n-1 and n-2. We can readily see, even in this very small example, that the all the function calls in the sub-tree rooted at 2 is computed again unnecessarily. One of the main ideas in dynamic programming is to store such computations so that we can reuse them when needed again. Let us try to use dynamic programming and rewrite our algorithm for computing the number of ways of climbing n steps. We shall use a simple array (a C++ vector) to store intermediate computations. More concretely, we will store the number of ways of climbing 1 step, the number of ways of climbing 2 steps, and so on. So, our array ways stores the number of ways - ways[i] gives us the number of ways of climbing i steps. As we saw in our previous post, the algorithm just needs to compute ways[i-1] + ways[i-2] for different values of i upto n and finally return ways[n] as the result. int stairs(int n) { std::vector&amp;lt;int&amp;gt; ways(n+1); // base case if (n &amp;lt;= 1) return 1; ways[0] = 1; ways[1] = 1; for (int i = 2; i &amp;lt;= n; i++) ways[i] = ways[i-1] + ways[i-2]; return ways[n]; } An astute reader would start thinking how this is different from divide-and-conquer approaches for solving recursive problems. I will let you think about it for now and find out for yourself what technique is beneficial for what specific structure of the recursive problem - that was already a hint there!">
  
    
    <meta name="keywords" content="dynamic programming,algorithms,C++">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dotkay.github.io/2018/05/06/climbing-stairs-dp/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Quotidien" href="https://dotkay.github.io/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Climbing stairs and remembering the past...">
  <meta name="twitter:description" content="Those who cannot remember the past are condemned to repeat it! In our previous post we saw a recursive algorithm to compute the number of ways one can climb a fleet of n steps. If you draw the recu...">
  
  

  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105390377-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Quotidien</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Posts</a>
      
        
        <a class="page-link" href="https://github.com/dotkay">GitHub</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline"><a href="https://dotkay.github.io/2018/05/06/climbing-stairs-dp">Climbing stairs and remembering the past... &rarr;</a></h1>
    
    <p class="post-meta"><time datetime="2018-05-06T00:00:00+00:00" itemprop="datePublished">May 6, 2018</time> â€¢ 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/dynamic-programming/">dynamic programming</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/c/">C++</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <blockquote>
  <p>Those who cannot remember the past are condemned to repeat it!</p>
</blockquote>

<p>In our <a href="https://dotkay.github.io/2018/05/05/climbing-stairs-recursively">previous post</a> we saw a recursive algorithm to compute the number of ways one can climb a fleet of <em>n</em> steps. If you draw the recursion tree for such an algorithm, we would soon find that we are computing some of the sub-problems repeatedly. We can do better by remembering (i.e. storing in some data structure) what we computed so that we can retrieve it and reuse it when needed again. Or in other fancy computer science parlance, we can use <em>dynamic programming</em> technique to solve such recursive problems more efficiently.</p>

<p>Here is the recursion tree for a hypothetical problem, similar to climbing stairs from our <a href="https://dotkay.github.io/2018/05/05/climbing-stairs-recursively">previous post</a> where each function call for an input parameter value <em>n</em> leads to two calls for values <em>n-1</em> and <em>n-2</em>. We can readily see, even in this very small example, that the all the function calls in the sub-tree rooted at <em>2</em> is computed again unnecessarily. One of the main ideas in dynamic programming is to store such computations so that we can reuse them when needed again.</p>

<p><br />
<img src="/assets/images/algorithms/cpp/rec_tree.jpg" alt="recursion tree" class="img=responsive" /></p>

<p>Let us try to use dynamic programming and rewrite our algorithm for computing the number of ways of climbing <em>n</em> steps. We shall use a simple array (a C++ vector) to store intermediate computations. More concretely, we will store the number of ways of climbing 1 step, the number of ways of climbing 2 steps, and so on. So, our array <code class="highlighter-rouge">ways</code> stores the number of ways - <code class="highlighter-rouge">ways[i]</code> gives us the number of ways of climbing <code class="highlighter-rouge">i</code> steps. As we saw in our previous post, the algorithm just needs to compute <code class="highlighter-rouge">ways[i-1] + ways[i-2]</code> for different values of <code class="highlighter-rouge">i</code> upto <code class="highlighter-rouge">n</code> and finally return <code class="highlighter-rouge">ways[n]</code> as the result.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">stairs</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ways</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">// base case</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

  <span class="n">ways</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">ways</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">ways</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ways</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ways</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">];</span>

  <span class="k">return</span> <span class="n">ways</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span></code></pre>
</figure>

<p>An astute reader would start thinking how this is different from divide-and-conquer approaches for solving recursive problems. I will let you think about it for now and find out for yourself what  technique is beneficial for what specific structure of the recursive problem - that was already a hint there!</p>

  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://dotkay.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>

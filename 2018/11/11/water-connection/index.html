<!DOCTYPE html>
<html lang="en">
  <!-- Mathjax Support -->
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Cost-efficient Water Connections</title>
  <meta name="description" content="Suppose you are the tech-savvy engineer recruited by Public Works Department in your rural county. The rural county has wonderful flora, fauna and a few environmentalists and ecologists have been recruited to take care of the environment. There are a few houses built to host these people. Since the settlement is very new, the county has asked you to design a efficient water connection map to bring water to these settlements from a water source at one corner of the area. There are known paths where these water pipelines could be laid in a way that will have minimal effect on the environment. And you have been entrusted with using some of these paths in such a way as to minimise the cost and at the same time make sure every house gets a water connection. You sit down and think that the map is nothing but an implicit graph, the cost of laying the pipelines being the weights on the graph’s edges. The vertices are the houses. You have one special vertex which is the community’s source of water. Your plan is to find the path from the source of water to every house in the community. Further, there might be several such paths and you would have to choose the one that has the lowest cost. You recall algorithms for minimum spanning trees that you had learned in your algorithms lessons a decade ago and decide to give it a go. Algorithmically, you have a set of edges with weights, a set of vertices and a special start vertex. Suppose each edge is defined by a source vertex src, a destination vertex dest and the associated cost of laying the pipe between these vertices cost - represented by the following structure: struct Edge { int src; int dest; int cost; }; And our graph is defined by the total set of vertices V (one source of water + the nodes representing houses) and a vector of Edges EdgeList each element is an Edge as defined above. Graph(int V, std::vector&amp;lt;Edge&amp;gt; edges) Assume that we also have a UnionFind data structure for us to use. Since we have to minimize the cost of construction, we try a greedy approach by picking the least expensive pipelines first - i.e., we sort edges in increasing order of cost. std::sort(EdgeList.begin(), EdgeList.end(), [](Edge e1, Edge e2) { return e1.cost &amp;lt; e2.cost; }); Once we pick the least cost edge, the next least cost edge may not be a neighbour of the current edge (i.e. having a common src or dest vertex). In order to prevent cycles, we maintain a UnionFind data structure and keep adding the (minimum cost) edges we choose. As we collect the minimum cost edges, we can compute the cost using an accumulator. int Graph::kruskal_mst() { int V = size; UnionFind uf(V); std::sort(EdgeList.begin(), EdgeList.end(), [](Edge e1, Edge e2) { return e1.cost &amp;lt; e2.cost; }); int mst_cost = 0; int n = EdgeList.size(); for (int i = 0; i &amp;lt; n; i++) { Edge e = EdgeList[i]; // min cost edge if (!uf.isSameSet(e.src, e.dest)) { mst_cost += e.cost; uf.formUnion(e.src, e.dest); } } return mst_cost; } Finally, we will end up with the following minimum cost spanning tree, with pipelines laid with a total cost of $990000.">
  
    
    <meta name="keywords" content="C++, algorithms, greedy, Kruskal, minimum spanning tree">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://dotkay.github.io/2018/11/11/water-connection/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Quotidien" href="https://dotkay.github.io/feed.xml">

  

  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="Cost-efficient Water Connections">
  <meta name="twitter:description" content="Suppose you are the tech-savvy engineer recruited by Public Works Department in your rural county. The rural county has wonderful flora, fauna and a few environmentalists and ecologists have been r...">
  
  

  
  
  <script type="text/javascript">
  WebFontConfig = {
    google: { families: [ 'Bitter:400,700,400italic:latin' ] }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105390377-1', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Quotidien</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/archives/">Posts</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline"><a href="https://dotkay.github.io/2018/11/11/water-connection">Cost-efficient Water Connections &rarr;</a></h1>
    
    <p class="post-meta"><time datetime="2018-11-11T00:00:00+00:00" itemprop="datePublished">Nov 11, 2018</time> • 
  
  
    
  
    
  
    
  
    
      <a href="/categories/algorithms/">algorithms</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/c/">C++</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/greedy/">greedy</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/kruskal/">Kruskal</a>,
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

  
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      <a href="/categories/minimum-spanning-tree/">Minimum Spanning Tree</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  

</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Suppose you are the tech-savvy engineer recruited by Public Works Department in your rural county. The rural county has wonderful flora, fauna and a few environmentalists and ecologists have been recruited to take care of the environment. There are a few houses built to host these people. Since the settlement is very new, the county has asked you to design a efficient water connection map to bring water to these settlements from a water source at one corner of the area. There are known paths where these water pipelines could be laid in a way that will have minimal effect on the environment. And you have been entrusted with using some of these paths in such a way as to minimise the cost and at the same time make sure every house gets a water connection.</p>

<p><br /></p>
<div class="img_container">
  <center><img src="https://raw.githubusercontent.com/dotkay/tmp/main/algo_illustrations/kruskal_mst_1.PNG" /></center>
</div>
<p><br /></p>

<p>You sit down and think that the map is nothing but an implicit graph, the cost of laying the pipelines being the weights on the graph’s edges. The vertices are the houses. You have one special vertex which is the community’s source of water. Your plan is to find the path from the source of water to every house in the community. Further, there might be several such paths and you would have to choose the one that has the lowest cost. You recall algorithms for minimum spanning trees that you had learned in your algorithms lessons a decade ago and decide to give it a go.</p>

<p>Algorithmically, you have a set of edges with weights, a set of vertices and a special start vertex. Suppose each edge is defined by a source vertex <code class="language-plaintext highlighter-rouge">src</code>, a destination vertex <code class="language-plaintext highlighter-rouge">dest</code> and the associated cost of laying the pipe between these vertices <code class="language-plaintext highlighter-rouge">cost</code> - represented by the following structure:</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">Edge</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">src</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">dest</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">cost</span><span class="p">;</span>
<span class="p">};</span></code></pre>
</figure>

<p>And our graph is defined by the total set of vertices <code class="language-plaintext highlighter-rouge">V</code> (one source of water + the nodes representing houses) and a vector of Edges <code class="language-plaintext highlighter-rouge">EdgeList</code> each element is an Edge as defined above.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">Graph</span><span class="p">(</span><span class="kt">int</span> <span class="n">V</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">edges</span><span class="p">)</span></code></pre>
</figure>

<p>Assume that we also have a UnionFind data structure for us to use. Since we have to minimize the cost of construction, we try a greedy approach by picking the least expensive pipelines first - i.e., we sort <code class="language-plaintext highlighter-rouge">edges</code> in increasing order of <code class="language-plaintext highlighter-rouge">cost</code>.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">EdgeList</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">EdgeList</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> 
          <span class="p">[](</span><span class="n">Edge</span> <span class="n">e1</span><span class="p">,</span> <span class="n">Edge</span> <span class="n">e2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">e1</span><span class="p">.</span><span class="n">cost</span> <span class="o">&lt;</span> <span class="n">e2</span><span class="p">.</span><span class="n">cost</span><span class="p">;</span> <span class="p">});</span></code></pre>
</figure>

<p>Once we pick the least cost edge, the next least cost edge may not be a neighbour of the current edge (i.e. having a common <code class="language-plaintext highlighter-rouge">src</code> or <code class="language-plaintext highlighter-rouge">dest</code> vertex). In order to prevent cycles, we maintain a UnionFind data structure and keep adding the (minimum cost) edges we choose. As we collect the minimum cost edges, we can compute the cost using an accumulator.</p>

<figure class="highlight">
  <pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">Graph</span><span class="o">::</span><span class="n">kruskal_mst</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">V</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
  <span class="n">UnionFind</span> <span class="n">uf</span><span class="p">(</span><span class="n">V</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">EdgeList</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">EdgeList</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> 
            <span class="p">[](</span><span class="n">Edge</span> <span class="n">e1</span><span class="p">,</span> <span class="n">Edge</span> <span class="n">e2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">e1</span><span class="p">.</span><span class="n">cost</span> <span class="o">&lt;</span> <span class="n">e2</span><span class="p">.</span><span class="n">cost</span><span class="p">;</span> <span class="p">});</span>
  <span class="kt">int</span> <span class="n">mst_cost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">EdgeList</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Edge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">EdgeList</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// min cost edge</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uf</span><span class="p">.</span><span class="n">isSameSet</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">dest</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">mst_cost</span> <span class="o">+=</span> <span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">;</span>
      <span class="n">uf</span><span class="p">.</span><span class="n">formUnion</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">dest</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">mst_cost</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</figure>

<p>Finally, we will end up with the following minimum cost spanning tree, with pipelines laid with a total cost of <code class="language-plaintext highlighter-rouge">$990000</code>.</p>

<p><br /></p>
<div class="img_container">
  <center><img src="https://raw.githubusercontent.com/dotkay/tmp/main/algo_illustrations/kruskal_mst_2.PNG" /></center>
</div>
<p><br /></p>

  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy;  - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://dotkay.github.io/feed.xml">RSS</a>

    </p>

  </div>

</footer>


  </body>

</html>
